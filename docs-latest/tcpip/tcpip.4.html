<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML EXPERIMENTAL 970324//EN">
<HTML>
<HEAD><!--version 1.1.0/Tue Nov 21 11:01:39 GMT 2000-->
<META NAME="GENERATOR" CONTENT="Adobe FrameMaker 5.5/HTML Export Filter">
<LINK REL="STYLESHEET" HREF="cygnus.css">
<TITLE> TCP/IP Library Reference</TITLE></HEAD>
<BODY BGCOLOR="#ffffff">
<DIV>
<TABLE STYLE="ECOS" WIDTH="98%" BORDER="0" ALIGN="LEFT" CELLPADDING="1"><TR><TH COLSPAN="3" ALIGN="center"><P CLASS="Gotos">TCP/IP Library Reference</P></TH></TR><TR><TD  ALIGN="center"><P CLASS="Gotos"><A HREF="tcpip.html">Contents</A></P></TD><TD  ALIGN="center"><P CLASS="Gotos"><A HREF="tcpip.3.html">To&nbsp;previous&nbsp;page</A></P></TD><TD ALIGN="center"><P CLASS="Gotos"><A HREF="tcpip.5.html">To&nbsp;next&nbsp;page</A></P></TD></TR></TABLE><P ALIGN="LEFT">&nbsp;</P><BR><BR><HR ALIGN="center"></DIV>
<H2 CLASS="ChapterTitle">
<A NAME="pgfId=1135688">
 </A>
TCP/IP Library Reference<DIV>
<IMG SRC="botclear.gif">
</DIV>
</H2>
<UL>
<P><LI>
<A NAME="pgfId=1135689">
 </A>
<A HREF="tcpip.4.html#24888" CLASS="XRef">
 accept</A>
 </LI>
<P><LI>
<A NAME="pgfId=1135690">
 </A>
<A HREF="tcpip.4.html#38378" CLASS="XRef">
 bind</A>
 </LI>
<P><LI>
<A NAME="pgfId=1133667">
 </A>
<A HREF="tcpip.4.html#41085" CLASS="XRef">
 close</A>
 </LI>
<P><LI>
<A NAME="pgfId=1133668">
 </A>
<A HREF="tcpip.4.html#20905" CLASS="XRef">
 connect</A>
 </LI>
<P><LI>
<A NAME="pgfId=1133669">
 </A>
<A HREF="tcpip.4.html#14351" CLASS="XRef">
 gethostbyname, gethostbyaddr</A>
 </LI>
<P><LI>
<A NAME="pgfId=1133670">
 </A>
<A HREF="tcpip.4.html#37270" CLASS="XRef">
 getpeername</A>
 </LI>
<P><LI>
<A NAME="pgfId=1133671">
 </A>
<A HREF="tcpip.4.html#26916" CLASS="XRef">
 getprotobyname, getprotobynumber</A>
 </LI>
<P><LI>
<A NAME="pgfId=1133672">
 </A>
<A HREF="tcpip.4.html#25184" CLASS="XRef">
 getservent, getservbyname, getservbyport</A>
 </LI>
<P><LI>
<A NAME="pgfId=1133673">
 </A>
<A HREF="tcpip.4.html#40703" CLASS="XRef">
 getsockname</A>
 </LI>
<P><LI>
<A NAME="pgfId=1133674">
 </A>
<A HREF="tcpip.4.html#15867" CLASS="XRef">
 getsockopt</A>
 </LI>
<P><LI>
<A NAME="pgfId=1133675">
 </A>
<A HREF="tcpip.4.html#33318" CLASS="XRef">
 inet_aton, inet_addr, inet_ntoa</A>
</LI>
<P><LI>
<A NAME="pgfId=1133676">
 </A>
<A HREF="tcpip.4.html#40272" CLASS="XRef">
 ioctl</A>
 </LI>
<P><LI>
<A NAME="pgfId=1133677">
 </A>
<A HREF="tcpip.4.html#23489" CLASS="XRef">
 listen</A>
 </LI>
<P><LI>
<A NAME="pgfId=1133678">
 </A>
<A HREF="tcpip.4.html#14927" CLASS="XRef">
 read</A>
 </LI>
<P><LI>
<A NAME="pgfId=1133679">
 </A>
<A HREF="tcpip.4.html#35893" CLASS="XRef">
 recvfrom</A>
 </LI>
<P><LI>
<A NAME="pgfId=1133680">
 </A>
<A HREF="tcpip.4.html#20733" CLASS="XRef">
 select</A>
 </LI>
<P><LI>
<A NAME="pgfId=1133681">
 </A>
<A HREF="tcpip.4.html#27328" CLASS="XRef">
 sendto</A>
 </LI>
<P><LI>
<A NAME="pgfId=1133682">
 </A>
<A HREF="tcpip.4.html#22582" CLASS="XRef">
 setsockopt</A>
 </LI>
<P><LI>
<A NAME="pgfId=1133683">
 </A>
<A HREF="tcpip.4.html#33580" CLASS="XRef">
 shutdown</A>
 </LI>
<P><LI>
<A NAME="pgfId=1133684">
 </A>
<A HREF="tcpip.4.html#30054" CLASS="XRef">
 socket</A>
 </LI>
<P><LI>
<A NAME="pgfId=1133685">
 </A>
<A HREF="tcpip.4.html#33398" CLASS="XRef">
 write</A>
</LI>
</UL>
<DIV>
<H3 CLASS="manhead">
<A NAME="pgfId=1133752">
 </A>
<A NAME="24888">
 </A>
 accept</H3>
<PRE CLASS="CodeExample"><A NAME="pgfId=1133751"> </A>
NAME</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1133759"> </A>
       accept - accept a connection on a socket</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1133760"> </A>
</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1133761"> </A>
SYNOPSIS</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1133762"> </A>
       #include &lt;network.h&gt;</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1133763"> </A>
</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1133764"> </A>
       int accept(int s, struct sockaddr *addr, int *addrlen);</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1133765"> </A>
</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1133766"> </A>
DESCRIPTION</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1133767"> </A>
       The  argument  s  is  a  socket that has been created with</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1133768"> </A>
       socket(2), bound to an address with bind(2), and  is  lis-</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1133769"> </A>
       tening  for  connections  after  a  listen(2).  The accept</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1133770"> </A>
       function extracts the  first  connection  request  on  the</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1133771"> </A>
       queue  of  pending  connections, creates a new socket with</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1133772"> </A>
       the same  properties  of  s,  and  allocates  a  new  file</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1133773"> </A>
       descriptor  for the socket.  If no pending connections are</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1133774"> </A>
       present on the queue, and the socket is not marked as non-</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1133775"> </A>
       blocking,  accept  blocks the caller until a connection is</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1133776"> </A>
       present.  If the socket  is  marked  non-blocking  and  no</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1133777"> </A>
       pending  connections  are  present  on  the  queue, accept</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1133778"> </A>
       returns an error as described below.  The socket  returned</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1133779"> </A>
       by accept may not be used to accept more connections.  The</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1133780"> </A>
       original socket s remains open.</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1133781"> </A>
</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1133782"> </A>
       The argument addr is a result parameter that is filled  in</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1133783"> </A>
       with the address of the connecting entity, as known to the</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1133784"> </A>
       communications layer.  The exact format of the addr param-</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1133785"> </A>
       eter  is  determined by the domain in which the communica-</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1133786"> </A>
       tion is occurring.  addrlen is a  value-result  parameter:</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1133787"> </A>
       it should initially contain the amount of space pointed to</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1133788"> </A>
       by addr; on return it will contain the actual  length  (in</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1133789"> </A>
       bytes)  of  the  address returned.  This call is used with</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1133790"> </A>
       connection-based socket types, currently with SOCK_STREAM.</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1133791"> </A>
</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1133792"> </A>
       It  is  possible to select(2) a socket for the purposes of</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1133793"> </A>
       doing an accept by selecting it for read.</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1133794"> </A>
</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1133795"> </A>
       For certain protocols which require an explicit  confirma-</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1133796"> </A>
       tion,  such  as DECNet, accept can be thought of as merely</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1133797"> </A>
       dequeuing the next connection  request  and  not  implying</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1133798"> </A>
       confirmation.   Confirmation  can  be  implied by a normal</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1133799"> </A>
       read or write on the new file  descriptor,  and  rejection</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1133800"> </A>
       can  be  implied by closing the new socket. Currently only</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1133801"> </A>
       DECNet has these semantics on Linux.</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1133802"> </A>
</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1133803"> </A>
NOTES</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1133804"> </A>
       If you want accept to never  block  the  listening  socket</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1133805"> </A>
       needs  to  have  the  non blocking flag set. Assuming that</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1133806"> </A>
       there is always a connection waiting after select returned</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1133807"> </A>
       true  is  not  reliable,  because  the connection might be</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1133808"> </A>
       removed by  an  asynchronous  network  error  between  the</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1133809"> </A>
       select/poll returning and the accept call. The application</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1133810"> </A>
       would hang then if the listen socket is not non  blocking.</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1133811"> </A>
</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1133812"> </A>
RETURN VALUES</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1133813"> </A>
       The  call returns -1 on error.  If it succeeds, it returns</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1133814"> </A>
       a non-negative  integer  that  is  a  descriptor  for  the</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1133815"> </A>
       accepted socket.</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1133816"> </A>
</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1133817"> </A>
ERRORS</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1133818"> </A>
       EBADF   The descriptor is invalid.</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1133819"> </A>
</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1133820"> </A>
       ENOTSOCK</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1133821"> </A>
               The descriptor references a file, not a socket.</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1133822"> </A>
</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1133823"> </A>
       EOPNOTSUPP</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1133824"> </A>
               The referenced socket is not of type  SOCK_STREAM.</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1133825"> </A>
</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1133826"> </A>
       EAGAIN  The socket is marked non-blocking and  no  connec-</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1133827"> </A>
               tions are present to be accepted.</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1133828"> </A>
</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1133829"> </A>
       ENOBUFS, ENOMEM</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1133830"> </A>
               Not enough free memory.</PRE>
</DIV>
<DIV>
<H3 CLASS="manhead">
<A NAME="pgfId=1133831">
 </A>
<A NAME="38378">
 </A>
bind</H3>
<PRE CLASS="CodeExample"><A NAME="pgfId=1133832"> </A>
NAME</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1133842"> </A>
       bind - bind a name to a socket</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1133843"> </A>
</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1133844"> </A>
SYNOPSIS</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1133845"> </A>
       #include &lt;network.h&gt;</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1133846"> </A>
</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1133847"> </A>
       int   bind(int   sockfd,  struct  sockaddr  *my_addr,  int</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1133848"> </A>
       addrlen);</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1133849"> </A>
</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1133850"> </A>
DESCRIPTION</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1133851"> </A>
       bind gives the socket sockfd the  local  address  my_addr.</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1133852"> </A>
       my_addr  is  addrlen  bytes  long.  Traditionally, this is</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1133853"> </A>
       called &quot;assigning a name to a socket.&quot;  (When a socket  is</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1133854"> </A>
       created with socket(2), it exists in a name space (address</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1133855"> </A>
       family) but has no name assigned.)</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1133856"> </A>
</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1133857"> </A>
       Before a SOCK_STREAM socket is put into the  LISTEN  state</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1133858"> </A>
       to receive connections, you usually need to first assign a</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1133859"> </A>
       local address using bind to make the socket visible.</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1133860"> </A>
</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1133861"> </A>
NOTES</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1133862"> </A>
       Binding a name that is not in the  abstract  namespace  in</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1133863"> </A>
       the  UNIX  domain creates a socket in the file system that</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1133864"> </A>
       must be deleted by the caller when it is no longer  needed</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1133865"> </A>
       (using unlink(2)).</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1133866"> </A>
</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1133867"> </A>
       The  rules used in name binding vary between communication</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1133868"> </A>
       domains.  Consult the manual  entries  in  section  4  for</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1133869"> </A>
       detailed information. For IP see ip(4) and for PF_UNIX see</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1133870"> </A>
       unix(4).  If you want to listen to every  local  interface</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1133871"> </A>
       for  IPv4 set the sin_addr member of the IP-specific sock-</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1133872"> </A>
       addr_in to INADDR_ANY.  For IP  only  one  socket  may  be</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1133873"> </A>
       bound  to  a  specific  local address/port pair. For TCP a</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1133874"> </A>
       bound  local  socket  endpoint  (address/port   pair)   is</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1133875"> </A>
       unavailable for some time after closing the socket, unless</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1133876"> </A>
       the SO_REUSEADDR flag is set. Note that carelessly setting</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1133877"> </A>
       SO_REUSEADDR might make TCP more unreliable unless PAWS is</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1133878"> </A>
       used (see tcp(4)); the delay is needed to handle old pack-</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1133879"> </A>
       ets still in the network.</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1133880"> </A>
</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1133881"> </A>
       IP  sockets  may  also  bind  to  a broadcast or multicast</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1133882"> </A>
       address.</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1133883"> </A>
</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1133884"> </A>
RETURN VALUE</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1133885"> </A>
       On success, zero is returned.  On error, -1  is  returned,</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1133886"> </A>
       and errno is set appropriately.</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1133887"> </A>
</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1133888"> </A>
ERRORS</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1133889"> </A>
       EBADF   sockfd is not a valid descriptor.</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1133890"> </A>
</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1133891"> </A>
       EINVAL  The  socket  is already bound to an address.  This</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1133892"> </A>
               may change in the  future:  see  linux/unix/sock.c</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1133893"> </A>
               for details.</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1133894"> </A>
</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1133895"> </A>
       ENOTSOCK</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1133896"> </A>
               Argument is a descriptor for a file, not a socket.</PRE>
</DIV>
<DIV>
<H3 CLASS="manhead">
<A NAME="pgfId=1133897">
 </A>
<A NAME="41085">
 </A>
close</H3>
<PRE CLASS="CodeExample"><A NAME="pgfId=1133898"> </A>
NAME</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1133918"> </A>
       close - close a file descriptor</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1133919"> </A>
</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1133920"> </A>
SYNOPSIS</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1133921"> </A>
</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1133922"> </A>
       int close(int fd);</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1133923"> </A>
</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1133924"> </A>
DESCRIPTION</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1133925"> </A>
       close  closes  a  file  descriptor,  so  that it no longer</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1133926"> </A>
       refers to any file and may be reused.</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1133927"> </A>
</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1133928"> </A>
       If fd is the last copy of a particular file descriptor the</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1133929"> </A>
       resources associated with it are freed.</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1133930"> </A>
</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1133931"> </A>
RETURN VALUE</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1133932"> </A>
       close returns zero on success, or -1 if an error occurred.</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1133933"> </A>
</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1133934"> </A>
ERRORS</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1133935"> </A>
       EBADF  fd isn't a valid open file descriptor.</PRE>
</DIV>
<DIV>
<H3 CLASS="manhead">
<A NAME="pgfId=1133936">
 </A>
<A NAME="20905">
 </A>
connect</H3>
<PRE CLASS="CodeExample"><A NAME="pgfId=1133937"> </A>
NAME</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1133955"> </A>
       connect - initiate a connection on a socket</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1133956"> </A>
</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1133957"> </A>
SYNOPSIS</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1133958"> </A>
       #include &lt;network.h&gt;</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1133959"> </A>
</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1133960"> </A>
       int  connect(int  sockfd,  struct sockaddr *serv_addr, int</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1133961"> </A>
       addrlen);</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1133962"> </A>
</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1133963"> </A>
DESCRIPTION</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1133964"> </A>
       The parameter sockfd is a socket.  If  the  socket  is  of</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1133965"> </A>
       type  SOCK_DGRAM,  this call specifies the peer with which</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1133966"> </A>
       the socket is to be associated; this address  is  that  to</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1133967"> </A>
       which  datagrams are to be sent, and the only address from</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1133968"> </A>
       which datagrams are to be received.  If the socket  is  of</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1133969"> </A>
       type  SOCK_STREAM, this call attempts to make a connection</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1133970"> </A>
       to another socket.   The  other  socket  is  specified  by</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1133971"> </A>
       serv_addr, which is an address in the communications space</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1133972"> </A>
       of the socket.  Each communications space  interprets  the</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1133973"> </A>
       serv_addr  parameter  in  its  own way.  Generally, stream</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1133974"> </A>
       sockets may successfully connect only once; datagram sock-</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1133975"> </A>
       ets may use connect multiple times to change their associ-</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1133976"> </A>
       ation.  Datagram sockets may dissolve the  association  by</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1133977"> </A>
       connecting  to an address with the sa_family sockaddr mem-</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1133978"> </A>
       ber set to AF_UNSPEC.</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1133979"> </A>
</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1133980"> </A>
RETURN VALUE</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1133981"> </A>
       If the connection or binding succeeds, zero  is  returned.</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1133982"> </A>
       On  error, -1 is returned, and errno is set appropriately.</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1133983"> </A>
</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1133984"> </A>
ERRORS</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1133985"> </A>
       The following are general socket errors only.   There  may</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1133986"> </A>
       be other domain-specific error codes.</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1133987"> </A>
</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1133988"> </A>
       EBADF   Bad descriptor.</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1133989"> </A>
</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1133990"> </A>
       ENOTSOCK</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1133991"> </A>
               The descriptor is not associated with a socket.</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1133992"> </A>
</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1133993"> </A>
       EISCONN The socket is already connected.</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1133994"> </A>
</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1133995"> </A>
       ECONNREFUSED</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1133996"> </A>
               Connection refused at server.</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1133997"> </A>
</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1133998"> </A>
       ETIMEDOUT</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1133999"> </A>
               Timeout while attempting connection.</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134000"> </A>
</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134001"> </A>
       ENETUNREACH</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134002"> </A>
               Network is unreachable.</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134003"> </A>
</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134004"> </A>
       EADDRINUSE</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134005"> </A>
               Address is already in use.</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134006"> </A>
</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134007"> </A>
       EINPROGRESS</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134008"> </A>
               The socket is non-blocking and the connection can-</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134009"> </A>
               not  be  completed immediately.  It is possible to</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134010"> </A>
               select(2) or poll(2) for completion  by  selecting</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134011"> </A>
               the  socket  for  writing.  After select indicates</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134012"> </A>
               writability,  use  getsockopt(2)   to   read   the</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134013"> </A>
               SO_ERROR  option  at level SOL_SOCKET to determine</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134014"> </A>
               whether connect completed  successfully  (SO_ERROR</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134015"> </A>
               is zero) or unsuccessfully (SO_ERROR is one of the</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134016"> </A>
               usual error codes  listed  above,  explaining  the</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134017"> </A>
               reason for the failure).</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134018"> </A>
</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134019"> </A>
       EALREADY</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134020"> </A>
               The  socket is non-blocking and a previous connec-</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134021"> </A>
               tion attempt has not yet been completed.</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134022"> </A>
</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134023"> </A>
       EAFNOSUPPORT</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134024"> </A>
               The passed address didn't have the correct address</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134025"> </A>
               family in its sa_family field.</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134026"> </A>
</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134027"> </A>
       EACCES  The  user  tried to connect to a broadcast address</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134028"> </A>
               without having the socket broadcast flag  enabled.</PRE>
</DIV>
<DIV>
<H3 CLASS="manhead">
<A NAME="pgfId=1134029">
 </A>
<A NAME="14351">
 </A>
gethostbyname, gethostbyaddr</H3>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134030"> </A>
NAME</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134048"> </A>
       gethostbyname, gethostbyaddr, herror, hstrerror - get network host entry</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134049"> </A>
</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134050"> </A>
SYNOPSIS</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134051"> </A>
       #include &lt;network.h&gt;</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134052"> </A>
</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134053"> </A>
       struct hostent *gethostbyname(const char *name);</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134054"> </A>
</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134055"> </A>
       struct hostent *gethostbyaddr(const char *addr, int len, int type);</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134056"> </A>
</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134057"> </A>
       void herror(const char *s);</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134058"> </A>
</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134059"> </A>
       const char * hstrerror(int err);</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134060"> </A>
</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134061"> </A>
DESCRIPTION</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134062"> </A>
       The gethostbyname() function returns a structure  of  type</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134063"> </A>
       hostent  for  the  given host name.  Here name is either a</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134064"> </A>
       host name, or an IPv4 address in standard dot notation, or</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134065"> </A>
       an IPv6 address in colon (and possibly dot) notation. (See</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134066"> </A>
       RFC 1884 for the description of IPv6 addresses.)  If  name</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134067"> </A>
       is  an  IPv4  or  IPv6 address, no lookup is performed and</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134068"> </A>
       gethostbyname() simply copies name into the  h_name  field</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134069"> </A>
       and  its struct in_addr equivalent into the h_addr_list[0]</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134070"> </A>
       field of the returned hostent structure.  If name  doesn't</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134071"> </A>
       end  in  a dot and the environment variable HOSTALIASES is</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134072"> </A>
       set, the alias file pointed to by HOSTALIASES  will  first</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134073"> </A>
       be  searched for name.  (See hostname(7) for the file for</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134074"> </A>
       mat.)  The current domain and  its  parents  are  searched</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134075"> </A>
       unless name ends in a dot.</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134076"> </A>
</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134077"> </A>
       The  gethostbyaddr()  function returns a structure of type</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134078"> </A>
       hostent for the given host address addr of length len  and</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134079"> </A>
       address  type  type.   The only valid address type is cur</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134080"> </A>
       rently AF_INET.</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134081"> </A>
</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134082"> </A>
       The  (obsolete) herror() function prints the error message</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134083"> </A>
       associated with the current value of h_errno on stderr.</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134084"> </A>
</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134085"> </A>
       The (obsolete) hstrerror() function takes an error  number</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134086"> </A>
       (typically  h_errno) and returns the corresponding message</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134087"> </A>
       string.</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134088"> </A>
</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134089"> </A>
       The domain name queries carried out by gethostbyname() and</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134090"> </A>
       gethostbyaddr()  use  a  combination  of any or all of the</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134091"> </A>
       name server named(8), a broken out line  from  /etc/hosts,</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134092"> </A>
       and the Network Information Service (NIS or YP), depending</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134093"> </A>
       upon the contents of the  order  line  in  /etc/host.conf.</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134094"> </A>
       (See   resolv+(8)).    The  default  action  is  to  query</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134095"> </A>
       named(8), followed by /etc/hosts.</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134096"> </A>
</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134097"> </A>
       The hostent structure is defined in &lt;netdb.h&gt; as follows:</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134098"> </A>
</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134099"> </A>
              struct hostent {</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134100"> </A>
                      char    *h_name;        /* official name of host */</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134101"> </A>
                      char    **h_aliases;    /* alias list */</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134102"> </A>
                      int     h_addrtype;     /* host address type */</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134103"> </A>
                      int     h_length;       /* length of address */</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134104"> </A>
                      char    **h_addr_list;  /* list of addresses */</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134105"> </A>
              }</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134106"> </A>
              #define h_addr  h_addr_list[0]  /* for backward compatibility */</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134107"> </A>
</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134108"> </A>
       The members of the hostent structure are:</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134109"> </A>
</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134110"> </A>
       h_name The official name of the host.</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134111"> </A>
</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134112"> </A>
       h_aliases</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134113"> </A>
              A zero-terminated array of  alternative  names  for</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134114"> </A>
              the host.</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134115"> </A>
</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134116"> </A>
       h_addrtype</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134117"> </A>
              The type of address; always AF_INET at present.</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134118"> </A>
</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134119"> </A>
       h_length</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134120"> </A>
              The length of the address in bytes.</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134121"> </A>
</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134122"> </A>
       h_addr_list</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134123"> </A>
              A  zero-terminated  array  of network addresses for</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134124"> </A>
              the host in network byte order.</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134125"> </A>
</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134126"> </A>
       h_addr The first address in h_addr_list for backward  com</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134127"> </A>
              patibility.</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134128"> </A>
</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134129"> </A>
RETURN VALUE</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134130"> </A>
       The  gethostbyname()  and gethostbyaddr() functions return</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134131"> </A>
       the hostent structure  or  a  NULL  pointer  if  an  error</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134132"> </A>
       occurs.   On  error,  the  h_errno variable holds an error</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134133"> </A>
       number.</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134134"> </A>
</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134135"> </A>
ERRORS</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134136"> </A>
       The variable h_errno can have the following values:</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134137"> </A>
</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134138"> </A>
       HOST_NOT_FOUND</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134139"> </A>
              The specified host is unknown.</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134140"> </A>
</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134141"> </A>
       NO_ADDRESS or NO_DATA</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134142"> </A>
              The requested name is valid but does not have an IP</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134143"> </A>
              address.</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134144"> </A>
</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134145"> </A>
       NO_RECOVERY</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134146"> </A>
              A non-recoverable name server error occurred.</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134147"> </A>
</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134148"> </A>
       TRY_AGAIN</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134149"> </A>
              A temporary error occurred on an authoritative name</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134150"> </A>
              server.  Try again later.</PRE>
</DIV>
<DIV>
<H3 CLASS="manhead">
<A NAME="pgfId=1134151">
 </A>
<A NAME="37270">
 </A>
getpeername</H3>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134152"> </A>
NAME</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134182"> </A>
       getpeername - get name of connected peer</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134183"> </A>
</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134184"> </A>
SYNOPSIS</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134185"> </A>
       #include &lt;network.h&gt;</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134186"> </A>
</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134187"> </A>
       int  getpeername(int  s,  struct sockaddr *name, socklen_t</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134188"> </A>
       *namelen);</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134189"> </A>
</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134190"> </A>
DESCRIPTION</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134191"> </A>
       Getpeername returns the name  of  the  peer  connected  to</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134192"> </A>
       socket  s.  The namelen parameter should be initialized to</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134193"> </A>
       indicate the amount of  space  pointed  to  by  name.   On</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134194"> </A>
       return  it  contains  the actual size of the name returned</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134195"> </A>
       (in bytes).  The name is truncated if the buffer  provided</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134196"> </A>
       is too small.</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134197"> </A>
</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134198"> </A>
RETURN VALUE</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134199"> </A>
       On  success,  zero is returned.  On error, -1 is returned,</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134200"> </A>
       and errno is set appropriately.</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134201"> </A>
</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134202"> </A>
ERRORS</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134203"> </A>
       EBADF   The argument s is not a valid descriptor.</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134204"> </A>
</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134205"> </A>
       ENOTSOCK</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134206"> </A>
               The argument s is a file, not a socket.</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134207"> </A>
</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134208"> </A>
       ENOTCONN</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134209"> </A>
               The socket is not connected.</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134210"> </A>
</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134211"> </A>
       ENOBUFS Insufficient resources were available in the  sys-</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134212"> </A>
               tem to perform the operation.</PRE>
</DIV>
<DIV>
<H3 CLASS="manhead">
<A NAME="pgfId=1134213">
 </A>
<A NAME="26916">
 </A>
getprotobyname, getprotobynumber</H3>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134214"> </A>
NAME</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134224"> </A>
       getprotobyname,  getprotobynumber - get protocol entry</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134225"> </A>
</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134226"> </A>
SYNOPSIS</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134227"> </A>
       #include &lt;network.h&gt;</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134228"> </A>
</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134229"> </A>
       struct protoent *getprotobyname(const char *name);</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134230"> </A>
</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134231"> </A>
       struct protoent *getprotobynumber(int proto);</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134232"> </A>
</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134233"> </A>
DESCRIPTION</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134234"> </A>
       The getprotobyname() function returns a protoent structure</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134235"> </A>
       for the line from /etc/protocols that matches the protocol</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134236"> </A>
       name name.</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134237"> </A>
</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134238"> </A>
       The  getprotobynumber() function returns a protoent struc</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134239"> </A>
       ture for the line that matches the protocol number number.</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134240"> </A>
</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134241"> </A>
       The protoent structure is defined in  as follows:</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134242"> </A>
</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134243"> </A>
              struct protoent {</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134244"> </A>
                      char    *p_name;        /* official protocol name */</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134245"> </A>
                      char    **p_aliases;    /* alias list */</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134246"> </A>
                      int     p_proto;        /* protocol number */</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134247"> </A>
              }</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134248"> </A>
</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134249"> </A>
       The members of the protoent structure are:</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134250"> </A>
</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134251"> </A>
       p_name The official name of the protocol.</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134252"> </A>
</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134253"> </A>
       p_aliases</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134254"> </A>
              A zero terminated list of alternative names for the</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134255"> </A>
              protocol.</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134256"> </A>
       p_proto</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134257"> </A>
              The protocol number.</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134258"> </A>
</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134259"> </A>
RETURN VALUE</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134260"> </A>
       The getprotobyname() and getprotobynumber()</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134261"> </A>
       functions return the protoent structure, or a NULL pointer</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134262"> </A>
       if an error occurs.</PRE>
</DIV>
<DIV>
<H3 CLASS="manhead">
<A NAME="pgfId=1134263">
 </A>
<A NAME="25184">
 </A>
getservent, getservbyname, getservbyport</H3>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134264"> </A>
NAME</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134282"> </A>
       getservent, getservbyname, getservbyport - get service entry</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134283"> </A>
</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134284"> </A>
SYNOPSIS</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134285"> </A>
       #include &lt;network.h&gt;</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134286"> </A>
</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134287"> </A>
       struct servent *getservbyname(const char *name, const char *proto);</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134288"> </A>
</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134289"> </A>
       struct servent *getservbyport(int port, const char *proto);</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134290"> </A>
</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134291"> </A>
DESCRIPTION</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134292"> </A>
       The  getservbyname()  function returns a servent structure</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134293"> </A>
       for the line from /etc/services that matches  the  service</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134294"> </A>
       name using protocol proto.</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134295"> </A>
</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134296"> </A>
       The  getservbyport()  function returns a servent structure</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134297"> </A>
       for the line that matches the port port given  in  network</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134298"> </A>
       byte order using protocol proto.</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134299"> </A>
</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134300"> </A>
       The servent structure is defined in &lt;netdb.h&gt; as follows:</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134301"> </A>
</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134302"> </A>
              struct servent {</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134303"> </A>
                      char    *s_name;        /* official service name */</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134304"> </A>
                      char    **s_aliases;    /* alias list */</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134305"> </A>
                      int     s_port;         /* port number */</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134306"> </A>
                      char    *s_proto;       /* protocol to use */</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134307"> </A>
              }</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134308"> </A>
</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134309"> </A>
       The members of the servent structure are:</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134310"> </A>
</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134311"> </A>
       s_name The official name of the service.</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134312"> </A>
</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134313"> </A>
       s_aliases</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134314"> </A>
              A zero terminated list of alternative names for the</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134315"> </A>
              service.</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134316"> </A>
</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134317"> </A>
       s_port The  port  number  for the service given in network</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134318"> </A>
              byte order.</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134319"> </A>
</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134320"> </A>
       s_proto</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134321"> </A>
              The name of the protocol to use with this  service.</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134322"> </A>
</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134323"> </A>
RETURN VALUE</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134324"> </A>
       The   getservbyname()  and  getservbyport()</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134325"> </A>
       functions return the servent structure, or a NULL  pointer</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134326"> </A>
       if an error occurs.</PRE>
</DIV>
<DIV>
<H3 CLASS="manhead">
<A NAME="pgfId=1134327">
 </A>
<A NAME="40703">
 </A>
getsockname</H3>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134328"> </A>
NAME</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134348"> </A>
       getsockname - get socket name</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134349"> </A>
</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134350"> </A>
SYNOPSIS</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134351"> </A>
       #include &lt;network.h&gt;</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134352"> </A>
</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134353"> </A>
       int   getsockname(int   s  ,  struct  sockaddr  *  name  ,</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134354"> </A>
       socklen_t * namelen )</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134355"> </A>
</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134356"> </A>
DESCRIPTION</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134357"> </A>
       Getsockname returns the current  name  for  the  specified</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134358"> </A>
       socket.   The  namelen  parameter should be initialized to</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134359"> </A>
       indicate the amount of  space  pointed  to  by  name.   On</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134360"> </A>
       return  it  contains  the actual size of the name returned</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134361"> </A>
       (in bytes).</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134362"> </A>
</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134363"> </A>
RETURN VALUE</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134364"> </A>
       On success, zero is returned.  On error, -1  is  returned,</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134365"> </A>
       and  errno  is  set appropriately.  A 0 is returned if the</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134366"> </A>
       call succeeds, -1 if it fails.</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134367"> </A>
</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134368"> </A>
ERRORS</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134369"> </A>
       EBADF   The argument s is not a valid descriptor.</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134370"> </A>
</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134371"> </A>
       ENOTSOCK</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134372"> </A>
               The argument s is a file, not a socket.</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134373"> </A>
</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134374"> </A>
       ENOBUFS Insufficient resources were available in the  sys-</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134375"> </A>
               tem to perform the operation.</PRE>
</DIV>
<DIV>
<H3 CLASS="manhead">
<A NAME="pgfId=1134376">
 </A>
<A NAME="15867">
 </A>
getsockopt</H3>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134377"> </A>
NAME</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134387"> </A>
       getsockopt, setsockopt - get and set options on sockets</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134388"> </A>
</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134389"> </A>
SYNOPSIS</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134390"> </A>
       #include &lt;network.h&gt;</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134391"> </A>
</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134392"> </A>
       int  getsockopt(int  s, int level, int optname, void *opt</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134393"> </A>
       val, socklen_t *optlen);</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134394"> </A>
</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134395"> </A>
       int setsockopt(int s, int level, int optname,  const  void</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134396"> </A>
       *optval, socklen_t optlen);</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134397"> </A>
</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134398"> </A>
DESCRIPTION</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134399"> </A>
       Getsockopt  and  setsockopt manipulate the options associ</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134400"> </A>
       ated with a socket.  Options may exist at multiple  proto</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134401"> </A>
       col  levels;  they  are  always  present  at the uppermost</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134402"> </A>
       socket level.</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134403"> </A>
</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134404"> </A>
       When manipulating socket options the level  at  which  the</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134405"> </A>
       option  resides  and the name of the option must be speci</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134406"> </A>
       fied.  To manipulate options at the socket level, level is</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134407"> </A>
       specified  as  SOL_SOCKET.   To  manipulate options at any</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134408"> </A>
       other level the protocol number of the appropriate  proto</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134409"> </A>
       col  controlling  the option is supplied.  For example, to</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134410"> </A>
       indicate that an option is to be interpreted  by  the  TCP</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134411"> </A>
       protocol,  level  should  be set to the protocol number of</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134412"> </A>
       TCP; see getprotoent(3).</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134413"> </A>
</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134414"> </A>
       The parameters optval and optlen are used to access option</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134415"> </A>
       values  for  setsockopt.   For  getsockopt they identify a</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134416"> </A>
       buffer in which the value for the requested option(s)  are</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134417"> </A>
       to  be returned.  For getsockopt, optlen is a value-result</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134418"> </A>
       parameter, initially containing the  size  of  the  buffer</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134419"> </A>
       pointed  to  by optval, and modified on return to indicate</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134420"> </A>
       the actual size of the value returned.  If no option value</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134421"> </A>
       is to be supplied or returned, optval may be NULL.</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134422"> </A>
</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134423"> </A>
       Optname and any specified options are passed uninterpreted</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134424"> </A>
       to the appropriate  protocol  module  for  interpretation.</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134425"> </A>
       The  include  file &lt;network.h&gt; contains definitions for</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134426"> </A>
       socket level options, described below.  Options  at  other</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134427"> </A>
       protocol  levels  vary  in  format  and  name; consult the</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134428"> </A>
       appropriate entries in section 4 of the manual.</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134429"> </A>
</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134430"> </A>
       Most socket-level options utilize  an  int  parameter  for</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134431"> </A>
       optval.   For setsockopt, the parameter should be non-zero</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134432"> </A>
       to enable a boolean option, or zero if the option is to be</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134433"> </A>
       disabled.</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134434"> </A>
</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134435"> </A>
       For  a  description  of  the  available socket options see</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134436"> </A>
       socket(7) and the appropriate protocol man pages.</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134437"> </A>
</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134438"> </A>
RETURN VALUE</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134439"> </A>
       On success, zero is returned.  On error, -1  is  returned,</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134440"> </A>
       and errno is set appropriately.</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134441"> </A>
</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134442"> </A>
ERRORS</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134443"> </A>
       EBADF   The argument s is not a valid descriptor.</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134444"> </A>
</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134445"> </A>
       ENOTSOCK</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134446"> </A>
               The argument s is a file, not a socket.</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134447"> </A>
</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134448"> </A>
       ENOPROTOOPT</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134449"> </A>
               The option is unknown at the level indicated.</PRE>
</DIV>
<DIV>
<H3 CLASS="manhead">
<A NAME="pgfId=1134450">
 </A>
<A NAME="33318">
 </A>
inet_aton, inet_addr, inet_ntoa</H3>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134451"> </A>
NAME</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134469"> </A>
       inet_aton, inet_addr, inet_ntoa -  Internet  address</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134470"> </A>
       manipulation routines</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134471"> </A>
</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134472"> </A>
SYNOPSIS</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134473"> </A>
       #include &lt;network.h&gt;</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134474"> </A>
</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134475"> </A>
       int inet_aton(const char *cp, struct in_addr *inp);</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134476"> </A>
</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134477"> </A>
       unsigned long int inet_addr(const char *cp);</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134478"> </A>
</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134479"> </A>
       char *inet_ntoa(struct in_addr in);</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134480"> </A>
</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134481"> </A>
DESCRIPTION</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134482"> </A>
       inet_aton() converts the Internet host address cp from the</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134483"> </A>
       standard numbers-and-dots notation into  binary  data  and</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134484"> </A>
       stores  it  in the structure that inp points to. inet_aton</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134485"> </A>
       returns nonzero if the address is valid, zero if not.</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134486"> </A>
</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134487"> </A>
       The  inet_addr()  function  converts  the  Internet   host</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134488"> </A>
       address cp from numbers-and-dots notation into binary data</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134489"> </A>
       in  network  byte  order.   If  the  input   is   invalid,</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134490"> </A>
       INADDR_NONE (usually -1) is returned.  This is an obsolete</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134491"> </A>
       interface to inet_aton, described immediately above; it is</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134492"> </A>
       obsolete  because -1 is a valid address (255.255.255.255),</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134493"> </A>
       and inet_aton provides a cleaner  way  to  indicate  error</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134494"> </A>
       return.</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134495"> </A>
</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134496"> </A>
       The   inet_ntoa()  function  converts  the  Internet  host</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134497"> </A>
       address in given in network byte  order  to  a  string  in</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134498"> </A>
       standard   numbers-and-dots   notation.    The  string  is</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134499"> </A>
       returned in a statically allocated  buffer,  which  subse</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134500"> </A>
       quent calls will overwrite.</PRE>
</DIV>
<DIV>
<H3 CLASS="manhead">
<A NAME="pgfId=1134501">
 </A>
<A NAME="40272">
 </A>
ioctl</H3>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134502"> </A>
NAME</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134519"> </A>
       ioctl - control device</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134520"> </A>
</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134521"> </A>
SYNOPSIS</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134522"> </A>
       #include </PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134523"> </A>
</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134524"> </A>
       int ioctl(int d, int request, ...)</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134525"> </A>
</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134526"> </A>
       [The  &quot;third&quot;  argument  is  traditionally char *argp, and</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134527"> </A>
       will be so named for this discussion.]</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134528"> </A>
</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134529"> </A>
DESCRIPTION</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134530"> </A>
       The  ioctl  function  manipulates  the  underlying  device</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134531"> </A>
       parameters  of special files.  In particular, many operat-</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134532"> </A>
       ing characteristics of sockets and network devices</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134533"> </A>
       may be controlled with ioctl requests.  The argu-</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134534"> </A>
       ment d must be an open file descriptor.</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134535"> </A>
</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134536"> </A>
       An ioctl request has encoded in it whether the argument is</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134537"> </A>
       an  in  parameter  or  out  parameter, and the size of the</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134538"> </A>
       argument argp in bytes.  Macros and defines used in speci-</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134539"> </A>
       fying   an   ioctl   request   are  located  in  the  file</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134540"> </A>
       .</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134541"> </A>
</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134542"> </A>
RETURN VALUE</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134543"> </A>
       On success, zero is returned.  On error, -1  is  returned,</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134544"> </A>
       and errno is set appropriately.</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134545"> </A>
</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134546"> </A>
ERRORS</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134547"> </A>
       EBADF  d is not a valid descriptor.</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134548"> </A>
</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134549"> </A>
       EFAULT argp references an inaccessible memory area.</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134550"> </A>
</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134551"> </A>
       ENOTTY d  is  not  associated  with  a  character  special</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134552"> </A>
              device.</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134553"> </A>
</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134554"> </A>
       ENOTTY The specified request does not apply to the kind of</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134555"> </A>
              object that the descriptor d references.</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134556"> </A>
</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134557"> </A>
       EINVAL Request or argp is not valid.</PRE>
</DIV>
<DIV>
<H3 CLASS="manhead">
<A NAME="pgfId=1134558">
 </A>
<A NAME="23489">
 </A>
listen</H3>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134559"> </A>
NAME</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134567"> </A>
       listen - listen for connections on a socket</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134568"> </A>
</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134569"> </A>
SYNOPSIS</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134570"> </A>
       #include &lt;network.h&gt;</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134571"> </A>
</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134572"> </A>
       int listen(int s, int backlog);</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134573"> </A>
</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134574"> </A>
DESCRIPTION</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134575"> </A>
       To  accept  connections,  a  socket  is first created with</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134576"> </A>
       socket(2), a willingness to  accept  incoming  connections</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134577"> </A>
       and  a  queue limit for incoming connections are specified</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134578"> </A>
       with listen, and then the connections  are  accepted  with</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134579"> </A>
       accept(2).   The  listen  call  applies only to sockets of</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134580"> </A>
       type SOCK_STREAM or SOCK_SEQPACKET.</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134581"> </A>
</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134582"> </A>
       The backlog parameter defines the maximum length the queue</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134583"> </A>
       of  pending  connections  may  grow  to.   If a connection</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134584"> </A>
       request arrives with the queue full the client may receive</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134585"> </A>
       an  error  with  an  indication of ECONNREFUSED or, if the</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134586"> </A>
       underlying protocol supports retransmission,  the  request</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134587"> </A>
       may be ignored so that retries may succeed.</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134588"> </A>
</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134589"> </A>
RETURN VALUE</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134590"> </A>
       On success, zero is returned.  On error, -1  is  returned,</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134591"> </A>
       and errno is set appropriately.</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134592"> </A>
</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134593"> </A>
ERRORS</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134594"> </A>
       EBADF   The argument s is not a valid descriptor.</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134595"> </A>
</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134596"> </A>
       ENOTSOCK</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134597"> </A>
               The argument s is not a socket.</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134598"> </A>
</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134599"> </A>
       EOPNOTSUPP</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134600"> </A>
               The socket is not of a type that supports the lis-</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134601"> </A>
               ten operation.</PRE>
</DIV>
<DIV>
<H3 CLASS="manhead">
<A NAME="pgfId=1134602">
 </A>
<A NAME="14927">
 </A>
read</H3>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134603"> </A>
NAME</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134621"> </A>
       read - read from a file descriptor</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134622"> </A>
</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134623"> </A>
SYNOPSIS</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134624"> </A>
       ssize_t read(int fd, void *buf, size_t count);</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134625"> </A>
</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134626"> </A>
DESCRIPTION</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134627"> </A>
       read()  attempts  to  read  up  to  count  bytes from file</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134628"> </A>
       descriptor fd into the buffer starting at buf.</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134629"> </A>
</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134630"> </A>
       If count is zero, read() returns zero  and  has  no  other</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134631"> </A>
       results.</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134632"> </A>
</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134633"> </A>
</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134634"> </A>
RETURN VALUE</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134635"> </A>
       On success, the number of bytes  read  is  returned  (zero</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134636"> </A>
       indicates  end of file), and the file position is advanced</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134637"> </A>
       by this number.  It is not an  error  if  this  number  is</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134638"> </A>
       smaller  than the number of bytes requested; this may hap-</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134639"> </A>
       pen for example because fewer bytes are actually available</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134640"> </A>
       right  now (maybe because we were close to end-of-file, or</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134641"> </A>
       because we are reading from a pipe, or from  a  terminal),</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134642"> </A>
       or  because read() was interrupted by a signal.  On error,</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134643"> </A>
       -1 is returned, and errno is set  appropriately.  In  this</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134644"> </A>
       case  it is left unspecified whether the file position (if</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134645"> </A>
       any) changes.</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134646"> </A>
</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134647"> </A>
ERRORS</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134648"> </A>
       EINTR   The call was interrupted by a  signal  before  any</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134649"> </A>
               data was read.</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134650"> </A>
</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134651"> </A>
       EAGAIN  Non-blocking  I/O  has  been selected using O_NON-</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134652"> </A>
               BLOCK and no data was  immediately  available  for</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134653"> </A>
               reading.</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134654"> </A>
</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134655"> </A>
       EIO     I/O  error.  This will happen for example when the</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134656"> </A>
               process is in a background process group, tries to</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134657"> </A>
               read  from  its  controlling tty, and either it is</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134658"> </A>
               ignoring or blocking SIGTTIN or its process  group</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134659"> </A>
               is  orphaned.   It  may also occur when there is a</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134660"> </A>
               low-level I/O error while reading from a  disk  or</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134661"> </A>
               tape.</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134662"> </A>
</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134663"> </A>
      EISDIR  fd refers to a directory.</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134664"> </A>
</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134665"> </A>
       EBADF   fd  is  not a valid file descriptor or is not open</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134666"> </A>
               for reading.</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134667"> </A>
</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134668"> </A>
       EINVAL  fd is attached to an object  which  is  unsuitable</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134669"> </A>
               for reading.</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134670"> </A>
</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134671"> </A>
       Other  errors may occur, depending on the object connected</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134672"> </A>
       to fd.  POSIX allows a  read  that  is  interrupted  after</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134673"> </A>
       reading  some  data to return -1 (with errno set to EINTR)</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134674"> </A>
       or to return the number of bytes already read.</PRE>
</DIV>
<DIV>
<H3 CLASS="manhead">
<A NAME="pgfId=1134675">
 </A>
<A NAME="35893">
 </A>
recvfrom</H3>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134676"> </A>
NAME</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134692"> </A>
       recvfrom - receive a message from a socket</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134693"> </A>
</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134694"> </A>
SYNOPSIS</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134695"> </A>
       #include &lt;network.h&gt;</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134696"> </A>
</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134697"> </A>
       int recvfrom(int s, void *buf, int len, unsigned int flags</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134698"> </A>
       struct sockaddr *from, int *fromlen);</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134699"> </A>
</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134700"> </A>
DESCRIPTION</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134701"> </A>
       The  recvfrom call is used to receive messages from a socket, </PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134702"> </A>
       and may be used to receive data on a socket whether or not it </PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134703"> </A>
       is connection-oriented.</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134704"> </A>
</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134705"> </A>
</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134706"> </A>
       If from is not NULL, and the socket is not connection-ori</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134707"> </A>
       ented, the source address of the  message  is  filled  in.</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134708"> </A>
       Fromlen  is  a  value-result parameter, initialized to the</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134709"> </A>
       size of the buffer associated with from, and  modified  on</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134710"> </A>
       return  to  indicate the actual size of the address stored</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134711"> </A>
       there.</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134712"> </A>
</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134713"> </A>
       The routine  returns  the length of the message on</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134714"> </A>
       successful completion.  If a message is too long to fit in</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134715"> </A>
       the supplied buffer, excess bytes may be discarded depend</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134716"> </A>
       ing on the type of socket the  message  is  received  from</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134717"> </A>
       (see socket(2)).</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134718"> </A>
</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134719"> </A>
       If  no  messages  are available at the socket, the receive</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134720"> </A>
       calls wait for a message to arrive, unless the  socket  is</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134721"> </A>
       nonblocking  (see  fcntl(2)) in which case the value -1 is</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134722"> </A>
       returned and the external variable errno  set  to  EAGAIN.</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134723"> </A>
       The  receive  calls normally return any data available, up</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134724"> </A>
       to the requested amount, rather than waiting  for  receipt</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134725"> </A>
       of the full amount requested.</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134726"> </A>
</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134727"> </A>
       The  select(2)  call may be used to determine</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134728"> </A>
       when more data arrives.</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134729"> </A>
</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134730"> </A>
       The flags argument to a recvfrom call is formed by OR'ing  one</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134731"> </A>
       or more of the following values:</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134732"> </A>
</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134733"> </A>
       MSG_OOB</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134734"> </A>
              This flag requests receipt of out-of-band data that</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134735"> </A>
              would not be received in the  normal  data  stream.</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134736"> </A>
              Some  protocols place expedited data at the head of</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134737"> </A>
              the normal data queue, and thus this flag cannot be</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134738"> </A>
              used with such protocols.</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134739"> </A>
</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134740"> </A>
       MSG_PEEK</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134741"> </A>
              This  flag  causes  the receive operation to return</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134742"> </A>
              data from the beginning of the receive queue  with</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134743"> </A>
              out  removing  that  data  from the queue.  Thus, a</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134744"> </A>
              subsequent receive call will return the same  data.</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134745"> </A>
</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134746"> </A>
       MSG_WAITALL</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134747"> </A>
              This  flag  requests that the operation block until</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134748"> </A>
              the full request is satisfied.  However,  the  call</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134749"> </A>
              may still return less data than requested if a sig</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134750"> </A>
              nal is caught, an error or  disconnect  occurs,  or</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134751"> </A>
              the next data to be received is of a different type</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134752"> </A>
              than that returned.</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134753"> </A>
</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134754"> </A>
       MSG_ERRQUEUE</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134755"> </A>
              Receive packet from the error queue</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134756"> </A>
</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134757"> </A>
       MSG_NOSIGNAL</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134758"> </A>
              This flag turns off raising of  SIGPIPE  on  stream</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134759"> </A>
              sockets when the other end disappears.</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134760"> </A>
</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134761"> </A>
       MSG_ERRQUEUE</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134762"> </A>
              This  flag  specifies  that queued errors should be</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134763"> </A>
              received from the socket error queue.  The error is</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134764"> </A>
              passed  in  a ancilliary message with a type depen</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134765"> </A>
              dent on the  protocol  (for  IP  IP_RECVERR).   The</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134766"> </A>
              error  is  supplied in a sock_extended_error struc</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134767"> </A>
              ture:</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134768"> </A>
</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134769"> </A>
              #define SO_EE_ORIGIN_NONE       0</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134770"> </A>
              #define SO_EE_ORIGIN_LOCAL      1</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134771"> </A>
              #define SO_EE_ORIGIN_ICMP       2</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134772"> </A>
              #define SO_EE_ORIGIN_ICMP6      3</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134773"> </A>
</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134774"> </A>
              struct sock_extended_err</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134775"> </A>
              {</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134776"> </A>
                  __u32           ee_errno;   /* error number */</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134777"> </A>
                  __u8            ee_origin;  /* where the error originated */</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134778"> </A>
                  __u8            ee_type;    /* type */</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134779"> </A>
                  __u8            ee_code;    /* code */</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134780"> </A>
                  __u8            ee_pad;</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134781"> </A>
                  __u32           ee_info;    /* additional information */</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134782"> </A>
                  __u32           ee_data;    /* other data */</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134783"> </A>
              };</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134784"> </A>
</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134785"> </A>
              struct sockaddr *SOCK_EE_OFFENDER(struct sock_extended_err *);</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134786"> </A>
</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134787"> </A>
              ee_errno contains the errno number  of  the  queued</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134788"> </A>
              error.   ee_origin  is the origin code of where the</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134789"> </A>
              error originated.  The other  fields  are  protocol</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134790"> </A>
              specific.   SOCK_EE_OFFENDER  returns  a pointer to</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134791"> </A>
              the address of the network object where  the  error</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134792"> </A>
              originated  from. If this address is not known, the</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134793"> </A>
              sa_family member of the sockaddr contains AF_UNSPEC</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134794"> </A>
              and the other fields of the sockaddr are undefined.</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134795"> </A>
              The payload of the packet that caused the error  is</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134796"> </A>
              passed as normal data.</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134797"> </A>
</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134798"> </A>
              For local errors, no address is passed (this can be</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134799"> </A>
              checked with the cmsg_len member of  the  cmsghdr).</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134800"> </A>
              For  error receives, the MSG_ERRQUEUE is set in the</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134801"> </A>
              msghdr.  After a error has been passed, the pending</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134802"> </A>
              socket  error  is  regenerated  based  on  the next</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134803"> </A>
              queued error and will be passed on the next  socket</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134804"> </A>
              operation.</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134805"> </A>
</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134806"> </A>
</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134807"> </A>
       The msg_flags field is set on return according to the mes</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134808"> </A>
       sage  received.  MSG_EOR indicates end-of-record; the data</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134809"> </A>
       returned completed a record (generally used  with  sockets</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134810"> </A>
       of  type  SOCK_SEQPACKET).   MSG_TRUNC  indicates that the</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134811"> </A>
       trailing portion of a datagram was discarded  because  the</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134812"> </A>
       datagram  was larger than the buffer supplied.  MSG_CTRUNC</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134813"> </A>
       indicates that some control data  were  discarded  due  to</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134814"> </A>
       lack  of  space in the buffer for ancillary data.  MSG_OOB</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134815"> </A>
       is returned to indicate that expedited or out-of-band data</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134816"> </A>
       were  received.   MSG_ERRQUEUE  indicates that no data was</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134817"> </A>
       received but an  extended  error  from  the  socket  error</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134818"> </A>
       queue.</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134819"> </A>
</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134820"> </A>
RETURN VALUES</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134821"> </A>
       These  calls return the number of bytes received, or -1 if</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134822"> </A>
       an error occurred.</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134823"> </A>
</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134824"> </A>
ERRORS</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134825"> </A>
       These are some standard errors  generated  by  the  socket</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134826"> </A>
       layer.  Additional  errors  may  be generated and returned</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134827"> </A>
       from the underlying protocol  modules;  see  their  manual</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134828"> </A>
       pages.</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134829"> </A>
</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134830"> </A>
       EBADF   The argument s is an invalid descriptor.</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134831"> </A>
</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134832"> </A>
       ENOTSOCK</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134833"> </A>
               The argument s does not refer to a socket.</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134834"> </A>
</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134835"> </A>
       EAGAIN  The  socket is marked non-blocking and the receive</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134836"> </A>
               operation would block, or a  receive  timeout  had</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134837"> </A>
               been  set  and the timeout expired before data was</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134838"> </A>
               received.</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134839"> </A>
</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134840"> </A>
       EINTR   The receive was interrupted by delivery of a  sig</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134841"> </A>
               nal before any data were available.</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134842"> </A>
</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134843"> </A>
       EINVAL  Invalid argument passed.</PRE>
</DIV>
<DIV>
<H3 CLASS="manhead">
<A NAME="pgfId=1134844">
 </A>
<A NAME="20733">
 </A>
select</H3>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134845"> </A>
NAME</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134877"> </A>
       select,  FD_CLR,  FD_ISSET,  FD_SET, FD_ZERO - synchronous</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134878"> </A>
       I/O multiplexing</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134879"> </A>
</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134880"> </A>
SYNOPSIS</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134881"> </A>
       #include &lt;network.h&gt;</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134882"> </A>
</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134883"> </A>
       int  select(int  n,  fd_set  *readfds,  fd_set  *writefds,</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134884"> </A>
       fd_set *exceptfds, struct timeval *timeout);</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134885"> </A>
</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134886"> </A>
       FD_CLR(int fd, fd_set *set);</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134887"> </A>
       FD_ISSET(int fd, fd_set *set);</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134888"> </A>
       FD_SET(int fd, fd_set *set);</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134889"> </A>
       FD_ZERO(fd_set *set);</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134890"> </A>
</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134891"> </A>
DESCRIPTION</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134892"> </A>
       select  waits  for  a number of file descriptors to change</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134893"> </A>
       status.</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134894"> </A>
</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134895"> </A>
       Three independent sets of descriptors are watched.   Those</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134896"> </A>
       listed  in  readfds  will  be watched to see if characters</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134897"> </A>
       become available for reading, those in  writefds  will  be</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134898"> </A>
       watched  to  see if it is ok to immediately write on them,</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134899"> </A>
       and those in exceptfds will be watched for exceptions.  On</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134900"> </A>
       exit,  the  sets  are  modified in place to indicate which</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134901"> </A>
       descriptors actually changed status.</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134902"> </A>
</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134903"> </A>
       Four macros are provided to manipulate the sets.   FD_ZERO</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134904"> </A>
       will clear a set.  FD_SET and FD_CLR add or remove a given</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134905"> </A>
       descriptor from  a  set.   FD_ISSET  tests  to  see  if  a</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134906"> </A>
       descriptor is part of the set; this is useful after select</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134907"> </A>
       returns.</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134908"> </A>
</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134909"> </A>
       n is the highest-numbered descriptor in any of  the  three</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134910"> </A>
       sets, plus 1.</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134911"> </A>
</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134912"> </A>
       timeout  is  an  upper bound on the amount of time elapsed</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134913"> </A>
       before select returns. It may be zero, causing  select  to</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134914"> </A>
       return  immediately.  If  timeout  is  NULL  (no timeout),</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134915"> </A>
       select can block indefinitely.</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134916"> </A>
</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134917"> </A>
RETURN VALUE</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134918"> </A>
       On success, select returns the number of descriptors  con-</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134919"> </A>
       tained  in  the  descriptor sets, which may be zero if the</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134920"> </A>
       timeout expires before anything interesting  happens.   On</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134921"> </A>
       error, -1 is returned, and errno is set appropriately; the</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134922"> </A>
       sets and timeout become undefined, so do not rely on their</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134923"> </A>
       contents after an error.</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134924"> </A>
</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134925"> </A>
ERRORS</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134926"> </A>
       EBADF   An invalid file descriptor was given in one of the</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134927"> </A>
               sets.</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134928"> </A>
</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134929"> </A>
       EINTR   A non blocked signal was caught.</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134930"> </A>
</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134931"> </A>
       EINVAL  n is negative.</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134932"> </A>
</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134933"> </A>
       ENOMEM  select was unable to allocate memory for  internal</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134934"> </A>
               tables.</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134935"> </A>
</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134936"> </A>
NOTES</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134937"> </A>
       Some  code calls select with all three sets empty, n zero,</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134938"> </A>
       and a non-null timeout as a fairly portable way  to  sleep</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134939"> </A>
       with subsecond precision.</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134940"> </A>
</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134941"> </A>
EXAMPLE</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134942"> </A>
       #include </PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134943"> </A>
       #include </PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134944"> </A>
       #include </PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134945"> </A>
       #include </PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134946"> </A>
</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134947"> </A>
       int</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134948"> </A>
       main(void)</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134949"> </A>
       {</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134950"> </A>
           fd_set rfds;</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134951"> </A>
           struct timeval tv;</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134952"> </A>
           int retval;</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134953"> </A>
</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134954"> </A>
           /* Watch stdin (fd 0) to see when it has input. */</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134955"> </A>
           FD_ZERO(&amp;rfds);</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134956"> </A>
           FD_SET(0, &amp;rfds);</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134957"> </A>
           /* Wait up to five seconds. */</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134958"> </A>
           tv.tv_sec = 5;</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134959"> </A>
           tv.tv_usec = 0;</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134960"> </A>
</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134961"> </A>
           retval = select(1, &amp;rfds, NULL, NULL, &amp;tv);</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134962"> </A>
           /* Don't rely on the value of tv now! */</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134963"> </A>
</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134964"> </A>
           if (retval)</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134965"> </A>
               printf(&quot;Data is available now.\n&quot;);</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134966"> </A>
               /* FD_ISSET(0, &amp;rfds) will be true. */</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134967"> </A>
           else</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134968"> </A>
               printf(&quot;No data within five seconds.\n&quot;);</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134969"> </A>
</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134970"> </A>
           exit(0);</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134971"> </A>
       }</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134972"> </A>
</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134973"> </A>
       Generally  portable  to/from  non-BSD  systems  supporting</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134974"> </A>
       clones  of  the BSD socket layer (including System V vari-</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134975"> </A>
       ants).  However, note that the System V variant  typically</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134976"> </A>
       sets the timeout variable before exit, but the BSD variant</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134977"> </A>
       does not.</PRE>
</DIV>
<DIV>
<H3 CLASS="manhead">
<A NAME="pgfId=1134978">
 </A>
<A NAME="27328">
 </A>
sendto</H3>
<PRE CLASS="CodeExample"><A NAME="pgfId=1134979"> </A>
NAME</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1135009"> </A>
       sendto - send a message from a socket</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1135010"> </A>
</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1135011"> </A>
SYNOPSIS</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1135012"> </A>
       #include &lt;network.h&gt;</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1135013"> </A>
</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1135014"> </A>
       int sendto(int s, const void *msg, int len,  unsigned  int</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1135015"> </A>
       flags, const struct sockaddr *to, int tolen);</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1135016"> </A>
</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1135017"> </A>
DESCRIPTION</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1135018"> </A>
       Sendto is used to transmit  a  message</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1135019"> </A>
       to  another socket.</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1135020"> </A>
</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1135021"> </A>
       The address of the target is given by to with tolen speci</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1135022"> </A>
       fying its size.  The length of the  message  is  given  by</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1135023"> </A>
       len.   If  the  message  is  too  long  to pass atomically</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1135024"> </A>
       through the underlying protocol,  the  error  EMSGSIZE  is</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1135025"> </A>
       returned, and the message is not transmitted.</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1135026"> </A>
</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1135027"> </A>
       No indication of failure to deliver is implicit in a send.</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1135028"> </A>
       Locally detected errors are indicated by a return value of</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1135029"> </A>
       -1.</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1135030"> </A>
</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1135031"> </A>
       When  the message does not fit into the send buffer of the</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1135032"> </A>
       socket, send normally blocks, unless the socket  has  been</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1135033"> </A>
       placed  in non-blocking I/O mode.  In non-blocking mode it</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1135034"> </A>
       would return EAGAIN in this case.  The select(2) call  may</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1135035"> </A>
       be  used  to  determine  when  it is possible to send more</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1135036"> </A>
       data.</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1135037"> </A>
</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1135038"> </A>
       The flags parameter may include one or more of the follow</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1135039"> </A>
       ing:</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1135040"> </A>
</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1135041"> </A>
              #define MSG_OOB           0x1     /* process out-of-band data */</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1135042"> </A>
              #define MSG_DONTROUTE     0x4     /* bypass routing, use direct interface */</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1135043"> </A>
              #define MSG_DONTWAIT      0x40    /* don't block */</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1135044"> </A>
              #define MSG_NOSIGNAL      0x2000  /* don't raise SIGPIPE */</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1135045"> </A>
</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1135046"> </A>
       MSG_OOB</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1135047"> </A>
              Sends out-of-band data on sockets that support this</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1135048"> </A>
              notion (e.g.  SOCK_STREAM); the underlying protocol</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1135049"> </A>
              must also support out-of-band data.</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1135050"> </A>
</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1135051"> </A>
       MSG_DONTROUTE</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1135052"> </A>
              Bypasses  the  usual routing table lookup and sends</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1135053"> </A>
              the packet directly to the interface  described  by</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1135054"> </A>
              the  destination address. This is usually used only</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1135055"> </A>
              by diagnostic or routing programs.</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1135056"> </A>
</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1135057"> </A>
       MSG_DONTWAIT</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1135058"> </A>
              Enables non-blocking operation;  if  the  operation</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1135059"> </A>
              would block, EAGAIN is returned.</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1135060"> </A>
</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1135061"> </A>
       MSG_NOSIGNAL</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1135062"> </A>
              Requests  not  to  send SIGPIPE on errors on stream</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1135063"> </A>
              oriented sockets when the other end breaks the con</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1135064"> </A>
              nection. The EPIPE error is still returned.</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1135065"> </A>
</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1135066"> </A>
       See recv(2) for a description of the msghdr structure. You</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1135067"> </A>
       may send control information  using  the  msg_control  and</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1135068"> </A>
       msg_controllen  members. The maximum control buffer length</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1135069"> </A>
       the kernel can process is  limited  by  the  net.core.opt</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1135070"> </A>
       mem_max sysctl; see socket(4).</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1135071"> </A>
</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1135072"> </A>
RETURN VALUES</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1135073"> </A>
       The  calls  return the number of characters sent, or -1 if</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1135074"> </A>
       an error occurred.</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1135075"> </A>
</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1135076"> </A>
ERRORS</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1135077"> </A>
       These are some standard errors  generated  by  the  socket</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1135078"> </A>
       layer.  Additional  errors  may  be generated and returned</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1135079"> </A>
       from the underlying protocol modules; see their respective</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1135080"> </A>
       manual pages.</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1135081"> </A>
</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1135082"> </A>
       EBADF   An invalid descriptor was specified.</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1135083"> </A>
</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1135084"> </A>
       ENOTSOCK</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1135085"> </A>
               The argument s is not a socket.</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1135086"> </A>
</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1135087"> </A>
       EMSGSIZE</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1135088"> </A>
               The socket requires that message  be  sent  atomi</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1135089"> </A>
               cally, and the size of the message to be sent made</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1135090"> </A>
               this impossible.</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1135091"> </A>
</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1135092"> </A>
       EAGAIN  The  socket  is  marked   non-blocking   and   the</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1135093"> </A>
               requested operation would block.</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1135094"> </A>
</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1135095"> </A>
       ENOBUFS The system was unable to allocate an internal mem</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1135096"> </A>
               ory block.  The operation may succeed when buffers</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1135097"> </A>
               become available.</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1135098"> </A>
</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1135099"> </A>
       EINTR   A signal occurred.</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1135100"> </A>
</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1135101"> </A>
       ENOMEM  No memory available.</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1135102"> </A>
</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1135103"> </A>
       EINVAL  Invalid argument passed.</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1135104"> </A>
</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1135105"> </A>
       EPIPE   The  local  end has been shut down on a connection</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1135106"> </A>
               oriented socket.  In this case  the  process  will</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1135107"> </A>
               also receive a SIGPIPE unless MSG_NOSIGNAL is set.</PRE>
</DIV>
<DIV>
<H3 CLASS="manhead">
<A NAME="pgfId=1135108">
 </A>
<A NAME="22582">
 </A>
setsockopt</H3>
<PRE CLASS="CodeExample"><A NAME="pgfId=1135109"> </A>
NAME</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1135137"> </A>
       getsockopt, setsockopt - get and set options on sockets</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1135138"> </A>
</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1135139"> </A>
SYNOPSIS</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1135140"> </A>
       #include &lt;network.h&gt;</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1135141"> </A>
</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1135142"> </A>
       int  getsockopt(int  s, int level, int optname, void *opt</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1135143"> </A>
       val, socklen_t *optlen);</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1135144"> </A>
</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1135145"> </A>
       int setsockopt(int s, int level, int optname,  const  void</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1135146"> </A>
       *optval, socklen_t optlen);</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1135147"> </A>
</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1135148"> </A>
DESCRIPTION</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1135149"> </A>
       Getsockopt  and  setsockopt manipulate the options associ</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1135150"> </A>
       ated with a socket.  Options may exist at multiple  proto</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1135151"> </A>
       col  levels;  they  are  always  present  at the uppermost</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1135152"> </A>
       socket level.</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1135153"> </A>
</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1135154"> </A>
       When manipulating socket options the level  at  which  the</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1135155"> </A>
       option  resides  and the name of the option must be speci</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1135156"> </A>
       fied.  To manipulate options at the socket level, level is</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1135157"> </A>
       specified  as  SOL_SOCKET.   To  manipulate options at any</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1135158"> </A>
       other level the protocol number of the appropriate  proto</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1135159"> </A>
       col  controlling  the option is supplied.  For example, to</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1135160"> </A>
       indicate that an option is to be interpreted  by  the  TCP</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1135161"> </A>
       protocol,  level  should  be set to the protocol number of</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1135162"> </A>
       TCP; see getprotoent(3).</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1135163"> </A>
</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1135164"> </A>
       The parameters optval and optlen are used to access option</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1135165"> </A>
       values  for  setsockopt.   For  getsockopt they identify a</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1135166"> </A>
       buffer in which the value for the requested option(s)  are</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1135167"> </A>
       to  be returned.  For getsockopt, optlen is a value-result</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1135168"> </A>
       parameter, initially containing the  size  of  the  buffer</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1135169"> </A>
       pointed  to  by optval, and modified on return to indicate</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1135170"> </A>
       the actual size of the value returned.  If no option value</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1135171"> </A>
       is to be supplied or returned, optval may be NULL.</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1135172"> </A>
</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1135173"> </A>
       Optname and any specified options are passed uninterpreted</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1135174"> </A>
       to the appropriate  protocol  module  for  interpretation.</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1135175"> </A>
       The  include  file &lt;network.h&gt; contains definitions for</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1135176"> </A>
       socket level options, described below.  Options  at  other</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1135177"> </A>
       protocol  levels  vary  in  format  and  name; consult the</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1135178"> </A>
       appropriate entries in section 4 of the manual.</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1135179"> </A>
</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1135180"> </A>
       Most socket-level options utilize  an  int  parameter  for</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1135181"> </A>
       optval.   For setsockopt, the parameter should be non-zero</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1135182"> </A>
       to enable a boolean option, or zero if the option is to be</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1135183"> </A>
       disabled.</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1135184"> </A>
</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1135185"> </A>
       For  a  description  of  the  available socket options see</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1135186"> </A>
       socket(7) and the appropriate protocol man pages.</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1135187"> </A>
</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1135188"> </A>
RETURN VALUE</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1135189"> </A>
       On success, zero is returned.  On error, -1  is  returned,</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1135190"> </A>
       and errno is set appropriately.</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1135191"> </A>
</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1135192"> </A>
ERRORS</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1135193"> </A>
       EBADF   The argument s is not a valid descriptor.</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1135194"> </A>
</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1135195"> </A>
       ENOTSOCK</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1135196"> </A>
               The argument s is a file, not a socket.</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1135197"> </A>
</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1135198"> </A>
       ENOPROTOOPT</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1135199"> </A>
               The option is unknown at the level indicated.</PRE>
</DIV>
<DIV>
<H3 CLASS="manhead">
<A NAME="pgfId=1135200">
 </A>
<A NAME="33580">
 </A>
shutdown</H3>
<PRE CLASS="CodeExample"><A NAME="pgfId=1135201"> </A>
NAME</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1135221"> </A>
       shutdown - shut down part of a full-duplex connection</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1135222"> </A>
</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1135223"> </A>
SYNOPSIS</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1135224"> </A>
       #include &lt;network.h&gt;</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1135225"> </A>
</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1135226"> </A>
       int shutdown(int s, int how);</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1135227"> </A>
</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1135228"> </A>
DESCRIPTION</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1135229"> </A>
       The shutdown call causes all or part of a full-duplex con-</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1135230"> </A>
       nection on the socket associated with s to be  shut  down.</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1135231"> </A>
       If  how is 0, further receives will be disallowed.  If how</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1135232"> </A>
       is 1, further sends will be disallowed.  If how is 2, fur-</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1135233"> </A>
       ther sends and receives will be disallowed.</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1135234"> </A>
</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1135235"> </A>
RETURN VALUE</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1135236"> </A>
       On  success,  zero is returned.  On error, -1 is returned,</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1135237"> </A>
       and errno is set appropriately.</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1135238"> </A>
</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1135239"> </A>
ERRORS</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1135240"> </A>
       EBADF   s is not a valid descriptor.</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1135241"> </A>
</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1135242"> </A>
       ENOTSOCK</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1135243"> </A>
               s is a file, not a socket.</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1135244"> </A>
</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1135245"> </A>
       ENOTCONN</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1135246"> </A>
               The specified socket is not connected.</PRE>
</DIV>
<DIV>
<H3 CLASS="manhead">
<A NAME="pgfId=1135247">
 </A>
<A NAME="30054">
 </A>
socket</H3>
<PRE CLASS="CodeExample"><A NAME="pgfId=1135248"> </A>
NAME</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1135256"> </A>
       socket - create an endpoint for communication</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1135257"> </A>
</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1135258"> </A>
SYNOPSIS</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1135259"> </A>
       #include &lt;network.h&gt;</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1135260"> </A>
</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1135261"> </A>
       int socket(int domain, int type, int protocol);</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1135262"> </A>
</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1135263"> </A>
DESCRIPTION</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1135264"> </A>
       Socket creates an endpoint for communication and returns a</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1135265"> </A>
       descriptor.</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1135266"> </A>
</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1135267"> </A>
       The domain parameter  specifies  a  communications  domain</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1135268"> </A>
       within  which  communication will take place; this selects</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1135269"> </A>
       the protocol family which should be used.  These  families</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1135270"> </A>
       are  defined  in &lt;network.h&gt;.  The currently understood</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1135271"> </A>
       formats include:</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1135272"> </A>
</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1135273"> </A>
       PF_INET</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1135274"> </A>
              IPv4 Internet protocols; see ip(4)</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1135275"> </A>
</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1135276"> </A>
       The socket has the indicated  type,  which  specifies  the</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1135277"> </A>
       semantics of communication.  Currently defined types are:</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1135278"> </A>
</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1135279"> </A>
       SOCK_STREAM</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1135280"> </A>
              Provides  sequenced,  reliable, two-way connection-</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1135281"> </A>
              based byte streams.  An out-of-band data  transmis-</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1135282"> </A>
              sion mechanism may be supported.</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1135283"> </A>
</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1135284"> </A>
       SOCK_DGRAM</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1135285"> </A>
              Supports datagrams (connectionless, unreliable mes-</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1135286"> </A>
              sages of a fixed maximum length).</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1135287"> </A>
</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1135288"> </A>
       SOCK_SEQPACKET</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1135289"> </A>
              Provides a sequenced, reliable, two-way connection-</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1135290"> </A>
              based data transmission path for datagrams of fixed</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1135291"> </A>
              maximum length; a consumer is required to  read  an</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1135292"> </A>
              entire packet with each read system call.</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1135293"> </A>
</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1135294"> </A>
       SOCK_RAW</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1135295"> </A>
              Provides raw network protocol access.</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1135296"> </A>
</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1135297"> </A>
       The  protocol  specifies  a particular protocol to be used</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1135298"> </A>
       with the socket.  Normally only a single  protocol  exists</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1135299"> </A>
       to  support a particular socket type within a given proto-</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1135300"> </A>
       col family.  However, it is possible that  many  protocols</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1135301"> </A>
       may  exist,  in  which  case a particular protocol must be</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1135302"> </A>
       specified in this manner.  The protocol number to  use  is</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1135303"> </A>
       particular to the &quot;communication domain&quot; in which communi-</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1135304"> </A>
       cation is to take place; see  protocols(5).   See  getpro-</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1135305"> </A>
       toent(3)  on  how to map protocol name strings to protocol</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1135306"> </A>
       numbers.</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1135307"> </A>
</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1135308"> </A>
       Sockets of type SOCK_STREAM are full-duplex byte  streams,</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1135309"> </A>
       similar  to pipes.  A stream socket must be in a connected</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1135310"> </A>
       state before any data may be sent or received  on  it.   A</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1135311"> </A>
       connection  to another socket is created with a connect(2)</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1135312"> </A>
       call.  Once  connected,  data  may  be  transferred  using</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1135313"> </A>
       read(2)  and write(2) calls or some variant of the send(2)</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1135314"> </A>
       and recv(2) calls.  When a session has  been  completed  a</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1135315"> </A>
       close(2)  may  be performed.  Out-of-band data may also be</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1135316"> </A>
       transmitted  as  described  in  send(2)  and  received  as</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1135317"> </A>
       described in recv(2).</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1135318"> </A>
</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1135319"> </A>
       The communications protocols which implement a SOCK_STREAM</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1135320"> </A>
       ensure that data is not lost or duplicated.  If a piece of</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1135321"> </A>
       data  for  which the peer protocol has buffer space cannot</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1135322"> </A>
       be successfully transmitted within a reasonable length  of</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1135323"> </A>
       time,  then the connection is considered When SO_KEEPALIVE</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1135324"> </A>
       is enabled on the socket the protocol checks in  a  proto-</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1135325"> </A>
       col-specific  manner  if  the other end is still alive.</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1135326"> </A>
</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1135327"> </A>
       SOCK_DGRAM and SOCK_RAW sockets allow sending of datagrams</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1135328"> </A>
       to correspondents named in send(2) calls.   Datagrams  are</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1135329"> </A>
       generally  received  with  recvfrom(2),  which returns the</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1135330"> </A>
       next datagram with its return address.</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1135331"> </A>
</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1135332"> </A>
       When  the network signals an error condition to the proto-</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1135333"> </A>
       col module (e.g.  using a ICMP message for IP) the pending</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1135334"> </A>
       error  flag  is set for the socket.  The next operation on</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1135335"> </A>
       this socket will return the  error  code  of  the  pending</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1135336"> </A>
       error.  For some protocols it is possible to enable a per-</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1135337"> </A>
       socket error queue to retrieve detailed information  about</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1135338"> </A>
       the error; see IP_RECVERR in ip(4).</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1135339"> </A>
</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1135340"> </A>
       The  operation  of  sockets  is controlled by socket level</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1135341"> </A>
       options.  These options  are  defined  in  .</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1135342"> </A>
       Setsockopt(2)  and  getsockopt(2)  are used to set and get</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1135343"> </A>
       options, respectively.</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1135344"> </A>
</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1135345"> </A>
RETURN VALUES</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1135346"> </A>
       -1 is returned if an error occurs;  otherwise  the  return</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1135347"> </A>
       value is a descriptor referencing the socket.</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1135348"> </A>
</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1135349"> </A>
ERRORS</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1135350"> </A>
       EPROTONOSUPPORT</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1135351"> </A>
                     The protocol type or the specified protocol is not</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1135352"> </A>
               supported within this domain.</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1135353"> </A>
</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1135354"> </A>
       EMFILE  There are too many open files.</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1135355"> </A>
</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1135356"> </A>
       EACCES   Permission  to  create  a  socket of the specified</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1135357"> </A>
               type and/or protocol is denied.</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1135358"> </A>
</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1135359"> </A>
       ENOBUFS or ENOMEM</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1135360"> </A>
                 Insufficient memory is available.  The socket can-</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1135361"> </A>
                      not  be  created  until  sufficient  resources are</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1135362"> </A>
               freed.</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1135363"> </A>
</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1135364"> </A>
        EINVAL   Unknown protocol, or protocol  family  not  avail-</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1135365"> </A>
               able.</PRE>
</DIV>
<DIV>
<H3 CLASS="manhead">
<A NAME="pgfId=1135366">
 </A>
<A NAME="33398">
 </A>
write</H3>
<PRE CLASS="CodeExample"><A NAME="pgfId=1135367"> </A>
NAME</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1135397"> </A>
       write - write to a file descriptor</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1135398"> </A>
</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1135399"> </A>
SYNOPSIS</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1135400"> </A>
       ssize_t write(int fd, const void *buf, size_t count);</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1135401"> </A>
</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1135402"> </A>
DESCRIPTION</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1135403"> </A>
       write  writes  up to count bytes to the file referenced by</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1135404"> </A>
       the file descriptor fd from the buffer  starting  at  buf.</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1135405"> </A>
</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1135406"> </A>
RETURN VALUE</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1135407"> </A>
       On success, the number of bytes written are returned (zero</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1135408"> </A>
       indicates nothing was written).  On error, -1 is returned,</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1135409"> </A>
      and  errno is set appropriately.</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1135410"> </A>
</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1135411"> </A>
ERRORS</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1135412"> </A>
       EBADF  fd is not a valid file descriptor or  is  not  open</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1135413"> </A>
             for writing.</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1135414"> </A>
</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1135415"> </A>
       EINVAL fd is attached to an object which is unsuitable for</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1135416"> </A>
             writing.</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1135417"> </A>
</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1135418"> </A>
      EPIPE  fd is connected to a socket  whose  reading</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1135419"> </A>
             end  is closed.</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1135832"> </A>
</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1135833"> </A>
       EAGAIN  Non-blocking I/O has been selected using O_NONBLOCK</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1135834"> </A>
              and  there  was  no room in the pipe or socket con</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1135423"> </A>
             nected to fd to write the data immediately.</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1135466"> </A>
</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1135467"> </A>
      EINTR  The call was interrupted before  any</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1135468"> </A>
             data was written.</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1135427"> </A>
</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1135428"> </A>
       ENOSPC The  device  containing  the file referred to by fd</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1135429"> </A>
             has no room for the data.</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1135430"> </A>
</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1135431"> </A>
      EIO   A low-level I/O error occurred.</PRE>
</DIV>
<HR ALIGN="center"><TABLE STYLE="ECOS" WIDTH="98%" BORDER="0" ALIGN="LEFT" CELLPADDING="1"><TR><TH COLSPAN="3" ALIGN="center"><P CLASS="Gotos">TCP/IP Library Reference</P></TH></TR><TR><TD  ALIGN="center"><P CLASS="Gotos"><A HREF="tcpip.html">Contents</A></P></TD><TD  ALIGN="center"><P CLASS="Gotos"><A HREF="tcpip.3.html">To&nbsp;previous&nbsp;page</A></P></TD><TD  ALIGN="center"><P CLASS="Gotos"><A HREF="tcpip.5.html">To&nbsp;next&nbsp;page</A></P></TD></TR></TABLE></BODY>
</HTML>
