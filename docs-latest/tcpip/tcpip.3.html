<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML EXPERIMENTAL 970324//EN">
<HTML>
<HEAD><!--version 1.1.0/Tue Nov 21 11:01:37 GMT 2000-->
<META NAME="GENERATOR" CONTENT="Adobe FrameMaker 5.5/HTML Export Filter">
<LINK REL="STYLESHEET" HREF="cygnus.css">
<TITLE> TCP/IP</TITLE></HEAD>
<BODY BGCOLOR="#ffffff">
<DIV>
<TABLE STYLE="ECOS" WIDTH="98%" BORDER="0" ALIGN="LEFT" CELLPADDING="1"><TR><TH COLSPAN="3" ALIGN="center"><P CLASS="Gotos">TCP/IP</P></TH></TR><TR><TD  ALIGN="center"><P CLASS="Gotos"><A HREF="tcpip.html">Contents</A></P></TD><TD  ALIGN="center"><P CLASS="Gotos"><A HREF="tcpip.2.html">To&nbsp;previous&nbsp;page</A></P></TD><TD ALIGN="center"><P CLASS="Gotos"><A HREF="tcpip.4.html">To&nbsp;next&nbsp;page</A></P></TD></TR></TABLE><P ALIGN="LEFT">&nbsp;</P><BR><BR><HR ALIGN="center"></DIV>
<H2 CLASS="ChapterTitle">
<A NAME="pgfId=1133006">
 </A>
TCP/IP<DIV>
<IMG SRC="botclear.gif">
</DIV>
</H2>
<P CLASS="BodyAfterHead">
<A NAME="pgfId=1133450">
 </A>
TCP/IP Networking for eCos now provides a complete TCP/IP networking stack, which is derived from the latest stable release of OpenBSD. The networking support is fully featured and well tested within the eCos environment.</P>
<P CLASS="Body">
<A NAME="pgfId=1133470">
 </A>
Ethernet drivers are currenty provided for the following standard supported platforms:</P>
<UL>
<P><LI>
<A NAME="pgfId=1133477">
 </A>
Motorola PowerPC MBX/860 </LI>
<P><LI>
<A NAME="pgfId=1133479">
 </A>
Cirrus Logic EDB72xx, based on the Crystal CS8900 </LI>
<P><LI>
<A NAME="pgfId=1136478">
 </A>
Socket Communications Low Power Compact Flash Ethernet adaptor</LI>
<P><LI>
<A NAME="pgfId=1135877">
 </A>
Intel EBSA-285 + EtherPRO 10/100+</LI>
</UL>
<DIV>
<H3 CLASS="Heading1">
<A NAME="pgfId=1133478">
 </A>
Networking Stack Features </H3>
<P CLASS="Body">
<A NAME="pgfId=1133485">
 </A>
Since this networking package is based on BSD code, it is very complete and robust.  The eCos implementation includes support for the following protocols:   </P>
<UL>
<P><LI>
<A NAME="pgfId=1133493">
 </A>
IPv4   </LI>
<P><LI>
<A NAME="pgfId=1133498">
 </A>
UDP   </LI>
<P><LI>
<A NAME="pgfId=1133499">
 </A>
TCP   </LI>
<P><LI>
<A NAME="pgfId=1133505">
 </A>
ICMP   </LI>
<P><LI>
<A NAME="pgfId=1136482">
 </A>
raw packet interface </LI>
</UL>
<P CLASS="Body">
<A NAME="pgfId=1133518">
 </A>
These additional features are also present in the package, but are not yet supported:</P>
<UL>
<P><LI>
<A NAME="pgfId=1133532">
 </A>
Berkeley Packet Filter   </LI>
<P><LI>
<A NAME="pgfId=1133548">
 </A>
Multi-cast and uni-cast support, including multi-casting routing   </LI>
<P><LI>
<A NAME="pgfId=1133553">
 </A>
IPv6 </LI>
</UL>
</DIV>
<DIV>
<H3 CLASS="Heading1">
<A NAME="pgfId=1133570">
 </A>
Ethernet Driver Design </H3>
<P CLASS="Body">
<A NAME="pgfId=1133581">
 </A>
Currently, the networking stack only supports ethernet based networking. </P>
<P CLASS="Body">
<A NAME="pgfId=1133595">
 </A>
The network drivers use a two-layer design.  One layer is hardware independent and contains all the stack specific code.  The other layer is platform dependent and communicates with the hardware independent layer via a very simple API.  In this way, hardware device drivers can actually be used with other stacks, if the same API can be provided by that stack.  We designed the drivers this way to encourage the development of other stacks in eCos while allowing re-use of the actual hardware specific code. </P>
<P CLASS="Body">
<A NAME="pgfId=1133596">
 </A>
Complete documentation of the ethernet device driver and the associated API can be found in the file <TT CLASS="Code">
net/drivers/eth/common/VERSION/doc/driver_doc</TT>
. The driver and API is the same as the minimal debug stack used by the RedBoot application. See the RedBoot documentation for further information.</P>
</DIV>
<DIV>
<H3 CLASS="Heading1">
<A NAME="pgfId=1133601">
 </A>
Sample Code </H3>
<P CLASS="Body">
<A NAME="pgfId=1133606">
 </A>
Many examples using the networking support are provided.  These are arranged as eCos test programs, primarily for use in verifying the package, but they can also serve as useful frameworks for program design.  We have taken a KISS approach to building programs which use the network.  A single include file &lt;<TT CLASS="Code">
network.h</TT>
&gt; is all that is required to access the stack.  A complete, annotated test program can be found at <TT CLASS="Code">
net/tcpip/VERSION/tests/ftp_test.c</TT>
,  with its neighbouring files.     </P>
</DIV>
<DIV>
<H3 CLASS="Heading1">
<A NAME="pgfId=1133007">
 </A>
OpenBSD TCP/IP stack port</H3>
<P CLASS="Body">
<A NAME="pgfId=1133008">
 </A>
This document describes how to get started with the OpenBSD TCP/IP network stack. </P>
<H3 CLASS="Heading2">
<A NAME="pgfId=1132617">
 </A>
Installation</H3>
<P CLASS="Body">
<A NAME="pgfId=1132618">
 </A>
The stack is usually distributed in the eCos package distribution format. It is installed by adding the file <TT CLASS="Code">
net-10b</TT>
<EM CLASS="Emphasis">
y</EM>
<TT CLASS="Code">
.epk </TT>
where <EM CLASS="Emphasis">
y</EM>
 is the minor version number of this release  (located in the root of the software distribution) to an existing eCos installation, using the eCos <SPAN CLASS="BOLD">
Package Administration Tool.</SPAN>
</P>
<P CLASS="Body">
<A NAME="pgfId=1136808">
 </A>
To add the new EPKs to the eCos 1.4.<EM CLASS="Emphasis">
x</EM>
 repository, run up the GUI Package Administration Tool, click &#153<SPAN CLASS="Bold">
Add...</SPAN>
' and select the net .epk file.</P>
<P CLASS="Body">
<A NAME="pgfId=1136809">
 </A>
In the config tool, most packages should be version &quot;v1_4_<EM CLASS="Emphasis">
x</EM>
&quot;. The EBSA ethernet driver should be version &quot;v1_4_<EM CLASS="Emphasis">
x</EM>
&quot;. When you add the &quot;Networking&quot; package to the config, it should be &quot;v1_0b<EM CLASS="Emphasis">
y</EM>
&quot;.</P>
<P CLASS="Body">
<A NAME="pgfId=1136811">
 </A>
If you have an existing configuration customized to your application which already uses the network driver, you can switch over to the newer versions of the network driver package using the <SPAN CLASS="Bold">
Build</SPAN>
<IMG SRC="arrow.gif"><SPAN CLASS="Bold">
Packages</SPAN>
 dialog.  </P>
<P CLASS="Body">
<A NAME="pgfId=1136812">
 </A>
For command-line use (eg. under Linux), use the script ecosadmin.tcl which will be found in the packages directory.  Ensure that either the environment variable ECOS_REPOSITORY is set correctly, or unset it and run the script from within the packages directory itself.</P>
<PRE CLASS="CodeExample"><A NAME="pgfId=1136813"> </A>
cd packages
./ecosadmin.tcl add net-1.0b<EM CLASS="Emphasis">y.</EM>
epk   </PRE>
<H3 CLASS="Heading2">
<A NAME="pgfId=1136666">
 </A>
Targets</H3>
<P CLASS="Body">
<A NAME="pgfId=1136795">
 </A>
A number of device drivers may be supported. The default configuration supports two by default, and you will need to write your own driver if you should add additional ones.</P>
<P CLASS="Body">
<A NAME="pgfId=1136826">
 </A>
The target for your board will normally be supplied with an ethernet driver, in which case it may simply be added to your network interface, as above. If your target is not supplied with an ethernet driver, you will need to use loopback (see <A HREF="tcpip.3.html#40207" CLASS="XRef">
 Loopback tests</A>
).</P>
<H3 CLASS="Heading2">
<A NAME="pgfId=1132621">
 </A>
Building the Network Stack</H3>
<P CLASS="Body">
<A NAME="pgfId=1132622">
 </A>
Using the <SPAN CLASS="Bold">
Build<IMG SRC="arrow.gif">Packages</SPAN>
 dialog, add the two packages &quot;Networking&quot; and &quot;Common Ethernet Support&quot; to your configuration.  Their macro names are CYGPKG_NET and CYGPKG_NET_ETH_DRIVERS respectively.</P>
<P CLASS="Body">
<A NAME="pgfId=1132878">
 </A>
The platform-specific ethernet device driver for your platform will be added as part of the target selection (in the <SPAN CLASS="Bold">
Build<IMG SRC="arrow.gif">Templates</SPAN>
 &quot;Hardware&quot; item), along with the <BR>
PCI I/O subsystem and the appropriate serial device driver.  For example, the PowerPC MBX target selection adds the package PKG_NET_QUICC_ETH_DRIVERS, and the Cirrus Logic EDB7xxx target selection adds the package CYGPKG_NET_EDB7XXX_ETH_DRIVERS. After this, eCos and its tests can be built exactly as usual.</P>
<H3 CLASS="Label">
<A NAME="pgfId=1132624">
 </A>
Note: </H3>
<P CLASS="Note">
<A NAME="pgfId=1132881">
 </A>
By default, most of the network tests are not built.  This is because some of them require manual intervention, i.e. they are to be run &quot;by hand&quot;, and are not suitable for automated testing.  To build the full set of network tests, set the configuration option CYGPKG_NET_BUILD_TESTS &quot;Build networking tests (demo programs)&quot; within &quot;Networking support build options&quot;.</P>
</DIV>
<DIV>
<H3 CLASS="Heading1">
<A NAME="pgfId=1132625">
 </A>
 Configuring IP Addresses</H3>
<P CLASS="Body">
<A NAME="pgfId=1132626">
 </A>
Each interface (&quot;eth0&quot; and &quot;eth1&quot;) has independent configuration of its setup.  Each can be set up manually (in which case you must write code to do this), or by using BOOTP/DHCP, or explicitly, with configured values. If additional interfaces are added, these must be configured manually.</P>
<P CLASS="Body">
<A NAME="pgfId=1132627">
 </A>
The configurable values are: </P>
<UL>
<P><LI>
<A NAME="pgfId=1136492">
 </A>
IP address </LI>
<P><LI>
<A NAME="pgfId=1136493">
 </A>
netmask </LI>
<P><LI>
<A NAME="pgfId=1136494">
 </A>
broadcast address </LI>
<P><LI>
<A NAME="pgfId=1136495">
 </A>
gateway/router </LI>
<P><LI>
<A NAME="pgfId=1136496">
 </A>
server address.  </LI>
</UL>
<P CLASS="Body">
<A NAME="pgfId=1136497">
 </A>
Server address is the DHCP server if applicable, but in addition, many test cases use it as &quot;the machine to talk to&quot; in whatever manner the test exercises the protocol stack.</P>
<P CLASS="Body">
<A NAME="pgfId=1132628">
 </A>
The initialization is invoked by calling the C routine         </P>
<PRE CLASS="CodeExample"><A NAME="pgfId=1132919"> </A>
void init_all_network_interfaces(void);</PRE>
<P CLASS="Body">
<A NAME="pgfId=1132922">
 </A>
refer to the test cases, &quot;<TT CLASS="Code">
.../packages/net/tcpip/VERSION/tests/ftp_test.c</TT>
&quot; for example usage, and the source files in <TT CLASS="Code">
packages/net/tcpip/VERSION/src/lib/ bootp_support.c </TT>
and<TT CLASS="Code">
 network_support.c</TT>
 to see what that call does.</P>
<P CLASS="Body">
<A NAME="pgfId=1132629">
 </A>
This assumes that the MAC address is already defined in the serial EEPROM or however the particular target implements this; there is no (tested) support for setting the MAC address in this release.</P>
<P CLASS="Body">
<A NAME="pgfId=1132630">
 </A>
DHCP support is active by default, and there are configuration options to control it.  Firstly, in the top level of the &quot;Networking&quot; configuration tree, &quot;Use full DHCP instead of BOOTP&quot; enables DHCP, and it contains an option to have the system provide a thread to renew DHCP leases and manage lease expiry. Secondly, the individual interfaces &quot;eth0&quot; and &quot;eth1&quot; each have new options within the &quot;Use BOOTP/DHCP to initialize &#153<EM CLASS="Emphasis">
ethX</EM>
'&quot; to select whether to use DHCP rather than BOOTP.</P>
</DIV>
<DIV>
<H3 CLASS="Heading1">
<A NAME="pgfId=1132631">
 </A>
Tests and Demonstrations</H3>
<H3 CLASS="Heading2">
<A NAME="pgfId=1132632">
 </A>
<A NAME="40207">
 </A>
Loopback tests</H3>
<P CLASS="Body">
<A NAME="pgfId=1132633">
 </A>
By default, only tests which can execute on any target will be built. These therefore do not actually use external network interfaces (though they may configure and initialize them) but are limited to testing via the loopback interface.</P>
<PRE CLASS="CodeExample"><A NAME="pgfId=1132634"> </A>
<SPAN CLASS="Bold">ping_lo_test</SPAN>
 - ping test of the loopback address 
<SPAN CLASS="Bold">tcp_lo_select</SPAN>
 - simple test of select with TCP via loopback 
<SPAN CLASS="Bold">tcp_lo_test</SPAN>
 - trivial TCP test via loopback 
<SPAN CLASS="Bold">udp_lo_test</SPAN>
 - trivial UDP test via loopback 
<SPAN CLASS="Bold">multi_lo_select</SPAN>
		 - test of multiple select() calls simultaneously</PRE>
<H3 CLASS="Heading2">
<A NAME="pgfId=1132636">
 </A>
Building the Network Tests</H3>
<P CLASS="Body">
<A NAME="pgfId=1132637">
 </A>
To build further network tests, ensure that the configuration option CYGPKG_NET_BUILD_TESTS is set as described above and then make the tests in the usual way.  Alternatively (with that option set) use </P>
<PRE CLASS="CodeExample"><A NAME="pgfId=1135971"> </A>
make -C net/tcpip/VERSION/ tests </PRE>
<P CLASS="Body">
<A NAME="pgfId=1135972">
 </A>
after building the eCos library to build only the network tests.</P>
<P CLASS="Body">
<A NAME="pgfId=1133237">
 </A>
This should give test executables in install/tests/net/tcpip/VERSION/tests including the following:</P>
<PRE CLASS="CodeExample"><A NAME="pgfId=1133238"> </A>
<SPAN CLASS="Bold">socket_test</SPAN>
 - trivial test of socket creation API 
<SPAN CLASS="Bold">mbuf_test</SPAN>
 - trivial test of mbuf allocation API 
<SPAN CLASS="Bold">ftp_test</SPAN>
 - simple FTP test, connects to &quot;server&quot; 
<SPAN CLASS="Bold">ping_test</SPAN>
 - pings &quot;server&quot; and non-existent host to test timeout 
<SPAN CLASS="Bold">dhcp_test</SPAN>
 - ping test, but also relinquishes and
                       reacquires DHCP leases periodically 
<SPAN CLASS="Bold">flood</SPAN>
 - a flood ping test; use with care 
<SPAN CLASS="Bold">tcp_echo</SPAN>
 - data forwarding program for performance test
<SPAN CLASS="Bold">nc_test_master </SPAN>
- network characterization master (unsupported)<SPAN CLASS="Bold">
nc_test_slave </SPAN>
- network characterization slave (unsupported)<SPAN CLASS="Bold">
server_test</SPAN>
 - a very simple server example
<SPAN CLASS="Bold">tftp_client_test</SPAN>
 - performs a tftp get and put from/to &quot;server&quot; 
<SPAN CLASS="Bold">tftp_server_test</SPAN>
 - runs a tftp server for a short while 
<SPAN CLASS="Bold">set_mac_address </SPAN>
- set MAC address(es) of interfaces in NVRAM<SPAN CLASS="Bold">
bridge</SPAN>
 - contributed network bridge code
</PRE>
<H3 CLASS="Heading2">
<A NAME="pgfId=1132640">
 </A>
 Standalone Tests</H3>
<PRE CLASS="CodeExample"><A NAME="pgfId=1132641"> </A>
<SPAN CLASS="Bold">socket_test</SPAN>
 - trivial test of socket creation API 
<SPAN CLASS="Bold">mbuf_test </SPAN>
 - trivial test of mbuf allocation API
</PRE>
<P CLASS="Body">
<A NAME="pgfId=1132642">
 </A>
These two do not communicate over the net; they just perform simple API tests then exit.</P>
<PRE CLASS="CodeExample"><A NAME="pgfId=1132643"> </A>
<SPAN CLASS="Bold">ftp_test</SPAN>
      - simple FTP test, connects to &quot;server&quot;</PRE>
<P CLASS="Body">
<A NAME="pgfId=1132644">
 </A>
This test initializes the interface(s) then connects to the FTP server on the &quot;server&quot; machine for for each active interface in turn, confirms that the connection was successful, disconnects and exits.  This tests interworking with the server.</P>
<PRE CLASS="CodeExample"><A NAME="pgfId=1132645"> </A>
<SPAN CLASS="Bold">ping_test</SPAN>
      - pings &quot;server&quot; and non-existent host to test
               timeout</PRE>
<P CLASS="Body">
<A NAME="pgfId=1132646">
 </A>
This test initializes the interface(s) then pings the server machine in the standard way, then pings address &quot;32 up&quot; from the server in the expectation that there is no machine there.  This confirms that the successful ping is not a false positive, and tests the receive timeout.  If there is such a machine, of course the 2nd set of pings succeeds, confirming that we can talk to a machine not previously mentioned by configuration or by bootp. It then does the same thing on the other interface, eth1.</P>
<PRE CLASS="CodeExample"><A NAME="pgfId=1136987"> </A>
<SPAN CLASS="Bold">dhcp_test</SPAN>
    - ping test, but also manipulates DHCP leases</PRE>
<P CLASS="Body">
<A NAME="pgfId=1137054">
 </A>
This test is very similar to the ping test, but in addition, provided the network package is not configured to do this automatically, it manually relinquishes and reclaims DHCP leases for all available interfaces. This tests the external API to DHCP. See section below describing this.</P>
<PRE CLASS="CodeExample"><A NAME="pgfId=1137064"> </A>
<SPAN CLASS="Bold">flood</SPAN>
        - a flood ping test; use with care</PRE>
<P CLASS="Body">
<A NAME="pgfId=1136993">
 </A>
This test performs pings on all interfaces as quickly as possible, and only prints status information periodically. Flood pinging is bad for network performance; so do not use this test on general purpose networks unless protected by a switch.</P>
<H3 CLASS="Heading2">
<A NAME="pgfId=1132647">
 </A>
Performance Test</H3>
<PRE CLASS="CodeExample"><A NAME="pgfId=1132648"> </A>
<SPAN CLASS="Bold">tcp_echo</SPAN>
      - data forwarding program for performance test</PRE>
<P CLASS="Body">
<A NAME="pgfId=1132649">
 </A>
<TT CLASS="Code">
tcp_echo</TT>
 is one part of the standard performance test we use.  The other parts are host programs <TT CLASS="Code">
tcp_source</TT>
 and <TT CLASS="Code">
tcp_sink</TT>
.  To make these (under LINUX) cd to the tests source directory in the eCos repository and type &quot;<TT CLASS="Code">
make -f make.linux</TT>
&quot; - this should build <TT CLASS="Code">
tcp_source</TT>
 and <TT CLASS="Code">
tcp_sink</TT>
.</P>
<P CLASS="Body">
<A NAME="pgfId=1132650">
 </A>
The LINUX program &quot;<TT CLASS="Code">
tcp_source</TT>
&quot; sends data to the target.  On the target, &quot;<TT CLASS="Code">
tcp_echo</TT>
&quot; sends it onwards to &quot;<TT CLASS="Code">
tcp_sink</TT>
&quot; running on LINUX.  So the target must receive and send on all the data that <TT CLASS="Code">
tcp_source</TT>
 sends it; the time taken for this is measured and the data rate is calculated.</P>
<P CLASS="Body">
<A NAME="pgfId=1132651">
 </A>
To invoke the test, first start <TT CLASS="Code">
tcp_echo</TT>
 on the target board and wait for it to become quiescent - it will report work to calibrate a CPU load which can be used to simulate real operating conditions for the stack.</P>
<P CLASS="Body">
<A NAME="pgfId=1132652">
 </A>
Then on your LINUX machine, in one terminal window, invoke <TT CLASS="Code">
tcp_sink</TT>
 giving it the IP address (or hostname) of one interface of the target board.  For example &quot;<TT CLASS="Code">
tcp_sink 10.130.39.66</TT>
&quot;.  <TT CLASS="Code">
tcp_echo</TT>
 on the target will print something like &quot;<TT CLASS="Code">
SINK connection from 10.130.39.13:1143</TT>
&quot; when <TT CLASS="Code">
tcp_sink</TT>
 is correctly invoked.</P>
<P CLASS="Body">
<A NAME="pgfId=1132653">
 </A>
Next, in another LINUX terminal window, invoke <TT CLASS="Code">
tcp_source</TT>
, giving it the IP address (or hostname) of an interface of the target board, and optionally a background load to apply to the target while the test runs.  For example, &quot;<TT CLASS="Code">
tcp_source 194.130.39.66</TT>
&quot; to run the test with no additional target CPU load, or &quot;<TT CLASS="Code">
tcp_source 194.130.39.66 85</TT>
&quot; to load it up to 85% used.  The target load must be a multiple of 5.  <TT CLASS="Code">
tcp_echo</TT>
 on the target will print something like &quot;<TT CLASS="Code">
SOURCE connection from 194.130.39.13:1144</TT>
&quot; when tcp_source is correctly invoked.</P>
<P CLASS="Body">
<A NAME="pgfId=1132654">
 </A>
You can connect tcp_sink to one target interface and tcp_source to another, or both to the same interface.  Similarly, you can run <TT CLASS="Code">
tcp_sink</TT>
 and <TT CLASS="Code">
tcp_source</TT>
 on the same LINUX machine or different ones.  TCP/IP and ARP look after them finding one another, as intended.</P>
<PRE CLASS="CodeExample"><A NAME="pgfId=1137227"> </A>
<SPAN CLASS="Bold">nc_test_master</SPAN>
  - network characterization master (unsupported)
<SPAN CLASS="Bold">nc_test_slave     </SPAN>
 - network characterization slave (unsupported)</PRE>
<P CLASS="Body">
<A NAME="pgfId=1137228">
 </A>
These tests talk to each other to measure network performance. They can each run on either a test target or a LINUX host computer given some customization to your local environment. As provided, <TT CLASS="Code">
nc_test_slave</TT>
 must run on the test target, and <TT CLASS="Code">
nc_test_master</TT>
 must be run on a LINUX host, and be given the test target's IP address or hostname.</P>
<P CLASS="Body">
<A NAME="pgfId=1137229">
 </A>
The tests print network performance for various packet sizes over UDP and TCP, versus various additional CPU loads on the target.</P>
<H3 CLASS="Heading2">
<A NAME="pgfId=1132655">
 </A>
Interactive Tests</H3>
<PRE CLASS="CodeExample"><A NAME="pgfId=1137237"> </A>
<SPAN CLASS="Bold">server_test</SPAN>
 - a very simple server example</PRE>
<P CLASS="Body">
<A NAME="pgfId=1137238">
 </A>
This test simply awaits a connection on port 7734 and after accepting a connection, gets a packet (with a timeout of a few seconds) and prints it. </P>
<P CLASS="Body">
<A NAME="pgfId=1137240">
 </A>
The connection is then closed. We then loop to await the next connection, and so on. To use it, telnet to the target on port 7734 then type something (quickly!)</P>
<PRE CLASS="CodeExample"><A NAME="pgfId=1137243"> </A>
% telnet 172.16.19.171 7734 
Hello target board</PRE>
<P CLASS="Body">
<A NAME="pgfId=1137245">
 </A>
and the test program will print something like:</P>
<PRE CLASS="CodeExample"><A NAME="pgfId=1137246"> </A>
connection from 172.16.19.13:3369 
buf = 'Hello target board'</PRE>
<P CLASS="Body">
<A NAME="pgfId=1137304">
 </A>
</P>
<PRE CLASS="CodeExample"><A NAME="pgfId=1132656"> </A>
<SPAN CLASS="Bold">tftp_client_test</SPAN>
      - performs a tftp get and put from/to &quot;server&quot;</PRE>
<P CLASS="Body">
<A NAME="pgfId=1132657">
 </A>
This is only partially interactive.  You need to set things up on the &quot;server&quot; in order for this to work, and you will need to look at the server afterwards to confirm that all was well.</P>
<P CLASS="Body">
<A NAME="pgfId=1132658">
 </A>
For each interface in turn, this test attempts to read by tftp from the server, a file called &quot;<TT CLASS="Code">
tftp_get</TT>
&quot; and prints the status and contents it read (if any).  It then writes the same data to a file called &quot;<TT CLASS="Code">
tftp_put</TT>
&quot; on the same server.</P>
<P CLASS="Body">
<A NAME="pgfId=1132659">
 </A>
In order for this to succeed, both files must already exist.  The TFTP protocol does not require that a WRQ request _create_ a file, just that it can write it.  The TFTP server on Linux certainly will only allow writes to an existing file, given the appropriate permission.  Thus, you need to have these files in place, with proper permission, before running the test.</P>
<P CLASS="Body">
<A NAME="pgfId=1132660">
 </A>
The conventional place for the tftp server to operate in LINUX is /tftpboot/; you will likely need root privileges to create files there. The data contents of <TT CLASS="Code">
tftp_get</TT>
 can be anything you like, but anything very large will waste lots of time printing it on the test's stdout, and anything above 32kB will cause a buffer overflow and unpredictable failure.</P>
<P CLASS="Body">
<A NAME="pgfId=1133196">
 </A>
Creating an empty tftp_put file (eg. by copying /dev/null to it) is neatest.  So before the test you should have something like:</P>
<PRE CLASS="CodeExample"><A NAME="pgfId=1133197"> </A>
-rw-rw-rw- 1 root        1076 May  1 11:39 tftp_get
-rw-rw-rw- 1 root        0 May  1 15:52 tftp_put 
</PRE>
<P CLASS="Body">
<A NAME="pgfId=1133205">
 </A>
note that both files have public permissions wide open.  After running the test, <TT CLASS="Code">
tftp_put</TT>
 should be a copy of <TT CLASS="Code">
tftp_get</TT>
.</P>
<PRE CLASS="CodeExample"><A NAME="pgfId=1133201"> </A>

-rw-rw-rw-  1 root       1076 May  1 11:39 tftp_get
-rw-rw-rw-  1 root       1076 May  1 15:52 tftp_put

</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1133164"> </A>
<SPAN CLASS="Bold">tftp_server_test</SPAN>
        - runs a tftp server for a short while</PRE>
<P CLASS="Body">
<A NAME="pgfId=1132664">
 </A>
This test is truly interactive, in that you can use a standard tftp application to get and put files from the server, during the 5 minutes that it runs.  The dummy filesystem which underlies the server initially contains one file, called &quot;uu&quot; which contains part of a familiar text and some padding.  It also accommodates creation of 3 further files of up to 1Mb in size and names of up to 256 bytes.  Exceeding these limits will cause a buffer overflow and unpredictable failure.</P>
<P CLASS="Body">
<A NAME="pgfId=1132665">
 </A>
The dummy filesystem is an implementation of the generic API which allows a true filesystem to be attached to the tftp server in the network stack.</P>
<P CLASS="Body">
<A NAME="pgfId=1132666">
 </A>
We have been testing the tftp server by running the test on the target board, then using two different host computers connecting to the different target interfaces, putting a file from each, getting the &quot;uu&quot; file, and getting the file from the other computer.  This verifies that data is preserved during the transfer as well as interworking with standard tftp applications.</P>
<H3 CLASS="Heading2">
<A NAME="pgfId=1137326">
 </A>
Maintenance Tools </H3>
<PRE CLASS="CodeExample"><A NAME="pgfId=1137328"> </A>
<SPAN CLASS="Bold">set_mac_address</SPAN>
 - set MAC address(es) of interfaces in NVRAM</PRE>
<P CLASS="Body">
<A NAME="pgfId=1137329">
 </A>
This program makes an example ioctl() call SIOCSIFHWADDR &quot;Socket IO Set InterFace HardWare ADDRess&quot; to set the MAC address on targets where this is supported and enabled in the configuration. You must edit the source to choose a MAC address and further edit it to allow this very dangerous operation. Not all ethernet drivers support this operation, because most ethernet hardware does not support it - or it comes pre-set from the factory. Do not use this program.</P>
</DIV>
<DIV>
<H3 CLASS="Heading1">
<A NAME="pgfId=1132667">
 </A>
APIs</H3>
<H3 CLASS="Heading2">
<A NAME="pgfId=1132668">
 </A>
Standard networking</H3>
<P CLASS="Body">
<A NAME="pgfId=1132669">
 </A>
The APIs for the standard networking calls such as socket(), recv() and so on, are in header files relative to the top-level include directory, within the standard subdirectories as conventionally found in /usr/include.  For example:   </P>
<PRE CLASS="CodeExample"><A NAME="pgfId=1133209"> </A>
-rw-r-----     5582 May  5 11:36 install/include/arpa/tftp.h   
-rw-r-----      5250 Apr 20 14:20 install/include/netinet/tcpip.h   
-rw-r-----    17292 Apr 20 14:20 install/include/sys/socket.h   
-rw-r-----     15022 May  3 13:05 install/include/sys/socketvar.h   
-rw-r-----     9615 Apr 20 14:20 install/include/sys/sockio.h
</PRE>
<P CLASS="Body">
<A NAME="pgfId=1132670">
 </A>
<TT CLASS="Code">
network.h</TT>
 at the top level defines various extensions, for example the API <TT CLASS="Code">
init_all_network_interfaces(void)</TT>
 described above.  We advise including <TT CLASS="Code">
network.h</TT>
 whether you use these features or not.</P>
<P CLASS="Body">
<A NAME="pgfId=1136004">
 </A>
In general, using the networking code may require definition of two symbols: _KERNEL and __ECOS.  _KERNEL is not normally required; __ECOS is normally required.  So add this to your compile lines for files which use the network stack:</P>
<PRE CLASS="CodeExample"><A NAME="pgfId=1133241"> </A>
	-D__ECOS</PRE>
<P CLASS="Body">
<A NAME="pgfId=1132672">
 </A>
To expand a little, it's like this because this is a port of a standard distribution external to Red Hat.  One goal is to perturb the sources as little as possible, so that upgrading and maintenance from the external distribution is simplified.  The __ECOS symbol marks out Red Hat's additions in making the port.  The _KERNEL symbol is traditional UNIX practice: it distinguishes a compilation which is to be linked into the kernel from one which is part of an application.  eCos applications are fully linked, so this distinction does not apply.  _KERNEL can however be used to control the visibility of the internals of the stack, so depending on what features your application uses, it may or may not be necessary.</P>
<P CLASS="Body">
<A NAME="pgfId=1132673">
 </A>
The include file <TT CLASS="Code">
network.h</TT>
 undefines _KERNEL unconditionally, to provide an application-like compilation environment.  If you were writing code which, for example, enumerates the stack's internal structures, that is a kernel-like compilation environment, so you would need to define _KERNEL (in addition to __ECOS) and avoid including <TT CLASS="Code">
network.h</TT>
.</P>
<H3 CLASS="Heading2">
<A NAME="pgfId=1132674">
 </A>
Enhanced Select()</H3>
<P CLASS="Body">
<A NAME="pgfId=1132675">
 </A>
The network stack supports an extension to the standard select semantics which allows all threads that are waiting to be restarted even if the select conditions are not satisfied.</P>
<P CLASS="Body">
<A NAME="pgfId=1132676">
 </A>
The standard select() API:  </P>
<PRE CLASS="CodeExample"><A NAME="pgfId=1133216"> </A>
int  
select(int nfd, fd_set *in, fd_set *out, fd_set *ex,
          struct timeval *tv); </PRE>
<P CLASS="Body">
<A NAME="pgfId=1133217">
 </A>
does not support the restart.</P>
<P CLASS="Body">
<A NAME="pgfId=1132677">
 </A>
The additional API:  </P>
<PRE CLASS="CodeExample"><A NAME="pgfId=1133221"> </A>
int  
cyg_select_with_abort(int nfd, fd_set *in, fd_set *out, fd_set *ex,
                       struct timeval *tv) </PRE>
<P CLASS="Body">
<A NAME="pgfId=1133222">
 </A>
behaves exactly as select() with the additional feature that a call to         </P>
<PRE CLASS="CodeExample"><A NAME="pgfId=1133226"> </A>
void cyg_select_abort(void) </PRE>
<P CLASS="Body">
<A NAME="pgfId=1133227">
 </A>
will cause all threads waiting in any <TT CLASS="Code">
cyg_select_with_abort()</TT>
 call to cease waiting and continue execution.</P>
<H3 CLASS="Heading2">
<A NAME="pgfId=1132678">
 </A>
TFTP</H3>
<P CLASS="Body">
<A NAME="pgfId=1132679">
 </A>
The TFTP client and server are described in <TT CLASS="Code">
tftp_support.h</TT>
; the client API is simple and can be easily understood by reading <TT CLASS="Code">
tftp_client_test.c</TT>
.</P>
<P CLASS="Body">
<A NAME="pgfId=1132680">
 </A>
The server is more complex.  It requires a filesystem implementation to be supplied by the user, and attached to the tftp server by means of a vector of function pointers:</P>
<PRE CLASS="CodeExample"><A NAME="pgfId=1133231"> </A>
struct tftpd_fileops {
             int (*open)(const char *, int);
             int (*close)(int);
             int (*write)(int, const void *, int);
             int (*read)(int, void *, int);         
};
</PRE>
<P CLASS="Body">
<A NAME="pgfId=1132681">
 </A>
These functions have the obvious semantics.  The structure describing the filesystem is an argument to the <TT CLASS="Code">
tftpd_start(int, struct tftpd_fileops *);</TT>
 call.  The first argument is the port to use for the server.</P>
<P CLASS="Body">
<A NAME="pgfId=1132682">
 </A>
As discussed in the description of the tftp_server_test above, an example filesystem is provided in <TT CLASS="Code">
net/tcpip/VERSION/src/lib/tftp_dummy_file.c</TT>
 for use by the tftp server test.  The dummy filesystem is not a supported part of the network stack, it exists purely for demonstration purposes.</P>
<H3 CLASS="Heading2">
<A NAME="pgfId=1132683">
 </A>
DHCP</H3>
<P CLASS="Body">
<A NAME="pgfId=1132684">
 </A>
This API publishes a routine to maintain DHCP state, and a semaphore that is signalled when a lease requires attention: this is your clue to call the aforementioned routine.</P>
<P CLASS="Body">
<A NAME="pgfId=1132685">
 </A>
The intent with this API is that a simple DHCP client thread, which maintains the state of the interfaces, can go as follows: (after <TT CLASS="Code">
init_all_networks</TT>
 is called from elsewhere)</P>
<PRE CLASS="CodeExample"><A NAME="pgfId=1132686"> </A>
while ( 1 ) {
        while ( 1 ) {
            cyg_semaphore_wait( &amp;dhcp_needs_attention );
            if ( ! dhcp_bind() ) // a lease expired
                break; // If we need to re-bind        
				  }
        dhcp_halt(); // tear everything down
        init_all_network_interfaces(); // re-initialize    
}
</PRE>
<P CLASS="Body">
<A NAME="pgfId=1132687">
 </A>
and if the application does not want to suffer the overhead of a separate thread and its stack for this, this functionality can be placed in the app's server loop in an obvious fashion.  That is the goal of breaking out these internal elements.  For example, some server might be arranged to poll DHCP from time to time like this:</P>
<PRE CLASS="CodeExample"><A NAME="pgfId=1132688"> </A>
while ( 1 ) {
    init_all_network_interfaces();
    open-my-listen-sockets();
    while ( 1 ) {
       serve-one-request();
       // sleeps if no connections, but not forever; 
       // so this loop is polled a few times a minute...
       if ( cyg_semaphore_trywait( &amp;dhcp_needs_attention )) {
             if ( ! dhcp_bind() ) {
                 close-my-listen-sockets();
                 dhcp_halt();
                 break;
             }
       }
    }
}
</PRE>
<P CLASS="Body">
<A NAME="pgfId=1132689">
 </A>
If the configuration option CYGOPT_NET_DHCP_DHCP_THREAD is defined, then eCos provides a thread as described initially.  Independent of this option, initialization of the interfaces still occurs in <TT CLASS="Code">
init_all_network_interfaces()</TT>
 and your startup code must call that.  It will start the DHCP management thread if configured.  If a lease fails to be renewed, the management thread will shut down all interfaces and attempt to initialize all the interfaces again from scratch.  This may cause chaos in the app, which is why managing the DHCP state in an application aware thread is actually better, just far less convenient for testing.</P>
</DIV>
<HR ALIGN="center"><TABLE STYLE="ECOS" WIDTH="98%" BORDER="0" ALIGN="LEFT" CELLPADDING="1"><TR><TH COLSPAN="3" ALIGN="center"><P CLASS="Gotos">TCP/IP</P></TH></TR><TR><TD  ALIGN="center"><P CLASS="Gotos"><A HREF="tcpip.html">Contents</A></P></TD><TD  ALIGN="center"><P CLASS="Gotos"><A HREF="tcpip.2.html">To&nbsp;previous&nbsp;page</A></P></TD><TD  ALIGN="center"><P CLASS="Gotos"><A HREF="tcpip.4.html">To&nbsp;next&nbsp;page</A></P></TD></TR></TABLE></BODY>
</HTML>
