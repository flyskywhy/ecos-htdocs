<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML EXPERIMENTAL 970324//EN">
<HTML>
<HEAD><!--version 1.0/Mon Sep 18 18:08:39 BST 2000--><!--version 1.0/Mon Sep 18 18:08:30 BST 2000-->
<META NAME="GENERATOR" CONTENT="Adobe FrameMaker 5.5/HTML Export Filter">
<LINK REL="STYLESHEET" HREF="cygnus.css">
<TITLE> User Commands</TITLE></HEAD>
<BODY BGCOLOR="#ffffff">
<DIV>
<TABLE STYLE="ECOS" WIDTH="100%" BORDER="0" ALIGN="LEFT" CELLPADDING="3"><TR><TH COLSPAN="2" ALIGN="center"><P CLASS="Gotos">User Commands</P></TH></TR><TR><TD WIDTH="47%" ALIGN="center"><P CLASS="Gotos"><A HREF="redboot.html">To&nbsp;main&nbsp;page</A></P></TD><TD WIDTH="47%" ALIGN="center"><P CLASS="Gotos"><A HREF="redboot.3.html">To&nbsp;previous&nbsp;page</A></P></TD></TR></TABLE><P ALIGN="LEFT">&nbsp;</P><BR><HR ALIGN="center"></DIV>
<H2 CLASS="ChapterTitle">
<A NAME="pgfId=2634990">
 </A>
User Commands<DIV>
<IMG SRC="redboot-4.gif">
</DIV>
</H2>
<P CLASS="Body">
<A NAME="pgfId=2634873">
 </A>
The standard RedBoot command set is structured around the bootstrap environment.  These commands are designed to be simple to use and remember, while still providing sufficient power and flexibility to be useful.  No attempt has been made to render RedBoot as the end-all product.  As such, things such as the debug environment are left to other modules, such as GDB stubs, which are typically included in RedBoot.</P>
<P CLASS="Body">
<A NAME="pgfId=2634874">
 </A>
The command set may be also be extended on a platform basis.</P>
<DIV>
<H3 CLASS="Heading1">
<A NAME="pgfId=2634875">
 </A>
Common commands:</H3>
<P CLASS="Body">
<A NAME="pgfId=2634876">
 </A>
The general format of commands is:   </P>
<PRE CLASS="CodeExample"><A NAME="pgfId=2635013"> </A>
&lt;command&gt; &lt;options, parameters&gt; </PRE>
<P CLASS="Body">
<A NAME="pgfId=2635014">
 </A>
Elements are separated by the space character.  Other control characters, such as <SPAN CLASS="Bold">
TAB</SPAN>
 or editing keys (<SPAN CLASS="Bold">
Insert</SPAN>
) are not currently supported.</P>
<P CLASS="Body">
<A NAME="pgfId=2634877">
 </A>
Numbers, such as a memory location, may be specified in either decimal or hexadecimal (requires a 0x prefix).</P>
<P CLASS="Body">
<A NAME="pgfId=2634878">
 </A>
Use the 'help' command to get limited help on command syntax.</P>
  <PRE CLASS="CodeExample"><A NAME="pgfId=2635028"> </A>
=================================================================
RedBoot&gt; help     
Display (hex dump) a range of memory
        dump &lt;location&gt; [&lt;length&gt;]     
Manage FLASH images
        fis {cmds}     
Manage configuration kept in FLASH memory
        fconfig     
Execute code at a location
        go [-w &lt;timeout&gt;] [entry]     
Help about help?
        help &lt;topic&gt;     
Load a file
        load [-raw] [-b &lt;mem_addr&gt;]]     
RedBoot&gt;     <br>==================================================================</PRE>
<P CLASS="Body">
<A NAME="pgfId=2634880">
 </A>
Commands may be abbreviated to any unique string.  For example, 'lo' is equivalent to 'loa' and 'load'.</P>
</DIV>
<DIV>
<H3 CLASS="Heading1">
<A NAME="pgfId=2634881">
 </A>
Download Process</H3>
<P CLASS="Body">
<A NAME="pgfId=2634882">
 </A>
Currently, download is only supported using TFTP over a network. Files to be downloaded may either be executable images in SREC format  or raw data. The format of the command is:</P>
<PRE CLASS="CodeExample"><A NAME="pgfId=2635044"> </A>
RedBoot&gt; load &lt;file&gt; [-v] [-b &lt;location&gt;] [-r] </PRE>
<P CLASS="Body">
<A NAME="pgfId=2635089">
 </A>
where:   </P>
<TABLE>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=2635103">
 </A>
&lt;file&gt;</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=2635105">
 </A>
The name of the file on the TFTP server.  Details of how this is specified are host-specific.   </P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=2635107">
 </A>
-v    </P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=2635122">
 </A>
Display a small spinner (indicator) while the download is in  progress.  This is just for feedback, especially during long loads.  </P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=2635111">
 </A>
-b   </P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=2635129">
 </A>
Specify the location in memory to which the file should be loaded.  Executable images normally load at the location to which the file was linked.  This option allows the file to be loaded to a specific memory location, possibly overriding any assumed location.   </P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=2635115">
 </A>
-r   </P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=2635136">
 </A>
Download raw data.  Normally, the load command is used to load executable images into memory.  This option allows for raw data to be loaded.  If this option is given, &quot;-b&quot; will also be required.</P>
</TD>
</TR>
</TABLE>
  <PRE CLASS="CodeExample"><A NAME="pgfId=2634883"> </A>
=============================================================
RedBoot&gt; lo redboot.ROM -b 0x8c400000       
Address offset = 0x0c400000     
Entry point: 0x80000000, address range: 0x80000000-0x8000fe80     <br>=============================================================</PRE>
</DIV>
<DIV>
<H3 CLASS="Heading1">
<A NAME="pgfId=2634884">
 </A>
Flash Image System (FIS)</H3>
<P CLASS="Body">
<A NAME="pgfId=2634885">
 </A>
If the platform has flash memory, RedBoot can use this for image storage. Executable images, as well as data, can be stored in flash in a simple file store.  The 'fis' command is used to manipulate and maintain flash images.</P>
<P CLASS="Body">
<A NAME="pgfId=2634886">
 </A>
The available 'fis' commands are:</P>
<PRE CLASS="CodeExample"><A NAME="pgfId=2635165"> </A>
<CODE CLASS="CodeOutput">fis init [-f]</CODE>
</PRE>
<P CLASS="Body">
<A NAME="pgfId=2635166">
 </A>
This command is used to initialize the Flash Image System (FIS).  It should only be executed once, when RedBoot is first installed on the hardware.  Subsequent executions will cause loss of data in the flash (previously saved images will no longer be accessible).</P>
<P CLASS="Body">
<A NAME="pgfId=2634889">
 </A>
If the &quot;-f&quot; option is specified, all blocks of flash memory will be erased as part of this process.</P>
  <PRE CLASS="CodeExample"><A NAME="pgfId=2634890"> </A>
==================================================================<br>RedBoot&gt; fis init -f     
About to initialize [format] FLASH image system - are you sure (y/n)? n
==================================================================</PRE>
<P CLASS="Body">
<A NAME="pgfId=2635184">
 </A>
</P>
<PRE CLASS="CodeExample"><A NAME="pgfId=2635183"> </A>
<CODE CLASS="CodeOutput">fis list </CODE>
</PRE>
<P CLASS="Body">
<A NAME="pgfId=2634892">
 </A>
This command lists the images currently available in the FIS.  Certain images used by RedBoot have fixed names.  Other images can be manipulated by the user.</P>
  <PRE CLASS="CodeExample"><A NAME="pgfId=2634893"> </A>
==================================================================
RedBoot&gt; fis list     
Name              FLASH addr   Mem addr    Length    Entry point     
RedBoot          0xA0000000   0xA0000000  0x020000  0x80000000     
RedBoot[backup]  0xA0020000   0x8C010000  0x010000  0x8C010000     
RedBoot config   0xA0FC0000   0xA0FC0000  0x020000  0x00000000     
FIS directory    0xA0FE0000   0xA0FE0000  0x020000  0x00000000     
==================================================================</PRE>
<P CLASS="Body">
<A NAME="pgfId=2635182">
 </A>
</P>
<PRE CLASS="CodeExample"><A NAME="pgfId=2634894"> </A>
<CODE CLASS="CodeOutput">fis free </CODE>
</PRE>
<P CLASS="Body">
<A NAME="pgfId=2634895">
 </A>
This command shows which areas of the flash memory are currently not in use. In use means that the block contains non-erased contents.  Since it is possible to force an image to be loaded at a particular flash location, this command can be used to check whether that location is in use by any other image.</P>
<H3 CLASS="Label">
<A NAME="pgfId=2634896">
 </A>
Note: </H3>
<P CLASS="Note">
<A NAME="pgfId=2635475">
 </A>
There is currently no cross-checking between actual flash contents and the image directory, which mans that there could be a segment of flash which is not erased that does not correspond to a named image, or vice-versa.</P>
  <PRE CLASS="CodeExample"><A NAME="pgfId=2634897"> </A>
==================================================================
RedBoot&gt; fis free
       0xA0040000 .. 0xA07C0000
       0xA0840000 .. 0xA0FC0000     
==================================================================</PRE>
<P CLASS="Body">
<A NAME="pgfId=2635193">
 </A>
</P>
<PRE CLASS="CodeExample"><A NAME="pgfId=2634898"> </A>
<CODE CLASS="CodeOutput">fis create -b &lt;mem_base&gt; -l &lt;length&gt; [-f &lt;flash_addr&gt;] [-e &lt;entry_point&gt;] [-r &lt;ram_addr&gt;] &lt;name&gt;</CODE>
</PRE>
<P CLASS="Body">
<A NAME="pgfId=2634899">
 </A>
This command creates an image in the FIS directory.  The data for the image must exist in RAM memory before the copy.  Typically, one would use the RedBoot 'load' command to load an image into RAM and then the 'fis create' command to write it to flash. </P>
<P CLASS="Body">
<A NAME="pgfId=2634900">
 </A>
Options:   </P>
<TABLE>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=2635213">
 </A>
&lt;name&gt;</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=2635215">
 </A>
The name of the file, as shown in the FIS directory.   </P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=2635217">
 </A>
-b</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=2635219">
 </A>
The location in RAM used to obtain the image. This is a required option.   </P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=2635221">
 </A>
-l</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=2635223">
 </A>
The length of the location. This is a required option.   </P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=2635225">
 </A>
-f</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=2635227">
 </A>
The location in flash for the image.  If this is not provided, the first freeVblock which is large enough will be used.  See 'fis free'.   </P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=2635229">
 </A>
-e</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=2635231">
 </A>
The execution entry address.  This is used if the starting address for an image is not known, or needs to be overridden.   </P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=2635233">
 </A>
-r</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=2635235">
 </A>
The location in RAM when the image is loaded via 'fis load'.  This only needs to be specified for images which will eventually loaded via 'fis load'.  Fixed images, such as RedBoot itself, will not need this.</P>
</TD>
</TR>
</TABLE>
  <PRE CLASS="CodeExample"><A NAME="pgfId=2635239"> </A>
==================================================================
RedBoot&gt; fis create RedBoot -f 0xa0000000 -b 0x8c400000 -l 0x20000     
An image named 'RedBoot' exists - are you sure (y/n)? n     
RedBoot&gt; fis create junk -b 0x8c400000 -l 0x20000
... Erase from 0xa0040000-0xa0060000: .
... Program from 0x8c400000-0x8c420000 at 0xa0040000: .
... Erase from 0xa0fe0000-0xa1000000: .
... Program from 0x8c7d0000-0x8c7f0000 at 0xa0fe0000: .
==================================================================</PRE>
<P CLASS="Body">
<A NAME="pgfId=2635245">
 </A>
</P>
<PRE CLASS="CodeExample"><A NAME="pgfId=2634902"> </A>
<CODE CLASS="CodeOutput">fis load name</CODE>
</PRE>
<P CLASS="Body">
<A NAME="pgfId=2634903">
 </A>
This command is used to transfer an image from flash memory to RAM.  Once loaded, it may be executed using the 'go' command.</P>
  <PRE CLASS="CodeExample"><A NAME="pgfId=2634904"> </A>
==================================================================
RedBoot&gt; fis load RedBoot[backup]     
RedBoot&gt; go     
==================================================================</PRE>
<P CLASS="Body">
<A NAME="pgfId=2635252">
 </A>
</P>
<PRE CLASS="CodeExample"><A NAME="pgfId=2634905"> </A>
<CODE CLASS="CodeOutput">fis delete name</CODE>
</PRE>
<P CLASS="Body">
<A NAME="pgfId=2635333">
 </A>
This command removes an image from the FIS.  The flash memory will be erased as part of the execution of this command, as well as removal of the name from the FIS directory.</P>
  <PRE CLASS="CodeExample"><A NAME="pgfId=2635337"> </A>
==================================================================
RedBoot&gt; fis list     
Name              FLASH addr   Mem addr    Length    Entry point     
RedBoot          0xA0000000   0xA0000000  0x020000  0x80000000     
RedBoot[backup]  0xA0020000   0x8C010000  0x020000  0x8C010000     
RedBoot config   0xA0FC0000   0xA0FC0000  0x020000  0x00000000     
FIS directory    0xA0FE0000   0xA0FE0000  0x020000  0x00000000     
junk             0xA0040000   0x8C400000  0x020000  0x80000000     
RedBoot&gt; fis delete junk     
Delete image 'junk' - are you sure (y/n)? y     
... Erase from 0xa0040000-0xa0060000: .     
... Erase from 0xa0fe0000-0xa1000000: .     
... Program from 0x8c7d0000-0x8c7f0000 at 0xa0fe0000: .
==================================================================</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=2635262"> </A>
<CODE CLASS="CodeOutput"></CODE>
</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=2635438"> </A>
<CODE CLASS="CodeOutput">fis lock -f &lt;flash_addr&gt; -l &lt;length&gt;</CODE>
</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=2635414"> </A>
This command is used to write-protect [lock] a portion of flash memory, to prevent accidental overwriting of images. In order to make make any modifications to the flash, a matching unlock command must be issued. This command is optional and will only be provided on hardware which can support write-protection of the flash space. Note: depending on the system, attempting to write to write-protected flash may generate errors or warnings, or be benignly quiet. ==================================================================
RedBoot fis lock -f 0xa0040000 -l 0x20000 
... Lock from 0xa0040000-0xa0060000: . 
==================================================================</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=2635418"> </A>
<CODE CLASS="CodeOutput"></CODE>
</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=2635439"> </A>
<CODE CLASS="CodeOutput">fis unlock -f &lt;flash_addr&gt; -l &lt;length&gt;</CODE>
</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=2635419"> </A>
This command is used to unlock a portion of flash memory forcibly, allowing it to be updated. It must be issued for regions which have been locked before the FIS can reuse those portions of flash. ==================================================================
RedBoot fis unlock -f 0xa0040000 -l 0x20000 
... Unlock from 0xa0040000-0xa0060000: . 
==================================================================</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=2634908"> </A>
<CODE CLASS="CodeOutput"></CODE>
</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=2635440"> </A>
<CODE CLASS="CodeOutput">fis erase -f &lt;flash_addr&gt; -l &lt;length&gt;</CODE>
</PRE>
<P CLASS="Body">
<A NAME="pgfId=2634909">
 </A>
This command is used to erase a portion of flash memory forcibly.  There is no cross-checking to ensure that the area being erased does not correspond to a loaded image.</P>
  <PRE CLASS="CodeExample"><A NAME="pgfId=2634910"> </A>
==================================================================
RedBoot&gt; fis erase -f 0xa0040000 -l 0x20000     
... Erase from 0xa0040000-0xa0060000: .     
==================================================================</PRE>
<P CLASS="Body">
<A NAME="pgfId=2635269">
 </A>
</P>
</DIV>
<DIV>
<H3 CLASS="Heading1">
<A NAME="pgfId=2634911">
 </A>
Persistent state [flash-based configuration] control</H3>
<P CLASS="Body">
<A NAME="pgfId=2634912">
 </A>
Additionally, if the platform has flash memory, certain control and configuration information used by RedBoot can be stored in flash.  The details of what information is maintained in flash differs, based on the platform and the configuration. However, the basic operation used to maintain this information is the same. Using the 'fconfig' command, the information may be displayed and/or changed.</P>
<P CLASS="Body">
<A NAME="pgfId=2634914">
 </A>
Usage:   </P>
<PRE CLASS="CodeExample"><A NAME="pgfId=2635273"> </A>
RedBoot&gt; fconfig [-l] </PRE>
<P CLASS="Body">
<A NAME="pgfId=2635274">
 </A>
If the optional flag &quot;-l&quot; is specified, the configuration data is simply listed. Otherwise, each configuration parameter will be displayed and you are given a chance to change it.  The entire value must be typed - typing just carriage return will leave a value unchanged.  Boolean values may be entered using the first letter ('t' for true, 'f' for false).  At any time the editing process may be stopped simply by entering just a '.' (period) on the line.  Entry of the character '^' will move the editing back to the previous item.</P>
<P CLASS="Body">
<A NAME="pgfId=2634915">
 </A>
If any changes are made in the configuration, then the updated data will be written back to flash after getting acknowledgement from the user.</P>
<P CLASS="Body">
<A NAME="pgfId=2634916">
 </A>
One item which is always present in the configuration data is the ability to execute a script at boot/startup time.  A sequence of RedBoot commands can be entered which will be executed when the system starts up.  Optionally, a time-out period can be provided which allows the user to abort the startup script and proceed with normal command processing from the console.</P>
  <PRE CLASS="CodeExample"><A NAME="pgfId=2634917"> </A>
==================================================================
RedBoot&gt; fconfig -l     
Run script at boot: false     
Use BOOTP for network configuration: false     
Local IP address: 192.168.1.29     
Default server IP address: 192.168.1.101     
GDB connection port: 9000     
Network debug at boot time: false     <br>==================================================================</PRE>
<P CLASS="Body">
<A NAME="pgfId=2635281">
 </A>
</P>
<PRE CLASS="CodeExample"><A NAME="pgfId=2634918"> </A>
The following example sets a boot script and then shows it running.  </PRE>
  <PRE CLASS="CodeExample"><A NAME="pgfId=2635358"> </A>
==================================================================
RedBoot&gt; fconfig
         ^^^^^^^     
Run script at boot: false t
                          ^
     Boot script:     
Enter script, terminate with empty line     
&gt;&gt; fi li        
   ^^^^^
&gt;&gt; ^
Boot script timeout: 0 10 
                       ^^     
Use BOOTP for network configuration: false .
                                           ^     
Update RedBoot non-volatile configuration - are you sure (y/n)? y
                                                                ^
... Erase from 0xa0fc0000-0xa0fe0000: .     
... Program from 0x8c021f60-0x8c022360 at 0xa0fc0000: .
RedBoot&gt;     
RedBoot(tm) debug environment - built 08:22:24, Aug 23 2000
Copyright (C) 2000, Red Hat, Inc.         

RAM: 0x8c000000-0x8c800000     
FLASH: 0xa0000000 - 0xa1000000, 128 blocks of 0x00020000 bytes ea.     
Socket Communications, Inc: Low Power Ethernet CF Revision C 5V/3.3V 08/27/98     
IP: 192.168.1.29, Default server: 192.168.1.101     
== Executing boot script in 10 seconds - enter ^C to abort     
RedBoot&gt; fi li     
Name              FLASH addr   Mem addr    Length    Entry point     
RedBoot          0xA0000000   0xA0000000  0x020000  0x80000000     
RedBoot[backup]  0xA0020000   0x8C010000  0x020000  0x8C010000     
RedBoot config   0xA0FC0000   0xA0FC0000  0x020000  0x00000000     
FIS directory    0xA0FE0000   0xA0FE0000  0x020000  0x00000000     
RedBoot&gt;              
        ^
==================================================================</PRE>
<H3 CLASS="Label">
<A NAME="pgfId=2634919">
 </A>
Note: </H3>
<P CLASS="Note">
<A NAME="pgfId=2635443">
 </A>
The '^' characters above indicate where something was entered on the console.  As you can see, the 'fi li' command at the end came from the script, not the console.  Once the script is executed, command processing reverts to the console.</P>
</DIV>
<DIV>
<H3 CLASS="Heading1">
<A NAME="pgfId=2634920">
 </A>
Program execution</H3>
<P CLASS="Body">
<A NAME="pgfId=2634921">
 </A>
Once an image has been loaded into memory, either via the 'load' command or the 'fis load' command, execution may be transfered to that image. </P>
<H3 CLASS="Label">
<A NAME="pgfId=2635453">
 </A>
Note: </H3>
<P CLASS="Note">
<A NAME="pgfId=2635454">
 </A>
The image is assumed to be a stand-alone entity, as RedBoot gives the entire platform over to it.  Typical examples would be an eCos application or a Linux kernel.</P>
<P CLASS="Body">
<A NAME="pgfId=2634922">
 </A>
The format of the 'go' command is:   </P>
<PRE CLASS="CodeExample"><A NAME="pgfId=2635298"> </A>
RedBoot&gt; go [-w &lt;time&gt;] [&lt;location&gt;] </PRE>
<P CLASS="Body">
<A NAME="pgfId=2635299">
 </A>
Execution will begin at &lt;location&gt; if specified.  Otherwise, the &quot;entry point&quot; of the last image loaded will be used.</P>
<P CLASS="Body">
<A NAME="pgfId=2634923">
 </A>
The &quot;-w&quot; option gives the user &lt;time&gt; seconds before execution begins. The execution may be aborted by typing ^C on the console.  This mode would typically be used in startup scripts.</P>
</DIV>
<DIV>
<H3 CLASS="Heading1">
<A NAME="pgfId=2634929">
 </A>
Installation and testing:</H3>
<H3 CLASS="Heading2">
<A NAME="pgfId=2635859">
 </A>
Intel StrongARM EBSA-285-Building Test Cases to run with RedBoot</H3>
<P CLASS="Body">
<A NAME="pgfId=2635880">
 </A>
The default configuration for EBSA-285 at present always sends diagnostic output to the serial line; to use RedBoot to channel diagnostic output to GDB whether connected by net or serial, enable the configuration option</P>
<PRE CLASS="CodeExample"><A NAME="pgfId=2636327"> </A>
 CYGSEM_HAL_VIRTUAL_VECTOR_DIAG 
&quot;Do diagnostic IO via virtual vector table&quot; </PRE>
<P CLASS="Body">
<A NAME="pgfId=2636328">
 </A>
located here in the common HAL configuration tree: </P>
<PRE CLASS="CodeExample"><A NAME="pgfId=2636329"> </A>
&quot;eCos HAL&quot;
    &quot;ROM monitor support&quot; 
        &quot;Enable use of virtual vector calling interface&quot; 
            &quot;Do diagnostic IO via virtual vector table&quot; </PRE>
<P CLASS="Body">
<A NAME="pgfId=2636330">
 </A>
Other than that, no special configuration is required to use RedBoot. </P>
<P CLASS="Body">
<A NAME="pgfId=2636331">
 </A>
If you have been using built-in stubs to acquire support for thread-aware debugging, you can still do that, but you must only use the serial device for GDB connection and you must not enable the option mentioned above. However, it is no longer necessary to do that to get thread-awareness; RedBoot is thread aware. </P>
<H3 CLASS="Heading2">
<A NAME="pgfId=2635552">
 </A>
Installation on the Intel StrongARM EBSA-285 development system and equivalents. </H3>
<P CLASS="Body">
<A NAME="pgfId=2635557">
 </A>
Here's how to install RedBoot, using the redboot images you should find in <TT CLASS="Code">
loaders/arm-ebsa285/</TT>
 in your installation directory: </P>
<PRE CLASS="CodeExample"><A NAME="pgfId=2636344"> </A>
431497 Aug 9 15:28 redboot-ram.elf 
184802 Aug 9 15:28 redboot-ram.srec 
433104 Aug 9 15:29 redboot-rom.elf (this one is not used) 
194732 Aug 9 15:29 redboot-rom.srec </PRE>
<P CLASS="Body">
<A NAME="pgfId=2636345">
 </A>
Copy the two '.srec' files to /tftpboot or where-ever they have to be for your TFTP server. </P>
<P CLASS="Body">
<A NAME="pgfId=2636349">
 </A>
Briefly, we use whatever boot flash image you have in place already (CygMon or an eCos stub ROM) along with GDB, to execute a RAM based version of RedBoot. That is used, in its command-line mode, to fetch a ROM-based boot image of RedBoot and write it into the flash memory. &quot;Fetching&quot; the image means TFTP from a server; the image must be in S-Record format. We then reset the target, thus running the newly-installed boot image of RedBoot. That in turn is used, in its command-line mode, to fetch a RAM-based boot image of RedBoot and write it into a different area of the flash memory, in order to make it easier to do the first part (running a RAM-based RedBoot in order to update the boot block) again in future. </P>
<P CLASS="Body">
<A NAME="pgfId=2636350">
 </A>
Alternatively you can make a plain binary from the redboot-rom.elf and &quot;blow&quot; that into the boot flash using the means of your choice, as with previous systems. </P>
<P CLASS="Body">
<A NAME="pgfId=2636351">
 </A>
1. Load a RedBoot, built for RAM startup, into RAM using existing GDB stubs. Note: do not run it yet! </P>
<PRE CLASS="CodeExample"><A NAME="pgfId=2636352"> </A>
% arm-elf-gdb -nw loaders/arm-ebsa285/redboot-ram.elf 

GNU gdb 4.18-ecos-99r1-991015 
Copyright 1998 Free Software Foundation, Inc. 
GDB is free software, covered by the GNU General Public License, and you are welcome to change it and/or distribute copies of it under certain conditions. Type &quot;show copying&quot; to see the conditions. This version of GDB is supported for customers of Cygnus Solutions. Type &quot;show warranty&quot; for details. 
This GDB was configured as &quot;--host=i686-pc-linux-gnu 
--target=arm-elf&quot;...(no debugging symbols found)... 
(gdb) set remotebaud 38400 
(gdb) tar rem /dev/ttyS0 
Remote debugging using /dev/ttyS0 
0x41000838 in ?? () 
(gdb) load 
Loading section .rom_vectors, size 0x44 lma 0x20000 
Loading section .text, size 0xf06c lma 0x20044 
Loading section .rodata, size 0x19a8 lma 0x2f0b0 
Loading section .data, size 0x474 lma 0x30a58 
Start address 0x20044 , load size 69324 
Transfer rate: 25208 bits/sec. 
(gdb) detach 
Ending remote debugging. 
(gdb) q </PRE>
<P CLASS="Body">
<A NAME="pgfId=2636353">
 </A>
2. Execute RedBoot from RAM, and initialize the flash filing system. </P>
<H3 CLASS="Label">
<A NAME="pgfId=2636386">
 </A>
Notes: </H3>
<P CLASS="Body">
<A NAME="pgfId=2636387">
 </A>
The key here is the &quot;-o&quot; option which keeps minicom from sending junk. </P>
<P CLASS="Body">
<A NAME="pgfId=2636354">
 </A>
The magic phrase &quot;$c#63&quot; is important: you must type it in exactly thus. It is the packet which a &quot;continue&quot; command in GDB would send to the target. If you get no response, try &quot;+$c#63&quot; instead. The IP and server info comes from BOOTP, which is how this RedBoot will start up if the flash does not contain good config info. </P>
<PRE CLASS="CodeExample"><A NAME="pgfId=2636355"> </A>
% minicom -o ttyS0 
$c#63 
RedBoot(tm) debug environment - built 07:45:57, Aug 7 2000 
Copyright (C) 2000, Red Hat, Inc. 

RAM: 0x00000000-0x01000000 
FLASH: 0x41000000 - 0x41400000, 16 blocks of 0x00040000 bytes ea. 
IP: 192.168.1.25, Default server: 192.168.1.101 
show tcp = 0x00030d48 
RedBoot fi init 
About to initialize [format] FLASH image system - are you sure (y/n)? y 
*** Initialize FLASH Image System 
Warning: device contents not erased, some blocks may not be usable 
... Erase from 0x413c0000-0x41400000: . 
... Program from 0x00fb0000-0x00fb0400 at 0x413c0000: . </PRE>
<P CLASS="Body">
<A NAME="pgfId=2636356">
 </A>
 3. Program RedBoot image into FLASH: This expects the file redboot-rom.srec to exist in the TFTP server space on the server that answered the BOOTP request. </P>
<PRE CLASS="CodeExample"><A NAME="pgfId=2636357"> </A>
Redboot&gt; lo -v redboot-rom.srec -b 0x00100000 
Address offset = bf100000 
Entry point: 0x41000044, address range: 0x41000000-0x41011384 
Redboot&gt; fi cr RedBoot -f 0x41000000 -b 0x00100000 -l 0x20000 
An image named 'RedBoot' exists - are you sure (y/n)? y 
... Erase from 0x41000000-0x41020000: . 
... Program from 0x00100000-0x00120000 at 0x41000000: . 
... Erase from 0x413c0000-0x41400000: . 
... Program from 0x00fb0000-0x00ff0000 at 0x413c0000: . 
RedBoot&gt; </PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=2636358"> </A>
****reset the board here, leaving your terminal program connected**** </PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=2636359"> </A>
RedBoot(tm) debug environment - built 07:47:35, Aug 7 2000 
Copyright (C) 2000, Red Hat, Inc. 

RAM: 0x00000000-0x01000000 
FLASH: 0x41000000 - 0x41400000, 16 blocks of 0x00040000 bytes ea. 
IP: 192.168.1.25, Default server: 192.168.1.101 
show tcp = 0x000082f0 
RedBoot&gt; </PRE>
<P CLASS="Body">
<A NAME="pgfId=2636360">
 </A>
4. Install RAM based RedBoot for backup/update: Similar considerations apply: redboot-ram.srec must be an S-record version of RedBoot built for RAM startup. </P>
<PRE CLASS="CodeExample"><A NAME="pgfId=2636361"> </A>
RedBoot&gt; lo -v redboot-ram.srec 
Entry point: 0x00020044, address range: 0x00020000-0x00030ecc 
RedBoot&gt; fi cr RedBoot[backup] -f 0x41040000 -b 0x20000 -r 0x20000 -l 0x20000 
An image named 'RedBoot[backup]' exists - are you sure (y/n)? y 
... Erase from 0x41040000-0x41060000: . 
... Program from 0x00020000-0x00040000 at 0x41040000: . 
... Erase from 0x413c0000-0x41400000: . 
... Program from 0x00fb0000-0x00ff0000 at 0x413c0000: . 
RedBoot&gt; </PRE>
<P CLASS="Body">
<A NAME="pgfId=2636362">
 </A>
You have now updated your board completely. </P>
<P CLASS="Body">
<A NAME="pgfId=2636365">
 </A>
5. To update RedBoot with a new version of RedBoot, it is necessary to run a RAM-based version of RedBoot which itself re-writes the ROM-based one, because you can't re-write the code that is executing at the time. </P>
<PRE CLASS="CodeExample"><A NAME="pgfId=2636366"> </A>
Redboot&gt; fi lo RedBoot[backup]
Redboot&gt; g 
+ 
RedBoot(tm) 
debug environment - built 07:45:57, Aug 7 2000 
Copyright (C) 2000, Red Hat, Inc. 

RAM: 0x00000000-0x01000000 
FLASH: 0x41000000 - 0x41400000, 16 blocks of 0x00040000 bytes ea. 
IP: 192.168.1.25, Default server: 192.168.1.101 
show tcp = 0x00030d48 
Redboot&gt; </PRE>
<P CLASS="Body">
<A NAME="pgfId=2636367">
 </A>
.. continue with step 3, using whatever your new boot image is called in the TFTP-place, in .srec format. </P>
<P CLASS="Body">
<A NAME="pgfId=2636368">
 </A>
You probably also want to set up then environment with your own IP addresses and so on. Recall that this IP address is the one you use for GDB to talk to the board, not the IP address which the eCos application will take on (by BOOTP/DHCP or whatever means according to configury as usual). </P>
<PRE CLASS="CodeExample"><A NAME="pgfId=2636369"> </A>
Redboot&gt; fconfig 
Network debug at boot time: false 
Use BOOTP for network configuration: false 
Local IP address: 192.168.1.25 
Default server IP address: 192.168.1.101 
GDB connection port: 1000 
Run script at boot: false 
Redboot&gt; </PRE>
<H4 CLASS="Heading3">
<A NAME="pgfId=2636370">
 </A>
Building RedBoot</H4>
<P CLASS="Body">
<A NAME="pgfId=2636371">
 </A>
To rebuild RedBoot from source, first cut out the attached configuration export file &quot;redboot.RAM&quot; and save it somewhere, say /tmp/redboot.RAM</P>
<PRE CLASS="CodeExample"><A NAME="pgfId=2636372"> </A>
mkdir redboot 
cd redboot 
ecosconfig new ebsa redboot 
ecosconfig import /tmp/redboot.RAM 
ecosconfig tree 
make </PRE>
<P CLASS="Body">
<A NAME="pgfId=2636373">
 </A>
To build the ROM version, in a different build/config directory, just change the startup mode (at the end of the export file) and add an enable of CYGSEM_HAL_ROM_MONITOR, or use the attached config export redboot.ROM. </P>
<P CLASS="Body">
<A NAME="pgfId=2636374">
 </A>
The resulting files will be, in each of the ROM and RAM startup build places: </P>
<PRE CLASS="CodeExample"><A NAME="pgfId=2636375"> </A>
70456 ..../install/bin/redboot.bin 
433104 ..../install/bin/redboot.elf 
91407 ..../install/bin/redboot.img 
194732 ..../install/bin/redboot.srec </PRE>
<P CLASS="Body">
<A NAME="pgfId=2636376">
 </A>
The .elf and .srec files have the obvious relationship to those supplied in the &quot;loaders/arm-ebsa285&quot; directory in the install. </P>
<P CLASS="Body">
<A NAME="pgfId=2636377">
 </A>
Here are the redboot.RAM and .ROM configuration exports:</P>
<PRE CLASS="CodeExample"><A NAME="pgfId=2636378"> </A>
=================== redboot.RAM ========================= 
cdl_savefile_version 1; 
cdl_savefile_command cdl_savefile_version {}; 
cdl_savefile_command cdl_savefile_command {}; 
cdl_savefile_command cdl_configuration { description hardware template package }; 
cdl_savefile_command cdl_package { value_source user_value wizard_value inferred_value }; 
cdl_savefile_command cdl_component { value_source user_value wizard_value inferred_value }; 
cdl_savefile_command cdl_option { value_source user_value wizard_value inferred_value }; 
cdl_savefile_command cdl_interface { value_source user_value wizard_value inferred_value }; 

cdl_configuration eCos { 
description &quot;&quot; ; 
hardware ebsa285 ; 
template redboot ; 
package -hardware CYGPKG_HAL_ARM current ; 
package -hardware CYGPKG_HAL_ARM_EBSA285 current ; 
package -hardware CYGPKG_IO_PCI current ; 
package -hardware CYGPKG_DEVS_ETH_ARM_EBSA285 current ; 
package -hardware CYGPKG_IO_SERIAL_ARM_EBSA285 current ; 
package -hardware CYGPKG_DEVICES_WATCHDOG_ARM_EBSA285 current ; 
package -template CYGPKG_HAL current ; 
package -template CYGPKG_INFRA current ; 
package -template CYGPKG_REDBOOT current ; 
package CYGPKG_IO_FLASH current ; 
package CYGPKG_IO_ETH_DRIVERS current ; 
package CYGPKG_DEVS_FLASH_EBSA285 current ; 
}; 
cdl_option CYGBLD_BUILD_GDB_STUBS { 
	user_value 0 }; 
cdl_option CYGDBG_DEVS_ETH_ARM_EBSA285_CHATTER { 
	user_value 0 }; 
cdl_option CYGNUM_DEVS_ETH_ARM_EBSA285_DEV_COUNT { 
	user_value 1 }; 
cdl_option CYGDBG_HAL_DEBUG_GDB_INCLUDE_STUBS { 
	inferred_value 1 }; 
cdl_option CYGDBG_HAL_DEBUG_GDB_CTRLC_SUPPORT { 
	inferred_value 0 }; 
cdl_option CYGSEM_HAL_VIRTUAL_VECTOR_DIAG { 
	user_value 1 }; 
cdl_option CYGSEM_HAL_USE_ROM_MONITOR { 
	inferred_value 0 0 }; 
cdl_option CYGBLD_BUILD_REDBOOT { 
	user_value 1 }; 
cdl_component CYG_HAL_STARTUP { 
	user_value RAM }; 
================== redboot.RAM ==================================== 
================== redboot.ROM ==================================== 
cdl_savefile_version 1; 
cdl_savefile_command 
cdl_savefile_version {}; 
cdl_savefile_command 
cdl_savefile_command {}; 
cdl_savefile_command 
cdl_configuration { description hardware template package }; 
cdl_savefile_command cdl_package { value_source user_value wizard_value inferred_value }; 
cdl_savefile_command cdl_component { value_source user_value wizard_value inferred_value }; 
cdl_savefile_command cdl_option { value_source user_value wizard_value inferred_value }; 
cdl_savefile_command cdl_interface { value_source user_value wizard_value inferred_value }; 

cdl_configuration eCos { 
	description &quot;&quot; ; 
	hardware ebsa285 ; 
	template redboot ; 
	package -hardware CYGPKG_HAL_ARM current ; 
	package -hardware CYGPKG_HAL_ARM_EBSA285 current ; 
	package -hardware CYGPKG_IO_PCI current ; 
	package -hardware CYGPKG_DEVS_ETH_ARM_EBSA285 current ; 
	package -hardware CYGPKG_IO_SERIAL_ARM_EBSA285 current ; 
	package -hardware CYGPKG_DEVICES_WATCHDOG_ARM_EBSA285 current ; 
	package -template CYGPKG_HAL current ; package -template CYGPKG_INFRA current ; 
	package -template CYGPKG_REDBOOT current ; 
	package CYGPKG_IO_FLASH current ; 
	package CYGPKG_IO_ETH_DRIVERS current ; 
	package CYGPKG_DEVS_FLASH_EBSA285 current ; 
}; 
cdl_option CYGBLD_BUILD_GDB_STUBS { 
	user_value 0 }; 
cdl_option CYGDBG_DEVS_ETH_ARM_EBSA285_CHATTER { 
	user_value 0 }; 
cdl_option CYGNUM_DEVS_ETH_ARM_EBSA285_DEV_COUNT { 
	user_value 1 }; 
cdl_option CYGDBG_HAL_DEBUG_GDB_INCLUDE_STUBS { 
	inferred_value 1 }; 
cdl_option CYGDBG_HAL_DEBUG_GDB_CTRLC_SUPPORT { 
	inferred_value 0 }; 
cdl_option CYGSEM_HAL_VIRTUAL_VECTOR_DIAG { 
	user_value 1 }; 
cdl_option CYGSEM_HAL_USE_ROM_MONITOR { 
	inferred_value 0 0 }; 
cdl_option CYGBLD_BUILD_REDBOOT { 
	user_value 1 }; 
cdl_component CYG_HAL_STARTUP { 
	user_value ROM }; 
cdl_option CYGSEM_HAL_ROM_MONITOR { 
	user_value 1 }; 
================= redboot.ROM ===================================== </PRE>
<H3 CLASS="Heading2">
<A NAME="pgfId=2636521">
 </A>
Installation on the the Cirrus Logic ARM-based EDB7xxx evaluation boards.</H3>
<P CLASS="Body">
<A NAME="pgfId=2635570">
 </A>
Copy the two '.srec' files to /tftpboot or where-ever they have to be for your tftp server.</P>
<P CLASS="Body">
<A NAME="pgfId=2635573">
 </A>
Briefly, we use whatever boot flash image you have in place already (CygMon or an eCos stub ROM) along with GDB, to execute a RAM based version of RedBoot.  That is used, in its command-line mode, to fetch a ROM-based boot image of RedBoot and write it into the flash memory.  &quot;Fetching&quot; the image means tftp from a server; the image must be in S-Record format.  We then reset the target, thus running the newly-installed boot image of RedBoot.</P>
<P CLASS="Body">
<A NAME="pgfId=2635579">
 </A>
That in turn is used, in its command-line mode, to fetch a RAM-based boot</P>
<P CLASS="Body">
<A NAME="pgfId=2635580">
 </A>
image of RedBoot and write it into a different area of the flash memory, in order to make it easier to do the first part (running a RAM-based RedBoot in order to update the boot block) again in future.</P>
<P CLASS="Body">
<A NAME="pgfId=2636595">
 </A>
1. Program RedBoot image into FLASH:</P>
<P CLASS="Body">
<A NAME="pgfId=2636596">
 </A>
 Using the 'dl_edb7xxx' tool (or it's Windows equivalent), program the file 'edb7212_redboot_ROM.bin' into the flash.</P>
<P CLASS="Body">
<A NAME="pgfId=2635589">
 </A>
2. Execute RedBoot from ROM, and initialize the flash filing system.</P>
<P CLASS="Body">
<A NAME="pgfId=2635590">
 </A>
 Notes: the key here is the &quot;-o&quot; option which keeps minicom from sending junk.</P>
<PRE CLASS="CodeExample"><A NAME="pgfId=2635593"> </A>
% minicom -o ttyS0

RedBoot(tm) debug environment - built 08:36:10, Aug 15 2000
Copyright (C) 2000, Red Hat, Inc.

RAM: 0x00000000-0x00fd7000
FLASH: 0xe0000000 - 0xe1000000, 128 blocks of 0x00020000 bytes ea.
IP: 192.168.1.23, Default server: 192.168.1.101
show tcp = 0x0001ed58
RedBoot&gt; 

RedBoot&gt; fi in
About to initialize [format] FLASH image system - are you sure (y/n)? y
*** Initialize FLASH Image System
    Warning: device contents not erased, some blocks may not be usable
... Erase from 0xe0fe0000-0xe1000000: .
... Program from 0x00fa7000-0x00fa7400 at 0xe0fe0000: .</PRE>
<P CLASS="Body">
<A NAME="pgfId=2636607">
 </A>
3. Install RAM based RedBoot for backup/update: Similar considerations apply: redboot-ram.srec must be an S-record version of RedBoot built for RAM startup.</P>
<PRE CLASS="CodeExample"><A NAME="pgfId=2635615"> </A>
RedBoot&gt; lo -v edb7212_redboot.srec
Entry point: 0x00010044, address range: 0x00010000-0x0001ee88</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=2635617"> </A>
RedBoot&gt; fi cr RedBoot[backup] -f 0xe0020000 -b 0x10000 -l 0x20000</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=2635618"> </A>
An image named 'RedBoot[backup]' exists - are you sure (y/n)? y</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=2635619"> </A>
... Erase from 0xe0020000-0xe0040000: .</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=2635620"> </A>
... Program from 0x00010000-0x00030000 at 0xe0020000: .</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=2635621"> </A>
... Erase from 0xe0fe0000-0xe1000000: .</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=2635622"> </A>
... Program from 0x00fa7000-0x00fc7000 at 0xe0fe0000: .</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=2635623"> </A>
RedBoot&gt; fi li</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=2635624"> </A>
Name              FLASH addr   Mem addr    Length    Entry point</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=2635625"> </A>
RedBoot           0xE0000000   0xE0000000  0x020000  0xE0000044</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=2635626"> </A>
RedBoot[backup]   0xE0020000   0xE0020000  0x020000  0x00010044</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=2635627"> </A>
RedBoot config    0xE0FC0000   0xE0FC0000  0x020000  0x00000000</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=2635628"> </A>
FIS directory     0xE0FE0000   0xE0FE0000  0x020000  0x00000000</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=2635629"> </A>
RedBoot&gt; </PRE>
<P CLASS="Body">
<A NAME="pgfId=2635631">
 </A>
You have now updated your board completely.  </P>
<P CLASS="Body">
<A NAME="pgfId=2635635">
 </A>
4. To update RedBoot with a new version of RedBoot, it is necessary to run a RAM-based version of RedBoot which itself re-writes the ROM-based one, because you can't re-write the code that is executing at the time.</P>
<PRE CLASS="CodeExample"><A NAME="pgfId=2635639"> </A>
RedBoot&gt; fi lo RedBoot[backup]
RedBoot&gt; g
+
RedBoot(tm) debug environment - built 07:45:57, Aug  7 2000
Copyright (C) 2000, Red Hat, Inc.

RAM: 0x00000000-0x00fd7000
FLASH: 0xe0000000 - 0xe1000000, 128 blocks of 0x00020000 bytes ea.
IP: 192.168.1.25, Default server: 192.168.1.101
show tcp = 0x00030d48
RedBoot&gt; </PRE>
<P CLASS="Body">
<A NAME="pgfId=2635651">
 </A>
.. continue with step 3, using whatever your new boot image is called in the tftp-place, in .srec format.</P>
<P CLASS="Body">
<A NAME="pgfId=2635655">
 </A>
You probably also want to set up then environment with your own IP addresses and so on.  Recall that this IP address is the one you use for GDB to talk to the board, not the IP address which the eCos application will take on (by bootp/dhcp or whatever means according to configury as usual).</P>
<PRE CLASS="CodeExample"><A NAME="pgfId=2636665"> </A>
RedBoot&gt; fconfig
Network debug at boot time: false 
Use BOOTP for network configuration: false 
Local IP address: 192.168.1.25 
Default server IP address: 192.168.1.101 
Network hardware address [MAC]: 0x08:0x88:0x12:0x34:0x56:0x79 
GDB connection port: 1000 
Run script at boot: false 
RedBoot&gt; </PRE>
<H4 CLASS="Heading3">
<A NAME="pgfId=2635672">
 </A>
Building RedBoot</H4>
<P CLASS="Body">
<A NAME="pgfId=2636670">
 </A>
To rebuild RedBoot from source, first cut out the attached configuration export file &quot;redboot.RAM&quot; and save it somewhere, say /tmp/redboot.RAM</P>
<PRE CLASS="CodeExample"><A NAME="pgfId=2636671"> </A>
mkdir redboot
cd redboot
ecosconfig new edb7212 redboot
ecosconfig import /tmp/redboot.RAM
ecosconfig tree
make</PRE>
<P CLASS="Body">
<A NAME="pgfId=2635685">
 </A>
To build the ROM version, in a different build/config directory, just change the startup mode (at the end of the export file).</P>
<P CLASS="Body">
<A NAME="pgfId=2635688">
 </A>
Here is the redboot.RAM configuration export:</P>
<PRE CLASS="CodeExample"><A NAME="pgfId=2635690"> </A>
===================== redboot.RAM =================================
cdl_savefile_version 1;
cdl_savefile_command cdl_savefile_version {};
cdl_savefile_command cdl_savefile_command {};
cdl_savefile_command cdl_configuration { description hardware template package };
cdl_savefile_command cdl_package { value_source user_value wizard_value inferred_value };
cdl_savefile_command cdl_component { value_source user_value wizard_value inferred_value };
cdl_savefile_command cdl_option { value_source user_value wizard_value inferred_value };
cdl_savefile_command cdl_interface { value_source user_value wizard_value inferred_value };

cdl_configuration eCos {
    description &quot;&quot; ;
    hardware    edb7212 ;
    template    redboot ;
    package -hardware CYGPKG_HAL_ARM current ;
    package -hardware CYGPKG_HAL_ARM_EDB7XXX current ;
    package -hardware CYGPKG_DEVS_ETH_ARM_EDB7XXX current ;
    package -hardware CYGPKG_IO_SERIAL_ARM_EDB7XXX current ;
    package -template CYGPKG_HAL current ;
    package -template CYGPKG_INFRA current ;
    package -template CYGPKG_REDBOOT current ;
    package CYGPKG_IO_ETH_DRIVERS current ;
    package CYGPKG_IO_FLASH current ;
    package CYGPKG_DEVS_FLASH_EDB7XXX current ;
};

cdl_option CYGBLD_BUILD_GDB_STUBS {
    user_value 0
};

cdl_option CYGDBG_HAL_COMMON_INTERRUPTS_SAVE_MINIMUM_CONTEXT {
    user_value 0
};

cdl_option CYGDBG_HAL_DEBUG_GDB_INCLUDE_STUBS {
    inferred_value 1
};

cdl_option CYGDBG_HAL_DEBUG_GDB_CTRLC_SUPPORT {
    inferred_value 0
};

cdl_option CYGSEM_HAL_USE_ROM_MONITOR {
    inferred_value 0 0
};

cdl_option CYGHWR_HAL_ARM_EDB7XXX_VARIANT {
    user_value EP7212
};

cdl_option CYGHWR_HAL_ARM_EDB7XXX_PROCESSOR_CLOCK {
    user_value 73728
};

cdl_option CYGBLD_BUILD_REDBOOT {
    user_value 1
};

cdl_component CYG_HAL_STARTUP {
    user_value RAM
};
===================== redboot.RAM =================================</PRE>
<P CLASS="Body">
<A NAME="pgfId=2276075">
 </A>
</P>
</DIV>
<HR ALIGN="center"><TABLE STYLE="ECOS"WIDTH="100%" BORDER="0" ALIGN="LEFT" CELLPADDING="3"><TR><TH COLSPAN="2" ALIGN="center"><P CLASS="Gotos">User Commands</P></TH></TR><TR><TD WIDTH="47%" ALIGN="center"><P CLASS="Gotos"><A HREF="redboot.html">To&nbsp;main&nbsp;page</A></P></TD><TD WIDTH="47%" ALIGN="center"><P CLASS="Gotos"><A HREF="redboot.3.html">To&nbsp;previous&nbsp;page</A></P></TD></TR></TABLE></BODY>
</HTML>
