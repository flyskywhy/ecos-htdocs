<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML EXPERIMENTAL 970324//EN">
<HTML>
<HEAD><!--version 1.3.4/Fri Apr 28 12:25:34 BST 2000-->
<META NAME="GENERATOR" CONTENT="Adobe FrameMaker 5.5/HTML Export Filter">
<LINK REL="STYLESHEET" HREF="../cygnus.css">
<TITLE> Target Setup</TITLE></HEAD>
<BODY BGCOLOR="#ffffff">
<DIV>
<TABLE STYLE="ECOS" WIDTH="98%" BORDER="0" ALIGN="LEFT" CELLPADDING="1"><TR><TH COLSPAN="3" ALIGN="center"><P CLASS="Gotos">Target Setup</P></TH></TR><TR><TD  ALIGN="center"><P CLASS="Gotos"><A HREF="ecos-tutorial.2.html">To Contents</A></P></TD><TD  ALIGN="center"><P CLASS="Gotos"><A HREF="ecos-tutorial.c.html">To&nbsp;previous&nbsp;page</A></P></TD><TD ALIGN="center"><P CLASS="Gotos"><A HREF="ecos-tutorial.e.html">To&nbsp;next&nbsp;page</A></P></TD></TR></TABLE><P ALIGN="LEFT">&nbsp;</P><BR><BR><HR ALIGN="center"></DIV>
<H2 CLASS="ChapterTitle">
<A NAME="pgfId=1740665">
 </A>
<A NAME="marker=1740664">
 </A>
<A NAME="34045">
 </A>
<A NAME="marker=2490506">
 </A>
Target Setup<DIV>
<IMG SRC="../botclear.gif">
</DIV>
</H2>
<DIV>
<H3 CLASS="Heading1">
<A NAME="pgfId=2269271">
 </A>
<A NAME="marker=2490502">
 </A>
Connecting To A Target Via Serial</H3>
<P CLASS="Body">
<A NAME="pgfId=2269272">
 </A>
While eCos supports a variety of targets, communication with the targets happens in one of four ways. These are descibed in general below.</P>
<P CLASS="Body">
<A NAME="pgfId=2290096">
 </A>
The descriptions are followed by descriptions of each target, providing specific details of how to set up the target (if hardware) and the necessary communication information (such as baud rate for hardware targets, or special connection options for simulator targets).</P>
<P CLASS="Body">
<A NAME="pgfId=2290095">
 </A>
Most targets will have eCos GDB stubs or CygMon installed. These normally wait for GDB to connect at 38400 baud, using 8 data bit, no parity bit and 1 stop-bit (no hardware flow control). Check the section for your target to ensure it uses this speed. If not, adjust the following instructions accordingly.</P>
<P CLASS="Body">
<A NAME="pgfId=2269273">
 </A>
The following instructions depend on you to select the appropriate serial port on the host - the serial port which connects to the target's (primary) serial port. On Linux this could be /dev/ttyS0, while the same port on Windows would be named COM1, or <BR>
/dev/ttya on Solaris. Substitute the proper serial port name in the below.</P>
<P CLASS="Body">
<A NAME="pgfId=2269274">
 </A>
Connect to the target by issuing the following commands in GDB console mode:</P>
<PRE CLASS="CodeExample"><A NAME="pgfId=2269275"> </A>
(gdb) set remotebaud 38400    
(gdb) target remote /dev/ttyS0</PRE>
<P CLASS="Body">
<A NAME="pgfId=2269276">
 </A>
In Insight, connect by opening the <SPAN CLASS="BOLD">
File<IMG SRC="../pix/arrow.gif">Target Settings.</SPAN>
.. window and enter:</P>
<PRE CLASS="CodeExample"><A NAME="pgfId=2269277"> </A>
Target: Remote/Serial     
Baud Rate: 38400     
Port: /dev/ttyS0</PRE>
<P CLASS="Body">
<A NAME="pgfId=2397398">
 </A>
Set other options according to preference, close the window and select <BR>
<SPAN CLASS="BOLD">
Run<IMG SRC="../pix/arrow.gif">Connect to target.</SPAN>
</P>
</DIV>
<DIV>
<H3 CLASS="Heading1">
<A NAME="pgfId=2269279">
 </A>
<A NAME="marker=2490504">
 </A>
Connecting To A Target Via Ethernet</H3>
<P CLASS="Body">
<A NAME="pgfId=2269280">
 </A>
Some targets allow GDB to connect via Ethernet - if so, it will be mentioned in the section describing the target. Substitute the target's assigned IP address or hostname for &lt;hostname&gt; in the following. The &lt;port&gt; is the TCP port which the eCos GDB stub or <SPAN CLASS="Bold">
CygWin</SPAN>
 is listening on. It is also listed in the section describing the target.</P>
<P CLASS="Body">
<A NAME="pgfId=2269281">
 </A>
Connect to the target by issuing the following command in GDB console mode:</P>
<PRE CLASS="CodeExample"><A NAME="pgfId=2269282"> </A>
(gdb) target remote &lt;hostname&gt;:&lt;port&gt;</PRE>
<P CLASS="Body">
<A NAME="pgfId=2269283">
 </A>
In Insight, connect by opening the <SPAN CLASS="BOLD">
File<IMG SRC="../pix/arrow.gif">Target Settings.</SPAN>
.. window and enter:</P>
<PRE CLASS="CodeExample"><A NAME="pgfId=2269284"> </A>
Target: Remote/TCP     
Hostname: &lt;hostname&gt;     
Port: &lt;port&gt;</PRE>
<P CLASS="Body">
<A NAME="pgfId=2460009">
 </A>
Set other options according to preference, close the window and select <BR>
<SPAN CLASS="BOLD">
Run<IMG SRC="../pix/arrow.gif">Connect to target.</SPAN>
</P>
</DIV>
<DIV>
<H3 CLASS="Heading1">
<A NAME="pgfId=2336728">
 </A>
<A NAME="marker=2490505">
 </A>
Connecting To A Simulator Target</H3>
<P CLASS="Body">
<A NAME="pgfId=2336729">
 </A>
GDB connects to all simulator targets using the same basic command, although each simulator may require additional options. These are listed in the section describing the target, and should be used when connecting.</P>
<P CLASS="Body">
<A NAME="pgfId=2336730">
 </A>
Connect to the target by issuing the following command in GDB console mode:</P>
<PRE CLASS="CodeExample"><A NAME="pgfId=2336731"> </A>
(gdb) target sim [target specific options]</PRE>
<P CLASS="Body">
<A NAME="pgfId=2336732">
 </A>
In Insight, connect by opening the <SPAN CLASS="BOLD">
File<IMG SRC="../pix/arrow.gif">Target Settings.</SPAN>
.. window and enter:</P>
<PRE CLASS="CodeExample"><A NAME="pgfId=2336733"> </A>
Target: Simulator     
Options: [target specific options]</PRE>
<P CLASS="Body">
<A NAME="pgfId=2336734">
 </A>
Set other options according to preference, close the window and select <BR>
<SPAN CLASS="BOLD">
Run<IMG SRC="../pix/arrow.gif">Connect to target.</SPAN>
</P>
</DIV>
<DIV>
<H3 CLASS="Heading1">
<A NAME="pgfId=2269293">
 </A>
Connecting To A Synthetic Target</H3>
<P CLASS="Body">
<A NAME="pgfId=2269294">
 </A>
Synthetic targets are special in that the built tests and applications actually run as native applications on the host. This means that there is no target to connect to - the test or application can be run directly from the GDB console using:</P>
<PRE CLASS="CodeExample"><A NAME="pgfId=2269295"> </A>
(gdb) run</PRE>
<P CLASS="Body">
<A NAME="pgfId=2269296">
 </A>
or from Insight by pressing the <SPAN CLASS="Bold">
Run</SPAN>
 icon. There is therefore no need to connect to the target or download the application, so you should ignore GDB &quot;target&quot; and &quot;load&quot; commands in any instructions found in other places in the documentation.</P>
</DIV>
<DIV>
<H3 CLASS="Heading1">
<A NAME="pgfId=2561893">
 </A>
<A NAME="marker=2561891">
 </A>
<A NAME="42063">
 </A>
ARM PID Hardware Setup</H3>
<P CLASS="Body">
<A NAME="pgfId=2561894">
 </A>
eCos comes with two ROM images that provide GDB support for the ARM PID board. The first ROM image provides a port of the CygMon ROM monitor, which includes a command-line interface and a GDB remote stub. The second ROM image provides a remote GDB stub only, which is a minimal environment for downloading and debugging eCos programs solely using GDB.</P>
<P CLASS="Body">
<A NAME="pgfId=2561895">
 </A>
eCos, CygMon and the GDB stubs all support the PID fitted with both ARM7T and ARM9 daughterboards. CygMon and the stubs can be programmed into either the programmable ROM (U12) or the FLASH (U13). Prebuilt forms of both ROM images are provided in the directory loaders/arm-pid under the root of your eCos installation, along with a tool that will program the stubs into the FLASH memory on the board. CygMon images are prefixed with the name 'cygmon' and GDB stub ROM images are given the prefix 'gdb_module'. Images may be provided in a number of formats including ELF (.img extension), binary (.bin extension) and SREC (.srec extension). Note that some unreliability has been experienced in downloading files using Angel 1.00. Angel 1.02 appears to be more robust in this application.</P>
<H3 CLASS="Heading2">
<A NAME="pgfId=2561896">
 </A>
Installing the Stubs into FLASH</H3>
<H4 CLASS="Heading3">
<A NAME="pgfId=2561897">
 </A>
Preparing the Binaries</H4>
<P CLASS="Body">
<A NAME="pgfId=2561898">
 </A>
These two binary preparation steps are not strictly necessary as the eCos distribution ships with precompiled binaries in the directory loaders/arm-pid relative to the installation root.</P>
<H4 CLASS="Heading3">
<A NAME="pgfId=2561899">
 </A>
Building the ROM images with the eCos Configuration Tool</H4>
<OL>
<P><LI>
<A NAME="pgfId=2561900">
 </A>
Start with a new document - selecting the <SPAN CLASS="Bold">
File</SPAN>
<IMG SRC="../pix/arrow.gif"><SPAN CLASS="Bold">
New</SPAN>
 menu item if necessary to do this.</LI>
<P><LI>
<A NAME="pgfId=2561901">
 </A>
Choose the <SPAN CLASS="Bold">
Build</SPAN>
<IMG SRC="../pix/arrow.gif"><SPAN CLASS="Bold">
Templates</SPAN>
 menu item, and then select the ARM PID hardware.</LI>
<P><LI>
<A NAME="pgfId=2561902">
 </A>
While still displaying the <SPAN CLASS="Bold">
Build</SPAN>
<IMG SRC="../pix/arrow.gif"><SPAN CLASS="Bold">
Templates</SPAN>
 dialog box, select either the &quot;stubs&quot; package template to build a GDB stub image, or the &quot;cygmon&quot; template to build the CygMon ROM Monitor. Click <SPAN CLASS="BOLD">
OK.</SPAN>
</LI>
<P><LI>
<A NAME="pgfId=2561903">
 </A>
Build eCos using <SPAN CLASS="Bold">
Build</SPAN>
<IMG SRC="../pix/arrow.gif"><SPAN CLASS="Bold">
Library</SPAN>
</LI>
<P><LI>
<A NAME="pgfId=2561904">
 </A>
When the build completes, the image files can be found in the bin/ subdirectory of the install tree. GDB stub ROM images have the prefix &quot;gdb_module&quot;. CygMon images have the prefix &quot;cygmon&quot;.</LI>
</OL>
<H4 CLASS="Heading3">
<A NAME="pgfId=2561905">
 </A>
Building the ROM images with ecosconfig</H4>
<P CLASS="Body">
<A NAME="pgfId=2561909">
 </A>
(See <A HREF="ecos-tutorial.11.html#26598" CLASS="XRef">
 Using ecosconfig on UNIX</A>
)</P>
<OL>
<P><LI>
<A NAME="pgfId=2561910">
 </A>
Make an empty directory to contain the build tree, and cd into it.</LI>
<P><LI>
<A NAME="pgfId=2561911">
 </A>
To build a GDB stub ROM image, enter the command:<BR>
   <TT CLASS="Code">
$ ecosconfig new pid stubs<BR>
</TT>
or to build a CygMon ROM monitor image, enter the command:<BR>
   <TT CLASS="Code">
$ ecosconfig new pid cygmon</TT>
</LI>
<P><LI>
<A NAME="pgfId=2561912">
 </A>
Enter the commands:<BR>
 <TT CLASS="Code">
$ ecosconfig tree<BR>
 $ make</TT>
</LI>
<P><LI>
<A NAME="pgfId=2561913">
 </A>
When the build completes, the image files can be found in the bin/ subdirectory of the install tree. GDB stub ROM images have the prefix &quot;gdb_module&quot;. CygMon images have the prefix &quot;cygmon&quot;.</LI>
</OL>
<H4 CLASS="Heading3">
<A NAME="pgfId=2561914">
 </A>
Building the FLASH Tool with the eCos Configuration Tool</H4>
<OL>
<P><LI>
<A NAME="pgfId=2561915">
 </A>
Start with a new document - selecting the <SPAN CLASS="Bold">
File</SPAN>
<IMG SRC="../pix/arrow.gif"><SPAN CLASS="Bold">
New</SPAN>
 menu item if necessary to do this.</LI>
<P><LI>
<A NAME="pgfId=2561916">
 </A>
Choose the <SPAN CLASS="Bold">
Build</SPAN>
<IMG SRC="../pix/arrow.gif"><SPAN CLASS="Bold">
Templates</SPAN>
 menu item, and then select the ARM PID hardware.</LI>
<P><LI>
<A NAME="pgfId=2561917">
 </A>
Enable the &quot;Build flash programming tool&quot; option in the ARM PID HAL (CYGBLD_BUILD_FLASH_TOOL) and resolve any resulting configuration conflicts.</LI>
<P><LI>
<A NAME="pgfId=2561918">
 </A>
Build eCos using <SPAN CLASS="Bold">
Build</SPAN>
<IMG SRC="../pix/arrow.gif"><SPAN CLASS="Bold">
Library</SPAN>
</LI>
<P><LI>
<A NAME="pgfId=2561919">
 </A>
When the build completes, the FLASH tool image file can be found in the bin/ subdirectory of the install tree, with the prefix &quot;prog_flash&quot;</LI>
</OL>
<H4 CLASS="Heading3">
<A NAME="pgfId=2561920">
 </A>
Building the FLASH Tool with ecosconfig</H4>
<P CLASS="Body">
<A NAME="pgfId=2561924">
 </A>
(See <A HREF="ecos-tutorial.11.html#26598" CLASS="XRef">
 Using ecosconfig on UNIX</A>
)</P>
<OL>
<P><LI>
<A NAME="pgfId=2561925">
 </A>
Make an empty directory to contain the build tree, and cd into it</LI>
<P><LI>
<A NAME="pgfId=2561926">
 </A>
Enter the command:<BR>
 <TT CLASS="Code">
$ ecosconfig new pid</TT>
</LI>
<P><LI>
<A NAME="pgfId=2561927">
 </A>
Edit the file ecos.ecc and enable the option CYGBLD_BUILD_FLASH_TOOL by uncommenting its user_value property and setting it to 1.</LI>
<P><LI>
<A NAME="pgfId=2561928">
 </A>
Enter the commands:<BR>
 <TT CLASS="Code">
$ ecosconfig resolve<BR>
</TT>
[there will be some output]<BR>
 <TT CLASS="Code">
$ ecosconfig tree<BR>
 $ make</TT>
</LI>
<P><LI>
<A NAME="pgfId=2561929">
 </A>
When the build completes, the FLASH tool image file can be found in the bin/ subdirectory of the install tree, with the prefix &quot;prog_flash&quot;</LI>
</OL>
<H4 CLASS="Heading3">
<A NAME="pgfId=2561930">
 </A>
Prepare the Board for FLASH Programming</H4>
<P CLASS="Body">
<A NAME="pgfId=2561931">
 </A>
Each time a new image is to be programmed in the FLASH, the jumpers on the board must be set to allow Angel to run:</P>
<OL>
<P><LI>
<A NAME="pgfId=2561932">
 </A>
Set jumper 7-8 on LK6   [using the Angel code in the 16 bit EPROM]</LI>
<P><LI>
<A NAME="pgfId=2561933">
 </A>
Set jumper 5-6 on LK6   [select 8bit ROM mode]</LI>
<P><LI>
<A NAME="pgfId=2561934">
 </A>
Set jumper LK18         [ROM remap - this is also required for eCos]</LI>
<P><LI>
<A NAME="pgfId=2561935">
 </A>
Set S1 to 0-0-1-1       [20MHz operation]</LI>
<P><LI>
<A NAME="pgfId=2562097">
 </A>
Open jumper LK4  [enable little-endian operation]<BR>
<BR>
Attach a serial cable from Serial A on the PID board to connector 1 on the development system. This is the cable through which the binaries will be downloaded. Attach a serial cable from Serial B on the PID board to connector 2 on the development system (or any system that will work as a terminal). Through this cable, the FLASH tool will write its instructions (at 38400 baud).</LI>
</OL>
<H4 CLASS="Heading3">
<A NAME="pgfId=2562098">
 </A>
Program the FLASH</H4>
<OL>
<P><LI>
<A NAME="pgfId=2562104">
 </A>
Download the FLASH ROM image onto the PID board. For example. for the GDB stubs image:<BR>
<TT CLASS="Code">
<BR>
bash$ arm-elf-gdb -nw gdb_module.img<BR>
GNU gdb 4.18-DEVTOOLSVERSION<BR>
Copyright 1998 Free Software Foundation, Inc.<BR>
GDB is free software, covered by the GNU General Public License, and you are welcome to change it and/or distribute copies of it under certain conditions. Type &quot;show copying&quot; to see the conditions. There is absolutely no warranty for GDB. Type &quot;show warranty&quot; for details.<BR>
This GDB was configured as &quot;--host=i586-pc-cygwin32 --target=arm-elf&quot;.<BR>
(no debugging symbols found)...<BR>
(gdb) target rdi s=com1<BR>
Angel Debug Monitor for PID (Built with Serial(x1), Parallel, DCC) 1.00<BR>
(Advanced RISC Machines SDT 2.10)<BR>
Angel Debug Monitor rebuilt on Jan 20 1997 at 02:33:43<BR>
Connected to ARM RDI target.<BR>
(gdb) load<BR>
Loading section .rom_vectors, size 0x44 lma 0x60000<BR>
Loading section .text, size 0x1f3c lma 0x60044<BR>
Loading section .rodata, size 0x2c lma 0x61f80<BR>
Loading section .data, size 0x124 lma 0x61fac<BR>
Start address 0x60044 , load size 8400<BR>
Transfer rate: 5169 bits/sec.<BR>
(gdb) q <BR>
The program is running.  Exit anyway? (y or n) y <BR>
</TT>
<BR>
NOTE<SPAN CLASS="Bold">
:</SPAN>
 On a UNIX or Linux system, the serial port must be<BR>
 /dev/ttyS0 instead of COM1.<BR>
 You need to make sure that the /dev/ttyS0 files have the right permissions:<BR>
<BR>
 $ su<BR>
 Password:<BR>
 # chmod o+rw /dev/ttyS0*<BR>
 # exit <BR>
<BR>
If you are programming the GDB stub image, it will now be located at 0x60000..0x64000. If you are programming the Cygmon ROM Monitor, it will be located at 0x60000..0x80000.</LI>
<P><LI>
<A NAME="pgfId=2562105">
 </A>
Now download the FLASH programmer tool<BR>
<TT CLASS="Code">
<BR>
bash$ arm-elf-gdb prog_flash.img <BR>
GNU gdb 4.18-DEVTOOLSVERSION<BR>
Copyright 1998 Free Software Foundation, Inc.<BR>
GDB is free software, covered by the GNU General Public License, and you are     welcome to change it and/or distribute copies of it under certain conditions. Type &quot;show copying&quot; to see the conditions. There is absolutely no warranty for GDB.  Type &quot;show warranty&quot; for details.<BR>
This GDB was configured as &quot;--host=i586-pc-cygwin32 --target=arm-elf&quot;.<BR>
(gdb) target rdi s=com1<BR>
Angel Debug Monitor for PID (Built with Serial(x1), Parallel, DCC) 1.00<BR>
(Advanced RISC Machines SDT 2.10)<BR>
Angel Debug Monitor rebuilt on Jan 20 1997 at 02:33:43<BR>
Connected to ARM RDI target.<BR>
(gdb) load<BR>
Loading section .rom_vectors, size 0x44 lma 0x40000<BR>
Loading section .text, size 0x44a4 lma 0x40044<BR>
Loading section .rodata, size 0x318 lma 0x444e8<BR>
Loading section .data, size 0x1c8 lma 0x44800<BR>
Start address 0x40044 , load size 18888<BR>
Transfer rate: 5596 bits/sec.<BR>
(gdb) c</TT>
</LI>
<P><LI>
<A NAME="pgfId=2562111">
 </A>
The FLASH tool will output some text on the board serial port B at 38400 baud:<BR>
<TT CLASS="Code">
<BR>
ARM </TT>
eCos<BR>
<TT CLASS="Code">
FLASH here!<BR>
manuf: 8, device: 40<BR>
Error: Wrong Manufaturer: 08<BR>
... Please change FLASH jumper</TT>
</LI>
<P><LI>
<A NAME="pgfId=2562117">
 </A>
This text is repeated until you remove the jumper 7-8 on LK6. Then the output will be:<BR>
<TT CLASS="Code">
<BR>
manuf: 1F, device: A4<BR>
AT29C040A recognised<BR>
About to program FLASH using data at 60000..64000<BR>
*** Press RESET now to abort!</TT>
</LI>
<P><LI>
<A NAME="pgfId=2562118">
 </A>
 You have about 10 seconds to abort the operation by pressing reset. After this timeout, the FLASH programming happens:<BR>
<TT CLASS="Code">
<BR>
...Programming FLASH <BR>
All done!</TT>
</LI>
<P><LI>
<A NAME="pgfId=2562119">
 </A>
Quit/kill the GDB process, which will hang.</LI>
<P><LI>
<A NAME="pgfId=2562120">
 </A>
Next time you reset the board, the stub will be in control, communicating on Serial A at 38400 baud.</LI>
</OL>
<H3 CLASS="Label">
<A NAME="pgfId=2562121">
 </A>
NOTE: </H3>
<P CLASS="Note">
<A NAME="pgfId=2562122">
 </A>
If you do not have two serial ports available on your host computer, you may still verify the flash programming completed successfully by quitting/killing the GDB process after running &quot;c&quot; in step 2 above. Then switch the serial cable on the PID from Serial A to Serial B and run a terminal emulator on the host computer. In a few seconds you should see the the repeated text described in step 2 above and you may continue the remaining steps as normal.</P>
<H4 CLASS="Heading3">
<A NAME="pgfId=2562123">
 </A>
Programming the FLASH for big-endian mode</H4>
<P CLASS="Body">
<A NAME="pgfId=2562124">
 </A>
The process is almost identical to the previous instructions which apply to a PID board running in little-endian mode only.</P>
<P CLASS="Body">
<A NAME="pgfId=2562125">
 </A>
The only adjustments to make are that if programming a <SPAN CLASS="Bold">
GDB</SPAN>
 stub ROM image (or CygMon ROM monitor image), you must enable the option &quot;Use Big-endian mode&quot; in the <SPAN CLASS="Bold">
eCos Configuration Tool</SPAN>
 (CYGHWR_HAL_ARM_BIGENDIAN if using ecosconfig and editing ecos.ecc).</P>
<P CLASS="Body">
<A NAME="pgfId=2562126">
 </A>
When programming the FLASH there are two options:</P>
<OL>
<P><LI>
<A NAME="pgfId=2562127">
 </A>
Program FLASH using the little-endian FLASH tool. After powering off, replace the ROM controller with the special big-endian version which can be acquired from ARM. (This has not been tested by Red Hat).</LI>
<P><LI>
<A NAME="pgfId=2562128">
 </A>
Use a specied big-endian version of the FLASH tool which byte-swaps all the words as they are written to the FLASH.</LI>
</OL>
<P CLASS="BodyListFollow">
<A NAME="pgfId=2562129">
 </A>
Build this tool by enabling the &quot;Build flash programming tool for BE images on LE boards&quot; option (CYGBLD_BUILD_FLASH_TOOL_BE), resulting in a utility with the prefix &quot;prog_flash_BE_image_LE_system&quot; which should be used instead of &quot;prog_flash&quot;.</P>
<P CLASS="BodyListFollow">
<A NAME="pgfId=2562130">
 </A>
Note that there is a limitation to this method: no sub-word data can be read from the ROM. To work around this, the .rodata section is folded into the .data section and thus copied to RAM before the system starts.</P>
<P CLASS="BodyListFollow">
<A NAME="pgfId=2562131">
 </A>
Given that Thumb instructions are 16 bit, it is not possible to run ROM-startup Thumb binaries on the PID board using this method.</P>
<P CLASS="Body">
<A NAME="pgfId=2562132">
 </A>
When the image has been programmed, power off the board, and set jumper LK4 to enable big-endian operation.</P>
<H3 CLASS="Heading2">
<A NAME="pgfId=2562133">
 </A>
Installing the Stubs into ROM</H3>
<OL>
<P><LI>
<A NAME="pgfId=2562139">
 </A>
Program the binary image file gdb_module.bin into ROM referring to the instructions of your ROM programmer.</LI>
<P><LI>
<A NAME="pgfId=2562145">
 </A>
Plug the ROM into socket U12 and install jumper LK6 pins 7-8 to enable the ROM.</LI>
</OL>
</DIV>
<DIV>
<H3 CLASS="Heading1">
<A NAME="pgfId=2562150">
 </A>
<A NAME="marker=2562149">
 </A>
ARM AEB-1 Hardware Setup</H3>
<H3 CLASS="Heading2">
<A NAME="pgfId=2562151">
 </A>
Overview</H3>
<P CLASS="Body">
<A NAME="pgfId=2562152">
 </A>
The ARM AEB-1 comes with tools in ROM. These include a simple FLASH management tool and the Angel&#174; monitor. eCos for the ARM AEB-1 comes with GDB stubs suitable for programming into the onboard FLASH. GDB is the preferred debug environment for GDB, and while Angel provides a subset of the features in the eCos GDB stub, Angel is unsupported.</P>
<P CLASS="Body">
<A NAME="pgfId=2562153">
 </A>
Both eCos and the stubs support both Revision B and Revision C of the AEB-1 board. Stub ROM images for both types of board can be found in the loaders/arm-aeb directory under the root of your eCos installation. You can select which board you are using by selecting either the aeb or aebC platform by selecting the appropriate platform HAL in the <SPAN CLASS="BOLD">
eCos Configuration Tool.</SPAN>
</P>
<P CLASS="Body">
<A NAME="pgfId=2562154">
 </A>
The GDB stub can be downloaded to the board for programming in the FLASH using the board's on-board ROM monitor:</P>
<OL>
<P><LI>
<A NAME="pgfId=2562155">
 </A>
talk to the AEB-1 board with a terminal emulator (or a real terminal!)</LI>
<P><LI>
<A NAME="pgfId=2562156">
 </A>
use the board's rom menu to download a UU-encoded version of the GDB stubs which will act as a ROM monitor</LI>
<P><LI>
<A NAME="pgfId=2562157">
 </A>
tell the board to use this new monitor, and then hook GDB up to it for real debugging</LI>
</OL>
<H3 CLASS="Heading2">
<A NAME="pgfId=2562158">
 </A>
Talking to the Board</H3>
<P CLASS="Body">
<A NAME="pgfId=2562159">
 </A>
Connect a terminal or computer's serial port to the ARM AEB-1. On a PC with a 9-pin serial port, you can use the cable shipped by ARM with no modification. </P>
<P CLASS="Body">
<A NAME="pgfId=2562160">
 </A>
Set the terminal or terminal emulator to 9600N1 (9600 baud, no parity, 1 stop bit). </P>
<P CLASS="Body">
<A NAME="pgfId=2562161">
 </A>
Reset the board by pressing the little reset button on the top. You will see the following text: </P>
<PRE CLASS="CodeExample"><A NAME="pgfId=2562162"> </A>
	ARM Evaluation Board Boot Monitor 0.01 (19 APR 1998)
	Press ENTER within 2 seconds to stop autoboot</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=2562163"> </A>
</PRE>
<P CLASS="Body">
<A NAME="pgfId=2562164">
 </A>
Press ENTER quickly, and you will get the boot prompt: </P>
<PRE CLASS="CodeExample"><A NAME="pgfId=2562165"> </A>
	Boot:</PRE>
<H3 CLASS="Heading2">
<A NAME="pgfId=2562166">
 </A>
Downloading the Stubs via the Rom Menu</H3>
<P CLASS="Body">
<A NAME="pgfId=2562167">
 </A>
Using the AEB-1 rom menu to download the GDB stubs from the provided &quot;.UU&quot; file.</P>
<H3 CLASS="Label">
<A NAME="pgfId=2562168">
 </A>
NOTE</H3>
<P CLASS="Note">
<A NAME="pgfId=2562169">
 </A>
This is an annotated 'terminal' session with the AEB-1 monitor:</P>
<PRE CLASS="CodeExample"><A NAME="pgfId=2562170"> </A>
+Boot: help
Module is BootStrap       1.00 (14 Aug 1998)</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=2562171"> </A>
Help is available on:</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=2562172"> </A>
Help          Modules       ROMModules    UnPlug        PlugIn
Kill          SetEnv        UnSetEnv      PrintEnv      DownLoad
Go            GoS           Boot          PC            FlashWrite
FlashLoad     FlashErase</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=2562173"> </A>
Boot: download c000
Ready to download. Use 'transmit' option on terminal emulator to download file.</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=2562174"> </A>
... at this point, download the ASCII file &quot;loaders/arm-aeb/
    gdb_module.img.UU&quot;. The details of this operation differ
    depending on which terminal emulator is used. It may be
    necessary to enter &quot;^D&quot; (control+D) when the download completes
   to get the monitor to return to command mode. </PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=2562175"> </A>
Loaded file gdb_module.img.bin at address 0000c000, size = 19392 </PRE>
<H3 CLASS="Heading2">
<A NAME="pgfId=2562176">
 </A>
Activating the GDB Stubs</H3>
<P CLASS="Body">
<A NAME="pgfId=2562177">
 </A>
Commit the GDB stubs module to flash: </P>
<PRE CLASS="CodeExample"><A NAME="pgfId=2562178"> </A>
	Boot: flashwrite 4018000 C000 8000
    </PRE>
<P CLASS="Body">
<A NAME="pgfId=2562179">
 </A>
Verify that the eCos/&quot;GDB stubs&quot; module is now added in the list of modules in the board: </P>
<PRE CLASS="CodeExample"><A NAME="pgfId=2562180"> </A>
	Boot: rommodules
    </PRE>
<P CLASS="Body">
<A NAME="pgfId=2562181">
 </A>
You should see output similar to the following: </P>
<PRE CLASS="CodeExample"><A NAME="pgfId=2562182"> </A>
	Header   Base     Limit
	04000004 04000000 040034a8 BootStrap       1.00 (14 Aug 1998) 
	04003a74 04003800 04003bc0 Production Test 1.00 (13 Aug 1998) 
	0400e4f4 04004000 0400e60f Angel           1.02 (12 MAY 1998) 
	0401c810 04018000 0401cbc0 eCos              1.3  (27 Jan 2000) GDB stubs
    </PRE>
<P CLASS="Body">
<A NAME="pgfId=2562183">
 </A>
Now make the eCos/&quot;GDB stubs&quot; module be the default monitor: </P>
<PRE CLASS="CodeExample"><A NAME="pgfId=2562184"> </A>
	Boot: plugin eCos
    </PRE>
<H3 CLASS="Label">
<A NAME="pgfId=2562185">
 </A>
NOTE</H3>
<P CLASS="Note">
<A NAME="pgfId=2562186">
 </A>
Since the GDB stubs are always linked at the same address (0x4018000), the operation of writing to the flash and selecting the stubs as default monitor is an idempotent operation. You can download a new set of stubs following the same procedure - you do not have to unregister or delete anything.</P>
<H3 CLASS="Heading2">
<A NAME="pgfId=2562193">
 </A>
Building the GDB Stub FLASH ROM Images</H3>
<P CLASS="Body">
<A NAME="pgfId=2562194">
 </A>
Prebuilt GDB stubs images are provided in the directory loaders/arm-aeb relative to the root of your eCos installation, but here are instructions on how to rebuild them if you should ever need to.</P>
<H3 CLASS="Heading2">
<A NAME="pgfId=2562195">
 </A>
Building the GDB Stubs with the eCos Configuration Tool</H3>
<OL>
<P><LI>
<A NAME="pgfId=2562196">
 </A>
Start with a new document - selecting the <SPAN CLASS="Bold">
File</SPAN>
<IMG SRC="../pix/arrow.gif"><SPAN CLASS="Bold">
New</SPAN>
 menu item if necessary to do this.</LI>
<P><LI>
<A NAME="pgfId=2562197">
 </A>
Choose the <SPAN CLASS="Bold">
Build</SPAN>
<IMG SRC="../pix/arrow.gif"><SPAN CLASS="Bold">
Templates</SPAN>
 menu item, and then select the ARM AEB-1 hardware.</LI>
<P><LI>
<A NAME="pgfId=2562198">
 </A>
While still displaying the <SPAN CLASS="Bold">
Build<IMG SRC="../pix/arrow.gif">Templates</SPAN>
 dialog box, select the &quot;stubs&quot; package template to build a GDB stub image. Click <SPAN CLASS="BOLD">
OK.</SPAN>
</LI>
<P><LI>
<A NAME="pgfId=2562199">
 </A>
If applicable, set the &quot;AEB board revision&quot; option to &quot;C&quot; from &quot;B&quot; depending on the board revision being used.</LI>
<P><LI>
<A NAME="pgfId=2562200">
 </A>
Build eCos using <SPAN CLASS="Bold">
Build</SPAN>
<IMG SRC="../pix/arrow.gif"><SPAN CLASS="Bold">
Library.</SPAN>
</LI>
<P><LI>
<A NAME="pgfId=2562201">
 </A>
When the build completes, the image files can be found in the bin/ subdirectory of the install tree. The GDB stub ROM images have the prefix &quot;gdb_module&quot;.</LI>
</OL>
<H3 CLASS="Heading2">
<A NAME="pgfId=2562202">
 </A>
Building the GDB Stub ROMs with ecosconfig</H3>
<P CLASS="Body">
<A NAME="pgfId=2562206">
 </A>
(See <A HREF="ecos-tutorial.11.html#26598" CLASS="XRef">
 Using ecosconfig on UNIX</A>
)</P>
<OL>
<P><LI>
<A NAME="pgfId=2562207">
 </A>
Make an empty directory to contain the build tree, and cd into it.</LI>
<P><LI>
<A NAME="pgfId=2562208">
 </A>
To build a GDB stub ROM image, enter the command:<BR>
 <TT CLASS="Code">
$ ecosconfig new aeb stubs</TT>
</LI>
<P><LI>
<A NAME="pgfId=2562209">
 </A>
If applicable, edit ecos.ecc and set the AEB board revision. (CYGHWR_HAL_ARM_AEB_REVISION) from the default &quot;B&quot; to &quot;C&quot; by uncommenting the user_value property and setting it to &quot;C&quot;.</LI>
<P><LI>
<A NAME="pgfId=2562210">
 </A>
Enter the commands<BR>
 <TT CLASS="Code">
$ ecosconfig tree<BR>
 $ make</TT>
</LI>
<P><LI>
<A NAME="pgfId=2562211">
 </A>
When the build completes, the image files can be found in the bin/ subdirectory of the install tree. The GDB stub ROM images have the prefix &quot;gdb_module&quot;.</LI>
</OL>
</DIV>
<DIV>
<H3 CLASS="Heading1">
<A NAME="pgfId=2562213">
 </A>
<A NAME="marker=2562212">
 </A>
ARM Cogent CMA230 Hardware Setup</H3>
<P CLASS="Body">
<A NAME="pgfId=2562214">
 </A>
The eCos Developer's Kit package comes with an EPROM which provides GDB support for the Cogent evaluation board. An image of this EPROM is also provided at loaders/arm-cma230/gdbload.bin under the root of your eCos installation. </P>
<P CLASS="Body">
<A NAME="pgfId=2562215">
 </A>
The EPROM is installed to socket U3 on the board. Attention should be paid to the correct orientation of the EPROM during installation.</P>
<P CLASS="Body">
<A NAME="pgfId=2562216">
 </A>
If you are going to burn a new EPROM using the binary image, be careful to get the byte order correct. It needs to be little-endian, which is usually the default in PC based programmer software.</P>
<P CLASS="Body">
<A NAME="pgfId=2562217">
 </A>
If the GDB stub EPROM you burn does not work, try reversing the byte-order, even if you think you have it the right way around. At least one DOS-based EPROM burner program is known to have the byte-order upside down.</P>
<P CLASS="Body">
<A NAME="pgfId=2562218">
 </A>
The GDB stub in the EPROM allows communication with GDB using the serial port at connector P12 (CMA101) or P3 (CMA102). The communication parameters are fixed at 38400 baud, 8 data bits, no parity bit and 1 stop bit (8-N-1).  No flow control is employed. Connection to the host computer should be made using a dedicated serial cable as specified in the Cogent CMA manual.</P>
<H4 CLASS="Heading3">
<A NAME="pgfId=2562219">
 </A>
Building the GDB Stub FLASH ROM images</H4>
<P CLASS="Body">
<A NAME="pgfId=2562220">
 </A>
Prebuilt GDB stubs images are provided in the directory loaders/arm-cma230 relative to the root of your eCos installation, but here are instructions on how to rebuild them if you should ever need to.</P>
<P CLASS="Body">
<A NAME="pgfId=2562221">
 </A>
CygMon images are prefixed with the name 'cygmon' and GDB stub ROM images</P>
<P CLASS="Body">
<A NAME="pgfId=2562222">
 </A>
are given the prefix 'gdb_module'. Images may be provided in a number of formats including ELF (.img extension), binary (.bin extension) and SREC (.srec extension). </P>
<H4 CLASS="Heading3">
<A NAME="pgfId=2562223">
 </A>
Building the GDB Stubs with the eCos Configuration Tool</H4>
<OL>
<P><LI>
<A NAME="pgfId=2562224">
 </A>
1. Start with a new document - selecting the File<IMG SRC="../pix/arrow.gif">New menu item if</LI>
</OL>
<P CLASS="Body">
<A NAME="pgfId=2562225">
 </A>
necessary to do this.</P>
<OL>
<P><LI>
<A NAME="pgfId=2562226">
 </A>
Choose the <SPAN CLASS="Bold">
Build</SPAN>
<IMG SRC="../pix/arrow.gif"><SPAN CLASS="Bold">
Templates</SPAN>
 menu item, and then select the ARM CMA230 hardware.</LI>
<P><LI>
<A NAME="pgfId=2562227">
 </A>
While still displaying the <SPAN CLASS="Bold">
Build</SPAN>
<IMG SRC="../pix/arrow.gif"><SPAN CLASS="Bold">
Templates</SPAN>
 dialog box, select the &quot;stubs&quot; package template to build a GDB stub image. Click <SPAN CLASS="BOLD">
OK.</SPAN>
</LI>
<P><LI>
<A NAME="pgfId=2562228">
 </A>
Build eCos using <SPAN CLASS="Bold">
Build</SPAN>
<IMG SRC="../pix/arrow.gif"><SPAN CLASS="Bold">
Library</SPAN>
</LI>
<P><LI>
<A NAME="pgfId=2562229">
 </A>
When the build completes, the image files can be found in the bin/ subdirectory of the install tree. The GDB stub ROM images have the prefix &quot;gdb_module&quot;.</LI>
</OL>
<H4 CLASS="Heading3">
<A NAME="pgfId=2562230">
 </A>
Building the GDB Stub ROMs with ecosconfig</H4>
<P CLASS="Body">
<A NAME="pgfId=2562234">
 </A>
(See <A HREF="ecos-tutorial.11.html#26598" CLASS="XRef">
 Using ecosconfig on UNIX</A>
)</P>
<OL>
<P><LI>
<A NAME="pgfId=2562235">
 </A>
1. Make an empty directory to contain the build tree, and cd into it.</LI>
<P><LI>
<A NAME="pgfId=2562236">
 </A>
To build a GDB stub ROM image, enter the command:<BR>
 <TT CLASS="Code">
$ ecosconfig new cma230 stubs</TT>
</LI>
<P><LI>
<A NAME="pgfId=2562237">
 </A>
Enter the commands:<BR>
 <TT CLASS="Code">
$ ecosconfig tree<BR>
 $ make</TT>
</LI>
<P><LI>
<A NAME="pgfId=2562238">
 </A>
When the build completes, the image files can be found in the bin/ subdirectory of the install tree. The GDB stub ROM images have the prefix &quot;gdb_module&quot;.</LI>
</OL>
</DIV>
<DIV>
<H3 CLASS="Heading1">
<A NAME="pgfId=2562244">
 </A>
<A NAME="marker=2562242">
 </A>
<A NAME="25420">
 </A>
Cirrus Logic ARM EP7211 Development Board Hardware Setup</H3>
<P CLASS="Body">
<A NAME="pgfId=2562245">
 </A>
eCos comes with two Flash ROM images that provide GDB support for the Cirrus Logic EP7211 Development Board (also known as the EDB7211).. Note that on some board revisions, the board is silk-screened as EDB7111-2. The first Flash ROM image provides a port of the CygMon ROM monitor, which includes a command-line interface and a GDB remote stub. The second Flash ROM image provides a remote GDB stub only.</P>
<P CLASS="Body">
<A NAME="pgfId=2562246">
 </A>
Both ROM images are provided in the directory loaders/arm-edb7211 under the root of your eCos installation. CygMon images are prefixed with the name 'edb7211_cygmon' and are provided in a number of formats including binary (.bin extension) and SREC (.srec) extension. GDB stub ROM images are given the prefix 'edb7211_gdb_module'. </P>
<P CLASS="Body">
<A NAME="pgfId=2562247">
 </A>
The ROM images provided for the EP7211 Development Board must be programmed into the flash. Please refer to the section titled &quot;Loading the ROM image into On-Board flash&quot; on how to program the ROM onto the board.</P>
<P CLASS="Body">
<A NAME="pgfId=2562248">
 </A>
Both Cygmon and GDB Stub ROMS allow communication with GDB via the serial connector labelled 'UART 1'. The communication parameters are fixed at 38400 baud, 8 data bits, no parity bit and 1 stop bit (8-N-1). No flow control is employed. Connection to the host computer should be made using a null modem cable. A gender changer may also be required. Note that the GDB Configuration tool uses the serial port identifiers 0 and 1 to identify the EB7211 serial ports UART1 and UART2 respectively.</P>
<P CLASS="Body">
<A NAME="pgfId=2562249">
 </A>
Both eCos and the ROM images assume the core clock is generated with a 3.6864 MHz PLL input. The CPU will be configured to run at 73.728MHz.</P>
<P CLASS="Body">
<A NAME="pgfId=2562250">
 </A>
Note: The EP7211 CPU needs a two step RESET process. After pressing the `URESET' pushbutton, the `WAKEUP' pushbutton must be pressed to complete the process.</P>
<H3 CLASS="Label">
<A NAME="pgfId=2562251">
 </A>
NOTE</H3>
<P CLASS="Note">
<A NAME="pgfId=2562252">
 </A>
When an eCos program is run on an EDB7211 board fitted with either CygMon or a GDB stub ROM, then the code in ROM loses control. This means that if you require the ability to remotely stop execution on the target, or want thread debugging capabilities, you must include GDB stub support when configuring eCos.</P>
<H4 CLASS="Heading3">
<A NAME="pgfId=2562253">
 </A>
Building programs for programming into flash</H4>
<P CLASS="Body">
<A NAME="pgfId=2562254">
 </A>
If your application is to be run directly from flash, you must configure eCos appropriately for &quot;ROM&quot; startup. This can be done in the <SPAN CLASS="Bold">
eCos Configuration Tool</SPAN>
 by setting the &quot;Startup type&quot; HAL option to &quot;ROM&quot;. If using the ecosconfig utility, set the user_value of the CYG_HAL_STARTUP option in ecos.ecc to &quot;ROM&quot;.</P>
<P CLASS="Body">
<A NAME="pgfId=2562255">
 </A>
When you have linked your application with eCos, you will then have an ELF executable. To convert this into a format appropriate for the Cirrus Logic flash download utility, or the dl_7xxx utility on linux, you can use the utility arm-elf-objcopy, as in the following example:</P>
<PRE CLASS="CodeExample"><A NAME="pgfId=2562256"> </A>
   $ arm-elf-objcopy -O binary helloworld.exe helloworld.bin</PRE>
<P CLASS="Body">
<A NAME="pgfId=2562257">
 </A>
This will produce a binary format image helloworld.bin which can be downloaded into flash.</P>
<H4 CLASS="Heading3">
<A NAME="pgfId=2562258">
 </A>
Building the GDB Stub FLASH ROM images</H4>
<P CLASS="Body">
<A NAME="pgfId=2562259">
 </A>
Prebuilt GDB stubs images are provided in the directory loaders/arm-edb7211 relative to the root of your eCos installation, but here are instructions on how to rebuild them if you should ever need to.</P>
<P CLASS="Body">
<A NAME="pgfId=2562260">
 </A>
CygMon images are prefixed with the name 'cygmon' and GDB stub ROM images are given the prefix 'gdb_module'. Images may be provided in a number of formats including ELF (.img extension), binary (.bin extension) and SREC (.srec extension). </P>
<H4 CLASS="Heading3">
<A NAME="pgfId=2562261">
 </A>
Building the ROM images with the eCos Configuration Tool</H4>
<OL>
<P><LI>
<A NAME="pgfId=2562262">
 </A>
Start with a new document - selecting the <SPAN CLASS="Bold">
File</SPAN>
<IMG SRC="../pix/arrow.gif"><SPAN CLASS="Bold">
New</SPAN>
 menu item if</LI>
</OL>
<P CLASS="Body">
<A NAME="pgfId=2562263">
 </A>
necessary to do this.</P>
<OL>
<P><LI>
<A NAME="pgfId=2562264">
 </A>
Choose the <SPAN CLASS="Bold">
Build</SPAN>
<IMG SRC="../pix/arrow.gif"><SPAN CLASS="Bold">
Templates</SPAN>
 menu item, and then select the &quot;Cirrus Logic development board&quot; hardware.</LI>
<P><LI>
<A NAME="pgfId=2562265">
 </A>
While still displaying the <SPAN CLASS="Bold">
Build</SPAN>
<IMG SRC="../pix/arrow.gif"><SPAN CLASS="Bold">
Templates</SPAN>
 dialog box, select either the &quot;stubs&quot; package template to build a GDB stub image, or the &quot;cygmon&quot; template to build the CygMon ROM Monitor. Click <SPAN CLASS="BOLD">
OK.</SPAN>
</LI>
<P><LI>
<A NAME="pgfId=2562266">
 </A>
Build eCos using <SPAN CLASS="Bold">
Build</SPAN>
<IMG SRC="../pix/arrow.gif"><SPAN CLASS="Bold">
Library</SPAN>
</LI>
<P><LI>
<A NAME="pgfId=2562267">
 </A>
When the build completes, the image files can be found in the bin/ subdirectory of the install tree. GDB stub ROM images have the prefix &quot;gdb_module&quot;. CygMon images have the prefix &quot;cygmon&quot;.</LI>
</OL>
<H4 CLASS="Heading3">
<A NAME="pgfId=2562268">
 </A>
Building the ROM images with ecosconfig</H4>
<P CLASS="Body">
<A NAME="pgfId=2562272">
 </A>
(See <A HREF="ecos-tutorial.11.html#26598" CLASS="XRef">
 Using ecosconfig on UNIX</A>
)</P>
<OL>
<P><LI>
<A NAME="pgfId=2562273">
 </A>
Make an empty directory to contain the build tree, and cd into it.</LI>
<P><LI>
<A NAME="pgfId=2562274">
 </A>
To build a GDB stub ROM image, enter the command:<BR>
 <TT CLASS="Code">
$ ecosconfig new edb7xxx stubs<BR>
</TT>
or to build a CygMon ROM monitor image, enter the command:<BR>
 <TT CLASS="Code">
$ ecosconfig new edb7xxx cygmon</TT>
</LI>
<P><LI>
<A NAME="pgfId=2562275">
 </A>
Enter the commands:<BR>
<TT CLASS="Code">
 $ ecosconfig tree<BR>
 $ make</TT>
</LI>
<P><LI>
<A NAME="pgfId=2562276">
 </A>
When the build completes, the image files can be found in the bin/ subdirectory of the install tree. GDB stub ROM images have the prefix &quot;gdb_module&quot;. CygMon images have the prefix &quot;cygmon&quot;.</LI>
</OL>
<H3 CLASS="Heading2">
<A NAME="pgfId=2562278">
 </A>
<A NAME="27146">
 </A>
Loading the ROM Image into On-board Flash</H3>
<P CLASS="Body">
<A NAME="pgfId=2562279">
 </A>
Program images can be written into Flash memory by means of a bootstrap program which is built into the  EDB7211.  This program communicates with a support program on your host to download and program an image into the Flash memory.</P>
<P CLASS="Body">
<A NAME="pgfId=2562280">
 </A>
Cirrus Logic provides such a program for use with Windows/DOS.  eCos comes with a similar program which will run under Linux. The basic operation of both programs is the same.</P>
<OL>
<P><LI>
<A NAME="pgfId=2562281">
 </A>
Connect a serial line to 'UART 1'.</LI>
<P><LI>
<A NAME="pgfId=2562282">
 </A>
Power off the  EDB7211.</LI>
<P><LI>
<A NAME="pgfId=2562283">
 </A>
Install jumper 'PROGRAM ENABLE' which enables this special mode for downloading Flash images. Note that some board revisions have this jumper labelled &quot;BOOT ENABLE&quot;.</LI>
<P><LI>
<A NAME="pgfId=2562284">
 </A>
Power on the  EDB7211.</LI>
<P><LI>
<A NAME="pgfId=2562285">
 </A>
Execute the Flash writing program on your host.  On Linux, this would be:<BR>
<TT CLASS="Code">
<BR>
     # dl_edb7xxx &lt;PATH&gt;/gdb_module.bin<BR>
</TT>
<BR>
where '&lt;PATH&gt;' is the path to the binary format version of the ROM image you wish to load, either as built in the previous section or the &quot;loaders/arm-edb7211/&quot; subdirectory of your eCos installation. The download tool defaults to 38400 baud and device /dev/ttyS1 for communication. To change these, specify them as parameters, e.g.<BR>
<TT CLASS="Code">
<BR>
# dl_edb7xxx &lt;PATH&gt;/gdb_module.bin 9600 /dev/ttyS0</TT>
</LI>
<P><LI>
<A NAME="pgfId=2562286">
 </A>
The download program will indicate that it is waiting for the board to come alive.  At this point, press 'RESET' and then 'WAKEUP' switches in order.  There should be some indication of progress, first of the code being downloaded, then of the programming process.</LI>
<P><LI>
<A NAME="pgfId=2562287">
 </A>
Upon completion of the programming, power off the  EDB7211.</LI>
<P><LI>
<A NAME="pgfId=2562288">
 </A>
Remove the 'PROGRAM ENABLE/BOOT ENABLE' jumper.</LI>
<P><LI>
<A NAME="pgfId=2562289">
 </A>
Power on the  EDB7211, press 'RESET' and 'WAKEUP'.  The new ROM image should now be running on the board.</LI>
<P><LI>
<A NAME="pgfId=2562290">
 </A>
The GDB debugger will now be able to communicate with the board to download and debug RAM based programs.<BR>
<BR>
This procedure also applies for loading ROM-startup eCos programs into the on-board flash memory, given a binary format image of the program from arm-elf-objcopy.  Loading a ROM-startup eCos program into Flash will overwrite the GDB Stub ROM/CygMon in Flash, so you would have to reload the GDB Stub ROM/CygMon to return to normal RAM-startup program development.</LI>
</OL>
<H3 CLASS="Heading2">
<A NAME="pgfId=2562291">
 </A>
Building the Flash Downloader on Linux</H3>
<P CLASS="Body">
<A NAME="pgfId=2562292">
 </A>
eCos provides a Flash download program suitable for use with the  EP7211 Development Board which will run on Linux.  Follow these steps to build this program.  Note: at the time of the writing of these instructions, the download program is built directly within the eCos<EM CLASS="ProductName">
 </EM>
source repository since it is not configuration specific.</P>
<PRE CLASS="CodeExample"><A NAME="pgfId=2562296"> </A>
  # cd &lt;eCos install dir&gt;/packages/hal/arm/edb7xxx/v1_3_x/support</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=2562297"> </A>
  # make</PRE>
<P CLASS="Body">
<A NAME="pgfId=2562298">
 </A>
(where '# ' is your shell prompt)</P>
<P CLASS="Body">
<A NAME="pgfId=2562299">
 </A>
Note: this program was adapted from the Cirrus Logic original DOS program and still contains some vestiges of that environment.</P>
<H3 CLASS="Heading2">
<A NAME="pgfId=2562300">
 </A>
Developing eCos Programs with the ARM Multi-ICE</H3>
<P CLASS="Body">
<A NAME="pgfId=2562301">
 </A>
The EP7211 Development Board supports use of the ARM Multi-processor EmbeddedICE(tm), also known as the Multi-ICE. Full instructions on how to install and use the Multi-ICE in conjunction with GDB are provided in the <EM CLASS="Emphasis">
&quot;GNUPro Toolkit Reference for eCos ARM/Thumb&quot;</EM>
 manual. However, the following platform-specific details should be noted.</P>
<P CLASS="Body">
<A NAME="pgfId=2562302">
 </A>
You will need an ARM Multi-ICE Server configuration file for the EP7211 Development Board. Here is a suggested configuration file to use:</P>
<PRE CLASS="CodeExample"><A NAME="pgfId=2562303"> </A>
======== File &quot;720T.cfg&quot; ======== 
;Total IR length = 4 
[TITLE] 
Multi-ICE configuration for EP7211 
 
[TAP 0] 
ARM720T 
 
[TAPINFO] 
YES 
 
[Timing] 
Low=0 
High=0 
Adaptive=OFF 
==================================</PRE>
<P CLASS="Body">
<A NAME="pgfId=2562304">
 </A>
You must ensure that the board has the appropriate soldered connections. For the EP7211 this involves connecting TEST0 and TEST1 of the EP7211 to ground. To do this you must solder a wire from ground at JP33 to TP8 and TP9.</P>
<P CLASS="Body">
<A NAME="pgfId=2562305">
 </A>
With respect to using multiple devices simultaneously, note that the EP7211 is not ID sensitive.</P>
<P CLASS="Body">
<A NAME="pgfId=2562306">
 </A>
If you wish to view diagnostic output from your program that was downloaded via the Multi-ICE, you will note that by default the output on the serial line (as viewed by a terminal such as Hyperterm in Windows, or cu in Unix) is in the form of GDB packets.</P>
<P CLASS="Body">
<A NAME="pgfId=2562307">
 </A>
To get legible output, the solution is to set the &quot;GDB Serial port&quot; to a different device from the &quot;Diagnostic serial port&quot;, and you should use the Diagnostic serial port to view the diagnostic output.</P>
<P CLASS="Body">
<A NAME="pgfId=2562308">
 </A>
Warning: The multi-ice-gdb-server will fail on startup if the board has not been both reset and awakened before running the server. </P>
<P CLASS="Body">
<A NAME="pgfId=2562309">
 </A>
To resolve this, it is necessary to free up the connection from within the ARM Multi-ICE server itself. However when this happens, the next time you use GDB to load the program into the board, you will see lots of &quot;Readback did not match original data&quot; messages in the output of the multi-ice-gdb-server program. This indicates your program did not load correctly, and you should restart the multi-ice-gdb-server program, taking care to reset the board correctly before reconnecting. </P>
<P CLASS="Body">
<A NAME="pgfId=2562310">
 </A>
As a reminder, you must specify --config-dialog to the multi-ice-gdb-server program to connect to the board correctly. If you do not, the multi-ice-gdb-server program will not be able to connect.</P>
</DIV>
<DIV>
<H3 CLASS="Heading1">
<A NAME="pgfId=2562311">
 </A>
Cirrus Logic ARM EP7212 Development Board Hardware Setup</H3>
<P CLASS="Body">
<A NAME="pgfId=2562312">
 </A>
The Cirrus Logic EP7212 Development Board is almost identical to the EP7211 Development Board from a hardware setup viewpoint, and is based on the same port of eCos. Therefore the earlier documentation for the EP7211 Development Board can be considered equivalent, but with the following changes:</P>
<UL>
<P><LI>
<A NAME="pgfId=2562313">
 </A>
The first serial port is silk screened as &quot;UART 1&quot; on the EP7211 Development Board, but is silk screened as &quot;Serial Port 0&quot; on the EP7212 Development Board. Similarly &quot;UART 2&quot; is silk screened as &quot;Serial Port 1&quot; on the EP7212 Development Board.</LI>
<P><LI>
<A NAME="pgfId=2562314">
 </A>
JP2 (used to control reprogramming of the flash) is not silkscreened with &quot;Boot Enable&quot;.</LI>
<P><LI>
<A NAME="pgfId=2562315">
 </A>
To setup the EP7212 Development Board for use with the ARM Multi-ICE JTAG debugging interface unit, it is necessary to connect TEST0 and TEST1 of the EP7212 to ground.  On the Development Board, this is accomplished by placing shorting blocks on JP47 and JP48. When the shorting blocks are fitted, the board can only be operated through the Multi-ICE - debugging over a serial line is not possible.</LI>
<P><LI>
<A NAME="pgfId=2562316">
 </A>
Prebuilt GDB stubs are provided in the directory loaders/arm-edb7212 relative to the root of your eCos installation</LI>
<P><LI>
<A NAME="pgfId=2562317">
 </A>
When rebuilding the GDB stub ROM image, change the &quot;Cirrus Logic processor variant&quot; option (CYGHWR_HAL_ARM_EDB7XXX_VARIANT) from the EP7211 to the EP7212. This can be selected in the <SPAN CLASS="BOLD">
eCos Configuration Tool,</SPAN>
 or if using ecosconfig, can be set by uncommenting the user_value property of this option in ecos.ecc and setting it to &quot;EP7212&quot;.</LI>
</UL>
</DIV>
<DIV>
<H3 CLASS="Heading1">
<A NAME="pgfId=2562318">
 </A>
Cirrus Logic ARM EP7209 Development Board Hardware Setup</H3>
<P CLASS="Body">
<A NAME="pgfId=2562319">
 </A>
Note: At time of writing, no EP7209 Development Board is available, and consequently eCos has not been verified for use with the EP7209 Development Board.</P>
<P CLASS="Body">
<A NAME="pgfId=2562320">
 </A>
The Cirrus Logic EP7209 Development Board is almost identical to the EP7212 Board in all respects, except that it is not fitted with DRAM, nor has it a DRAM controller.</P>
<P CLASS="Body">
<A NAME="pgfId=2562321">
 </A>
The only valid configuration for the EDB7209 is ROM based. The STUBS and RAM startup modes are not available as no DRAM is fitted.</P>
</DIV>
<DIV>
<H3 CLASS="Heading1">
<A NAME="pgfId=2562323">
 </A>
<A NAME="marker=2562322">
 </A>
Cirrus Logic ARM CL-PS7111 Evaluation Board Hardware Setup</H3>
<P CLASS="Body">
<A NAME="pgfId=2562324">
 </A>
The implementation of the port of eCos to the Cirrus Logic ARM CL-PS7111 Evaluation Board (also known as EB7111) is based on the EP7211 Development Board port.</P>
<P CLASS="Body">
<A NAME="pgfId=2562325">
 </A>
For that reason, the setup required is identical to the  EP7211 Development Board as described above, with the following exceptions:</P>
<UL>
<P><LI>
<A NAME="pgfId=2562326">
 </A>
The Cygmon ROM monitor is not supported</LI>
<P><LI>
<A NAME="pgfId=2562327">
 </A>
The ARM Multi-ICE is not supported</LI>
<P><LI>
<A NAME="pgfId=2562328">
 </A>
Prebuilt GDB stubs are provided in the directory loaders/arm-eb7111 relative to the root of your eCos installation</LI>
<P><LI>
<A NAME="pgfId=2562329">
 </A>
If rebuilding the GDB stub ROM image, change the &quot;Cirrus Logic processor variant&quot; option (CYGHWR_HAL_ARM_EDB7XXX_VARIANT) from the EP7211 to the CL_PS7111. This can be selected in the <SPAN CLASS="BOLD">
eCos Configuration Tool,</SPAN>
 or if using ecosconfig, can be set by uncommenting the user_value property of this option in ecos.ecc and setting it to &quot;CL_PS7111&quot;</LI>
<P><LI>
<A NAME="pgfId=2562383">
 </A>
All remote serial communication is done with the serial I/O connector labelled 'Serial Port 1'</LI>
</UL>
</DIV>
<DIV>
<H3 CLASS="Heading1">
<A NAME="pgfId=2562385">
 </A>
<A NAME="marker=2562384">
 </A>
StrongARM EBSA-285 Hardware Setup</H3>
<P CLASS="Body">
<A NAME="pgfId=2562386">
 </A>
The eCos Developer's Kit package comes with a ROM image which provides GDB<EM CLASS="ProductName">
 </EM>
support for the Intel&#174; StrongARM&#174; Evaluation Board EBSA-285.  Both eCos and the Stub ROM image assume the clocks are: 3.6864 MHz PLL input for generating the core clock, and 50MHz osc input for external clocks. An image of this ROM is also provided at <TT CLASS="Code">
loaders/arm-ebsa285/gdbload.bin</TT>
 under the root of your eCos<EM CLASS="ProductName">
 </EM>
installation.</P>
<P CLASS="Body">
<A NAME="pgfId=2562387">
 </A>
The ROM monitor image (an eCos<EM CLASS="ProductName">
 </EM>
GDB stub) provided for the EBSA-285 board must be programmed into the flash, replacing the Angel monitor on the board. Please refer to the section titled &quot;Loading the ROM Image into On-Board flash&quot; on how to program the ROM onto the board.</P>
<P CLASS="Body">
<A NAME="pgfId=2562388">
 </A>
The Stub ROM allows communication with GDB via the serial connector on the bulkhead mounting bracket COM0.  The communication parameters are fixed at 38400 baud, 8 data bits, no parity bit and 1 stop bit (8-N-1).  No flow control is employed.</P>
<H4 CLASS="Heading3">
<A NAME="pgfId=2562389">
 </A>
Building the GDB Stub FLASH ROM images</H4>
<P CLASS="Body">
<A NAME="pgfId=2562390">
 </A>
Prebuilt GDB stubs images are provided in the directory loaders/arm-ebsa285 relative to the root of your eCos installation, but here are instructions on how to rebuild them if you should ever need to.</P>
<H4 CLASS="Heading3">
<A NAME="pgfId=2562391">
 </A>
Building the GDB Stubs with the eCos Configuration Tool</H4>
<OL>
<P><LI>
<A NAME="pgfId=2562392">
 </A>
Start with a new document - selecting the <SPAN CLASS="Bold">
File</SPAN>
<IMG SRC="../pix/arrow.gif"><SPAN CLASS="Bold">
New</SPAN>
 menu item if necessary to do this.</LI>
<P><LI>
<A NAME="pgfId=2562393">
 </A>
Choose the <SPAN CLASS="Bold">
Build</SPAN>
<IMG SRC="../pix/arrow.gif"><SPAN CLASS="Bold">
Templates</SPAN>
 menu item, and then select the StrongARM EBSA285 hardware.</LI>
<P><LI>
<A NAME="pgfId=2562394">
 </A>
While still displaying the <SPAN CLASS="Bold">
Build</SPAN>
<IMG SRC="../pix/arrow.gif"><SPAN CLASS="Bold">
Templates</SPAN>
 dialog box, select the &quot;stubs&quot; package template to build a GDB stub image. Click <SPAN CLASS="BOLD">
OK.</SPAN>
</LI>
<P><LI>
<A NAME="pgfId=2562395">
 </A>
Build eCos using <SPAN CLASS="Bold">
Build</SPAN>
<IMG SRC="../pix/arrow.gif"><SPAN CLASS="Bold">
Library</SPAN>
</LI>
<P><LI>
<A NAME="pgfId=2562396">
 </A>
When the build completes, the image files can be found in the bin/ subdirectory of the install tree. The GDB stub ROM images have the prefix &quot;gdb_module&quot;.</LI>
</OL>
<H4 CLASS="Heading3">
<A NAME="pgfId=2562397">
 </A>
Building the GDB Stub ROMs with ecosconfig</H4>
<P CLASS="Body">
<A NAME="pgfId=2562401">
 </A>
(See <A HREF="ecos-tutorial.11.html#26598" CLASS="XRef">
 Using ecosconfig on UNIX</A>
)</P>
<OL>
<P><LI>
<A NAME="pgfId=2562402">
 </A>
Make an empty directory to contain the build tree, and cd into it.</LI>
<P><LI>
<A NAME="pgfId=2562403">
 </A>
To build a GDB stub ROM image, enter the command:<BR>
<TT CLASS="Code">
 $ ecosconfig new ebsa285 stubs</TT>
</LI>
<P><LI>
<A NAME="pgfId=2562404">
 </A>
Enter the commands:<BR>
 <TT CLASS="Code">
$ ecosconfig tree<BR>
 $ make</TT>
</LI>
<P><LI>
<A NAME="pgfId=2562405">
 </A>
When the build completes, the image files can be found in the bin/ subdirectory of the install tree. The GDB stub ROM images have the prefix &quot;gdb_module&quot;.</LI>
</OL>
<H3 CLASS="Heading2">
<A NAME="pgfId=2562406">
 </A>
Loading the ROM Image into On-board Flash</H3>
<P CLASS="Body">
<A NAME="pgfId=2562407">
 </A>
There are several ways to install the eCos gdb stub ROM image in the EBSA board's flash memory. Once installed, the gdb stub ROM provides standard eCos download and debug via the EBSA board's serial port. The options available include the Linux based EBSA flash upgrade utility provided by Red Hat, direct writing of the flash via MultiICE (JTAG) hardware debugger, and other flash management utilities from Intel (these only support DOS, and proprietary ARM tools and image formats). Only the Red Hat flash upgrade tool is supported and tested in this release.</P>
<P CLASS="Body">
<A NAME="pgfId=2562408">
 </A>
The flash upgrade tool requires the EBSA board to be configured as a PCI slave (rather than a master, its normal operating mode) and plugged into a Linux host computer's PCI bus.</P>
<P CLASS="Body">
<A NAME="pgfId=2562409">
 </A>
Configuring the board for flash loading: Follow the instructions in the EBSA-285 Reference Manual, pages A-2 and A-3 to configure the board as an add-in card, and enable flash blank programming.  Briefly: assuming the board was in the default setting to execute as a bus master (&quot;Host Bridge&quot;) make jumper 9 (J9), move jumper 10 (J10) to external reset (PCI_RST), and move jumper 15 (J15) link 4-6-5 to connect 5-6 instead of 4-6.</P>
<P CLASS="Body">
<A NAME="pgfId=2562410">
 </A>
Configuring the board for execution of eCos programs: Follow the instructions in the EBSA-285 Reference Manual, pages A-2 and A-3 to configure the board as a &quot;Host Bridge&quot; with &quot;Central Function&quot;.  Briefly: unset J9, move J10 to on-board reset (BRD_RST), and set J15 to make 4-6 instead of 5-6 (see page A-8 also).  Plug the card into its own PCI bus, not the Linux PC used for the flash-programming process.</P>
<P CLASS="Body">
<A NAME="pgfId=2562411">
 </A>
Building the Linux software: the Linux software sources are in directory</P>
<PRE CLASS="CodeExample"><A NAME="pgfId=2562412"> </A>
&lt;BASEDIR&gt;/packages/hal/arm/ebsa285/v1_3/support/linux/safl_util</PRE>
<P CLASS="Body">
<A NAME="pgfId=2562413">
 </A>
in the eCos source repository.  There are two parts to the system: a loadable kernel module and the flash utility.  The loadable kernel module is safl.o and the utility is sa_flash.  To build:</P>
<P CLASS="Body">
<A NAME="pgfId=2562414">
 </A>
  cd to this directory, or a copy of it.</P>
<P CLASS="Body">
<A NAME="pgfId=2562415">
 </A>
  make</P>
<P CLASS="Body">
<A NAME="pgfId=2562416">
 </A>
This builds safl.o and sa_flash. The kernel module must be installed, and a device file created for it. Both of these operations require root permissions.  Create the device file by: </P>
<PRE CLASS="CodeExample"><A NAME="pgfId=2562417"> </A>
      % mknod /dev/safl c 10 178</PRE>
<P CLASS="Body">
<A NAME="pgfId=2562418">
 </A>
Programming the flash: switch off the EBSA-285, and remove the EBSA-285 board from its PCI bus.  Take appropriate anti-static precautions. Configure it for flash loading as above, halt your Linux system and turn it off.  Install the EBSA-285 board in the PCI bus of the Linux system and boot it up. (Single user is good enough, assuming your image and safl_util build dir are on a local disc partition.)  Change directory to the safl_util directory, then, to load the kernel module and flash an image onto the eval board (as root): </P>
<PRE CLASS="CodeExample"><A NAME="pgfId=2562419"> </A>
       % insmod safl.o
       % sa_flash &lt;image_file&gt;</PRE>
<P CLASS="Body">
<A NAME="pgfId=2562420">
 </A>
Halt and turn off the Linux machine and remove the EBSA-285 card.  Take appropriate anti-static precautions.  Configure it for execution of eCos programs as above, and plug it into its own PCI bus.  Restart the Linux machine however you wish.</P>
<P CLASS="Body">
<A NAME="pgfId=2562421">
 </A>
This information is replicated in the README file within the safl_util directory and its parents, and in the <EM CLASS="CiteTitle">
EBSA-285 Reference Manual</EM>
 from Intel, appendix A &quot;Configuration Guide&quot;.  If in doubt, please refer to those documents also.</P>
<P CLASS="Body">
<A NAME="pgfId=2562422">
 </A>
This procedure also applies for loading ROM-startup eCos programs into the on-board flash memory, given a binary format image of the program from arm-elf-objcopy.  Loading a ROM-startup eCos program into flash will overwrite the StubROM in flash, so you would have to reload the StubROM to return to normal RAM-startup program development.</P>
</DIV>
<DIV>
<H3 CLASS="Heading1">
<A NAME="pgfId=2510483">
 </A>
 <A NAME="marker=1997404">
 </A>
i386/Linux Synthetic Target Setup</H3>
<P CLASS="Body">
<A NAME="pgfId=1997406">
 </A>
When building for the synthetic Linux target, the resulting binaries are native Linux applications with the HAL providing suitable bindings between the eCos kernel and the Linux kernel.</P>
<H3 CLASS="Label">
<A NAME="pgfId=2392364">
 </A>
NOTE:</H3>
<P CLASS="Note">
<A NAME="pgfId=2392365">
 </A>
Please be aware that the current implementation of the Linux synthetic target does not allow thread-aware debugging.</P>
<P CLASS="Body">
<A NAME="pgfId=1997407">
 </A>
These Linux applications cannot be run on a Windows system. However, it is possible to write a similar HAL emulation for the Windows kernel if such a testing target is desired.</P>
<H3 CLASS="Heading2">
<A NAME="pgfId=1997408">
 </A>
Tools</H3>
<P CLASS="Body">
<A NAME="pgfId=2395006">
 </A>
For the synthetic target, eCos relies on features not available in native compilers earlier than gcc-2.95.1. It also requires version 2.9.5 or later of the GNU linker. If you have gcc-2.95.1 or later and ld version 2.9.5 or later, then you do not need to build new tools. eCos does not support earlier versions. You can check the compiler version using <TT CLASS="Code">
gcc -v</TT>
 or <TT CLASS="Code">
egcs -v</TT>
, and the linker version using <TT CLASS="Code">
ld -v</TT>
.</P>
<P CLASS="Body">
<A NAME="pgfId=2395013">
 </A>
If you have native tools that are sufficiently recent for use with eCos, you should be aware that by default eCos assumes that the tools <TT CLASS="Code">
i686-pc-linux-gnu-gcc</TT>
, <TT CLASS="Code">
i686-pc-linux-gnu-ar</TT>
,  <TT CLASS="Code">
i686-pc-linux-gnu-ld</TT>
, and <TT CLASS="Code">
i686-pc-linux-gnu-objcopy</TT>
 are on your system and are the correct versions for use with eCos. But instead, you can tell eCos to use your native tools by editing the configuration value &quot;Global command prefix&quot; (CYGBLD_GLOBAL_COMMAND_PREFIX) in your eCos configuration. If left empty (i.e. set to the empty string) eCos will use your native tools when building.</P>
<P CLASS="Body">
<A NAME="pgfId=2395068">
 </A>
If you have any difficulties, it is almost certainly easiest overall to rebuild the tools as described on:</P>
<PRE CLASS="CodeExample"><A NAME="pgfId=2395069"> </A>
<A HREF="http://sourceware.cygnus.com/ecos/getstart.html" CLASS="URL">http://sourceware.cygnus.com/ecos/getstart.html</A>
</PRE>
<TABLE>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
</TD>
</TR>
</TABLE>
</DIV>
<HR ALIGN="center"><TABLE STYLE="ECOS" WIDTH="98%" BORDER="0" ALIGN="LEFT" CELLPADDING="1"><TR><TH COLSPAN="3" ALIGN="center"><P CLASS="Gotos">Target Setup</P></TH></TR><TR><TD  ALIGN="center"><P CLASS="Gotos"><A HREF="ecos-tutorial.2.html">To Contents</A></P></TD><TD  ALIGN="center"><P CLASS="Gotos"><A HREF="ecos-tutorial.c.html">To&nbsp;previous&nbsp;page</A></P></TD><TD  ALIGN="center"><P CLASS="Gotos"><A HREF="ecos-tutorial.e.html">To&nbsp;next&nbsp;page</A></P></TD></TR></TABLE></BODY>
</HTML>
