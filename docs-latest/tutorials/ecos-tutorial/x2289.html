<HTML
><HEAD
><TITLE
>StrongARM EBSA-285 hardware setup</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.33"><LINK
REL="HOME"
TITLE="Getting Started with eCos"
HREF="ecos-tutorial.html"><LINK
REL="UP"
TITLE="Hardware
setup"
HREF="hardware-setup.html"><LINK
REL="PREVIOUS"
TITLE="VR4300 hardware setup"
HREF="x2275.html"><LINK
REL="NEXT"
TITLE="SH3EDK7708 hardware setup"
HREF="x2364.html"></HEAD
><BODY
><DIV
CLASS="NAVHEADER"
><TABLE
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="3"
ALIGN="center"
>Getting Started with <SPAN
CLASS="PRODUCTNAME"
><SPAN
CLASS="TRADEMARK"
>eCos</SPAN
><SUP
><FONT
SIZE="-4"
>TM</FONT
></SUP
></SPAN
></TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="bottom"
><A
HREF="x2275.html"
>Prev</A
></TD
><TD
WIDTH="80%"
ALIGN="center"
VALIGN="bottom"
>Chapter 10. Hardware
setup</TD
><TD
WIDTH="10%"
ALIGN="right"
VALIGN="bottom"
><A
HREF="x2364.html"
>Next</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><DIV
CLASS="SECT1"
><H1
CLASS="SECT1"
><A
NAME="AEN2289"
>StrongARM EBSA-285 hardware setup</A
></H1
><P
>The <SPAN
CLASS="PRODUCTNAME"
>eCos</SPAN
> Developer&#8217;s Kit
package comes with a ROM image which provides <SPAN
CLASS="APPLICATION"
>GDB</SPAN
> support
for the Intel(R) StrongARM(R) Evaluation Board EBSA-285.  Both <SPAN
CLASS="PRODUCTNAME"
>eCos</SPAN
> and the
Stub ROM image assume the clocks are: 3.6864 MHz PLL input for generating
the core clock, and 50MHz osc input for external clocks. An image
of this ROM is also provided at <TT
CLASS="FILENAME"
>loaders/arm-ebsa285/gdbload.bin</TT
> under
the root of your <SPAN
CLASS="PRODUCTNAME"
>eCos</SPAN
> installation.</P
><P
>The ROM monitor image (an <SPAN
CLASS="PRODUCTNAME"
>eCos</SPAN
> <SPAN
CLASS="APPLICATION"
>GDB</SPAN
> stub)
provided for the EBSA-285 board must be programmed into the flash,
replacing the Angel monitor on the board. Please refer to the section
titled "Loading the ROM Image into On-Board flash" on how to program
the ROM onto the board.</P
><P
>The Stub ROM allows communication with <SPAN
CLASS="APPLICATION"
>GDB</SPAN
> via
the serial connector on the bulkhead mounting bracket COM0.  The
communication parameters are fixed at 38400 baud, 8 data bits, no
parity bit and 1 stop bit (8-N-1).  No flow control is employed.</P
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN2305"
>Building the ROM image</A
></H2
><P
><SPAN
CLASS="PRODUCTNAME"
>eCos</SPAN
> comes with a pre-built GDB
stub ROM image for the EBSA-285 platform. This can be found in the
loaders\arm-ebsa285 subdirectory of the <SPAN
CLASS="PRODUCTNAME"
>eCos</SPAN
> install
directory.</P
><P
>If necessary, the ROM image can be re-built as follows:</P
><P
>1. Open a Bash session using      Start-&#62;Programs-&#62;Cygnus
eCos-&#62;eCos Development Environment</P
><P
>2. Create a build directory and cd into it.</P
><P
>3. Run (all as one line):     <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>      cygtclsh80 &#60;BASE_DIR&#62;/packages/pkgconf.tcl --target=arm --platform=ebsa285 \
        --startup=rom --disable-kernel --disable-uitron --disable-libc\
        --disable-libm --disable-io --disable-io_serial\
       --disable-wallclock --disable-watchdog</PRE
></TD
></TR
></TABLE
> </P
><P
> Where &#60;BASE_DIR&#62; is the path to
the <SPAN
CLASS="PRODUCTNAME"
>eCos</SPAN
> installation directory. On Unix,
use tclsh in place of cygtclsh80</P
><P
>4. Edit the configuration file "pkgconf/hal.h" in
the build directory tree as follows:<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>          enable   CYGDBG_HAL_DEBUG_GDB_INCLUDE_STUBS
          disable  CYGFUN_HAL_COMMON_KERNEL_SUPPORT
          disable  CYGDBG_HAL_DEBUG_GDB_BREAK_SUPPORT
          disable  CYGDBG_HAL_DEBUG_GDB_CTRLC_SUPPORT
          disable  CYGDBG_HAL_DEBUG_GDB_THREAD_SUPPORT
         enable   CYG_HAL_ROM_MONITOR</PRE
></TD
></TR
></TABLE
>    ("enable" means make sure there is a #define;
"disable" means make sure the symbol has a #undef.)</P
><P
>5. Run: make</P
><P
>6. Run: make -C hal/common/v1_2_9/src/stubrom</P
><P
>The file hal/common/current/src/stubrom/stubrom
will be an ELF format executable of the ROM. Use objcopy to convert
this to the appropriate format for loading into the onboard flash
memory, "binary" in this case. <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>      arm-elf-objcopy -O binary hal/common/v1_2_9/src/stubrom/stubrom stubrom.img</PRE
></TD
></TR
></TABLE
></P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN2323"
>Loading the ROM image into on-board
Flash</A
></H2
><P
>There are several ways to install the <SPAN
CLASS="PRODUCTNAME"
>eCos</SPAN
> gdb
stub ROM image in the EBSA board&#8217;s flash memory. Once installed,
the gdb stub ROM provides standard <SPAN
CLASS="PRODUCTNAME"
>eCos</SPAN
> download and
debug via the EBSA board"s serial port. The options available
include the Linux based EBSA flash upgrade utility provided by Cygnus,
direct writing of the flash via MultiICE (JTAG) hardware debugger,
and other flash management utilities from Intel (these only support
DOS, and proprietary ARM tools and image formats). Only the Cygnus
flash upgrade tool is supported and tested in this release.</P
><P
>The flash upgrade tool requires the EBSA board to be configured
as a PCI slave (rather than a master, its normal operating mode)
and plugged into a Linux host computer"s PCI bus.</P
><P
>Configuring the board for flash loading: Follow the instructions
in the EBSA-285 Reference Manual, pages A-2 and A-3 to configure
the board as an add-in card, and enable flash blank programming.
 Briefly: assuming the board was in the default setting to execute
as a bus master ("Host Bridge") make jumper 9 (J9), move jumper 10
(J10) to external reset (PCI_RST), and move jumper 15 (J15)
link 4-6-5 to connect 5-6 instead of 4-6.</P
><P
>Configuring the board for execution of <SPAN
CLASS="PRODUCTNAME"
>eCos</SPAN
> programs:
Follow the instructions in the EBSA-285 Reference Manual, pages
A-2 and A-3 to configure the board as a "Host Bridge" with "Central
Function".  Briefly: unset J9, move J10 to on-board reset (BRD_RST),
and set J15 to make 4-6 instead of 5-6 (see page A-8 also).  Plug
the card into its own PCI bus, not the Linux PC used for the flash-programming
process.</P
><P
>Building the Linux software: the Linux software sources are
in directory<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>      &#60;BASEDIR&#62;/packages/hal/arm/ebsa285/current/support/linux/safl_util</PRE
></TD
></TR
></TABLE
>in the <SPAN
CLASS="PRODUCTNAME"
>eCos</SPAN
> source repository.
 There are two parts to the system: a loadable kernel module and
the flash utility.  The loadable kernel module is safl.o and the
utility is sa_flash.  To build:  cd to this directory,
or a copy of it.  makeThis builds safl.o and sa_flash.
The kernel module must be installed, and a device file created for
it. Both of these operations require root permissions.  Create the
device file by: <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>      % mknod /dev/safl c 10 178</PRE
></TD
></TR
></TABLE
>Programming the flash: switch off the EBSA-285, and remove
the EBSA-285 board from its PCI bus.  Take appropriate anti-static
precautions. Configure it for flash loading as above, halt your
Linux system and turn it off.  Install the EBSA-285 board in the
PCI bus of the Linux system and boot it up. (Single user is good
enough, assuming your image and safl_util build dir are
on a local disc partition.)  Change directory to the safl_util
directory, then, to load the kernel module and flash an image onto
the eval board (as root): <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>       % insmod safl.o
       % sa_flash &#60;image_file&#62;</PRE
></TD
></TR
></TABLE
>Halt and turn off the Linux machine and remove the EBSA-285
card.  Take appropriate anti-static precautions.  Configure it for
execution of <SPAN
CLASS="PRODUCTNAME"
>eCos</SPAN
>programs as above, and
plug it into its own PCI bus.  Restart the Linux machine however
you wish.</P
><P
>This information is replicated in the README file within the
safl_util directory and its parents, and in the <I
CLASS="CITETITLE"
>EBSA-285
Reference Manual</I
> from Intel, appendix A "Configuration
Guide".  If in doubt, please refer to those documents also.</P
><P
>This procedure also applies for loading ROM-startup <SPAN
CLASS="PRODUCTNAME"
>eCos</SPAN
> programs
into the on-board flash memory, given a binary format image of the
program from arm-elf-objcopy.  Loading a ROM-startup <SPAN
CLASS="PRODUCTNAME"
>eCos</SPAN
> program
into flash will overwrite the StubROM in flash, so you would have
to reload the StubROM to return to normal RAM-startup program development.</P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN2343"
>Running your eCos program using GDB and the StubROM</A
></H2
><DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
><B
>Note: </B
>You must first load the StubROM image into the flash memory
on the EBSA-285 board before doing this.  See  for details.</P
></BLOCKQUOTE
></DIV
><P
>Connect to the StubROM in the board and run your <SPAN
CLASS="PRODUCTNAME"
>eCos</SPAN
> program &#60;PROGRAM&#62; asfollows:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>      $ arm-elf-gdb -nw &#60;PROGRAM&#62;
       (gdb) set remotebaud 38400
      (gdb) target remote &#60;DEVICE&#62;</PRE
></TD
></TR
></TABLE
><P
>Where &#60;DEVICE&#62; is /dev/ttyS0
or COM1: or similar, depending on your environment and how you connected
your serial line to the host computer. Expect some output here,
for example:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>      Remote debugging using /dev/ttyS0
      0x410026a4 in ?? ()</PRE
></TD
></TR
></TABLE
><P
>then, to load the program</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>&#13;        (gdb) load
    </PRE
></TD
></TR
></TABLE
><P
>which will report locations and sizes of sections as they
load, then begin execution using<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>      (gdb) continue</PRE
></TD
></TR
></TABLE
></P
><P
>If you have no <SPAN
CLASS="PRODUCTNAME"
>eCos</SPAN
> program yet,
but you want to connect to the board just to verify serial communications,
tell gdb "set endian little" before anything else, so that it understands
the board (GDB normally infers this from information within the <SPAN
CLASS="PRODUCTNAME"
>eCos</SPAN
> program).</P
><DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
><B
>Note: </B
>When an <SPAN
CLASS="PRODUCTNAME"
>eCos</SPAN
> program is run on
the EBSA-285 board, the GDB stub in ROM loses control. This means
that if you require the ability to stop execution on the target
remotely, or want thread debugging capabilities, you must include GDB
stub support when configuring <SPAN
CLASS="PRODUCTNAME"
>eCos</SPAN
>.</P
></BLOCKQUOTE
></DIV
></DIV
></DIV
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="x2275.html"
>Prev</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="ecos-tutorial.html"
>Home</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="x2364.html"
>Next</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>VR4300 hardware setup</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="hardware-setup.html"
>Up</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>SH3/EDK7708 hardware setup</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>