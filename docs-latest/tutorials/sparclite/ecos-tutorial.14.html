<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML EXPERIMENTAL 970324//EN">
<HTML>
<HEAD><!--version 1.3.4/Fri Apr 28 15:02:34 BST 2000-->
<META NAME="GENERATOR" CONTENT="Adobe FrameMaker 5.5/HTML Export Filter">
<LINK REL="STYLESHEET" HREF="../cygnus.css">
<TITLE> More Features -- Clocks and Alarm Handlers</TITLE></HEAD>
<BODY BGCOLOR="#ffffff">
<DIV>
<TABLE STYLE="ECOS" WIDTH="98%" BORDER="0" ALIGN="LEFT" CELLPADDING="1"><TR><TH COLSPAN="3" ALIGN="center"><P CLASS="Gotos">More Features -- Clocks and Alarm Handlers</P></TH></TR><TR><TD  ALIGN="center"><P CLASS="Gotos"><A HREF="ecos-tutorial.2.html">To Contents</A></P></TD><TD  ALIGN="center"><P CLASS="Gotos"><A HREF="ecos-tutorial.13.html">To&nbsp;previous&nbsp;page</A></P></TD><TD ALIGN="center"><P CLASS="Gotos"><A HREF="ecos-tutorial.15.html">To&nbsp;next&nbsp;page</A></P></TD></TR></TABLE><P ALIGN="LEFT">&nbsp;</P><BR><BR><HR ALIGN="center"></DIV>
<H2 CLASS="ChapterTitle">
<A NAME="pgfId=1741808">
 </A>
More Features -- <A NAME="marker=1741807">
 </A>
Clocks and Alarm Handlers<DIV>
<IMG SRC="../botclear.gif">
</DIV>
</H2>
<P CLASS="Body">
<A NAME="pgfId=1741809">
 </A>
If a program wanted to execute a task at a given time, or periodically, it could do it in an inefficient way by sitting in an infinite loop and checking the real-time clock to see if the proper amount of time has elapsed. But operating systems usually provide system calls which allow the program to be interrupted at the desired time.</P>
<P CLASS="Body">
<A NAME="pgfId=1741810">
 </A>
eCos provides a rich timekeeping formalism, involving <EM CLASS="Emphasis">
counters,</EM>
 <EM CLASS="Emphasis">
clocks,</EM>
 <EM CLASS="Emphasis">
alarms,</EM>
 and <EM CLASS="Emphasis">
timers.</EM>
 The precise definition, relationship, and motivation of these features is beyond the scope of this tutorial, but these examples illustrate how to set up basic periodic tasks.</P>
<P CLASS="Body">
<A NAME="pgfId=1741812">
 </A>
<EM CLASS="Emphasis">
Alarms</EM>
<A NAME="marker=1741811">
 </A>
 are events that happen at a given time, either once or periodically. A thread associates an alarm handling function with the alarm, so that the function will be invoked every time the alarm &quot;goes off&quot;.</P>
<DIV>
<H3 CLASS="Heading1">
<A NAME="pgfId=1741813">
 </A>
A Sample Program with Alarms</H3>
<P CLASS="Body">
<A NAME="pgfId=1741815">
 </A>
<A NAME="marker=1741814">
 </A>
<TT CLASS="Code">
simple-alarm.c</TT>
 (in the examples directory) is a short program that creates a thread that creates an alarm. The alarm is handled by the function <TT CLASS="Code">
test_alarm_func()</TT>
, which sets a global variable. When the main thread of execution sees that the variable has changed, it prints a message.</P>
<P CLASS="Body">
<A NAME="pgfId=1741816">
 </A>
</P>
<P CLASS="Body">
<A NAME="pgfId=1741817">
 </A>
</P>
<P CLASS="ExampleTitle">
<A NAME="pgfId=1741819">
 </A>
A sample <A NAME="marker=1741818">
 </A>
program that creates an alarm</P>
<PRE CLASS="CodeExample"><A NAME="pgfId=1741820"> </A>
 /* this is a very simple program meant to demonstrate
 a basic use of time, alarms and alarm-handling functions
 in eCos */

#include &lt;cyg/kernel/kapi.h&gt;

#include &lt;stdio.h&gt;

#define NTHREADS 1
#define STACKSIZE 4096

static cyg_handle_t thread[NTHREADS];

static cyg_thread thread_obj[NTHREADS];
static char stack[NTHREADS][STACKSIZE];

static void alarm_prog( cyg_addrword_t data );

/* we install our own startup routine which sets up
 threads and starts the scheduler */
void cyg_user_start(void)
{
 cyg_thread_create(4, alarm_prog, (cyg_addrword_t) 0,
	&quot;alarm_thread&quot;, (void *) stack[0],
	STACKSIZE, &amp;thread[0], &amp;thread_obj[0]);
 cyg_thread_resume(thread[0]);
}

/* we need to declare the alarm handling function (which is
 defined below), so that we can pass it to
 cyg_alarm_initialize() */
cyg_alarm_t test_alarm_func;

/* alarm_prog() is a thread which sets up an alarm which is then
 handled by test_alarm_func() */
static void alarm_prog(cyg_addrword_t data)
{
 cyg_handle_t test_counterH, system_clockH, test_alarmH;
 cyg_tick_count_t ticks;
 cyg_alarm test_alarm;
 unsigned how_many_alarms = 0, prev_alarms = 0, tmp_how_many;

 system_clockH = cyg_real_time_clock();
 cyg_clock_to_counter(system_clockH, &amp;test_counterH);
 cyg_alarm_create(test_counterH, test_alarm_func,
	(cyg_addrword_t) &amp;how_many_alarms,
	&amp;test_alarmH, &amp;test_alarm);
 cyg_alarm_initialize(test_alarmH, cyg_current_time()+200, 200);

 /* get in a loop in which we read the current time and
 print it out, just to have something scrolling by */
 for (;;) {
 ticks = cyg_current_time();
 printf(&quot;Time is %llu\n&quot;, ticks);
 /* note that we must lock access to how_many_alarms, since the
 alarm handler might change it. this involves using the
 annoying temporary variable tmp_how_many so that I can keep the
 critical region short */
 cyg_scheduler_lock();
 tmp_how_many = how_many_alarms;
 cyg_scheduler_unlock();
 if (prev_alarms != tmp_how_many) {
 printf(&quot; --- alarm calls so far: %u\n&quot;, tmp_how_many);
 prev_alarms = tmp_how_many;
 }
 cyg_thread_delay(30);
 }
}

/* test_alarm_func() is invoked as an alarm handler, so
 it should be quick and simple. in this case it increments
 the data that is passed to it. */
void test_alarm_func(cyg_handle_t alarmH, cyg_addrword_t data)
{
 ++*((unsigned *) data);
} </PRE>
<P CLASS="Body">
<A NAME="pgfId=1741821">
 </A>
When you run this program (by typing <TT CLASS="Code">
run</TT>
 at the (<SPAN CLASS="Bold">
gdb</SPAN>
) prompt) the output should look like this:</P>
<PRE CLASS="CodeExample"><A NAME="pgfId=1741822"> </A>

Starting program: BASE_DIR/examples/simple-alarm.exe
Time is 0
Time is 30
Time is 60
Time is 90
Time is 120
Time is 150
Time is 180
Time is 210
  --- alarm calls so far: 1
Time is 240
Time is 270
Time is 300
Time is 330
Time is 360
Time is 390
Time is 420
  --- alarm calls so far: 2
Time is 450
Time is 480 </PRE>
<H3 CLASS="Label">
<A NAME="pgfId=2336840">
 </A>
NOTE</H3>
<P CLASS="Note">
<A NAME="pgfId=2336842">
 </A>
When running in a simulator the <A NAME="marker=2336841">
 </A>
delays might be quite long. On a hardware board (where the clock speed is 100 ticks/second) the delays should average to about 0.3 seconds (and 2 seconds between alarms). In simulation, the delay will depend on the speed of the processor and will almost always be much slower than the actual board. You might want to reduce the delay parameter when running in simulation. </P>
<P CLASS="Body">
<A NAME="pgfId=1741826">
 </A>
Here are a few things you might notice about this program:</P>
<UL>
<P><LI>
<A NAME="pgfId=1741827">
 </A>
It used the <EM CLASS="function">
cyg_real_time_clock();</EM>
 this always returns a handle to the default system real-time <A NAME="marker=1741828">
 </A>
clock. </LI>
<P><LI>
<A NAME="pgfId=1741831">
 </A>
<A NAME="marker=1741829">
 </A>
Alarms are based on <A NAME="marker=1741830">
 </A>
counters, so the function <EM CLASS="function">
cyg_alarm_create()</EM>
 uses a counter handle. The program used the function <EM CLASS="function">
cyg_clock_to_counter()</EM>
 to strip the clock handle to the underlying counter handle. </LI>
<P><LI>
<A NAME="pgfId=1741833">
 </A>
Once the alarm is created it is <A NAME="marker=1741832">
 </A>
initialized with <EM CLASS="function">
cyg_alarm_initialize(),</EM>
 which sets the time at which the alarm should go off, as well as the period for repeating alarms. It is set to go off at the current time and then to repeat every 200 ticks. </LI>
<P><LI>
<A NAME="pgfId=1741834">
 </A>
The alarm handler function <EM CLASS="function">
test_alarm_func()</EM>
 conforms to the guidelines for writing alarm handlers and other <EM CLASS="Emphasis">
delayed service routines</EM>
<A NAME="marker=1741835">
 </A>
<A NAME="marker=2528815">
 </A>
: it does not invoke any functions which might lock the scheduler. This is discussed in detail in the <EM CLASS="Emphasis">
eCos Reference Manual,</EM>
 in the chapter <EM CLASS="Emphasis">
Requirements for programs.</EM>
</LI>
<P><LI>
<A NAME="pgfId=1741836">
 </A>
There is a <EM CLASS="Emphasis">
critical region</EM>
 in this program: the variable <EM CLASS="Emphasis">
how_many_alarms</EM>
 is accessed in the main thread of control and is also modified in the alarm handler. To prevent a possible (though unlikely) race condition on this variable, access to <EM CLASS="Emphasis">
how_many_alarms</EM>
 in the principal thread is protected by calls to <EM CLASS="function">
cyg_scheduler_lock()</EM>
 and <EM CLASS="function">
cyg_scheduler_unlock().</EM>
 When the scheduler is locked, the alarm handler will not be invoked, so the problem is averted. </LI>
</UL>
<P CLASS="Body">
<A NAME="pgfId=1740598">
 </A>
</P>
</DIV>
<HR ALIGN="center"><TABLE STYLE="ECOS" WIDTH="98%" BORDER="0" ALIGN="LEFT" CELLPADDING="1"><TR><TH COLSPAN="3" ALIGN="center"><P CLASS="Gotos">More Features -- Clocks and Alarm Handlers</P></TH></TR><TR><TD  ALIGN="center"><P CLASS="Gotos"><A HREF="ecos-tutorial.2.html">To Contents</A></P></TD><TD  ALIGN="center"><P CLASS="Gotos"><A HREF="ecos-tutorial.13.html">To&nbsp;previous&nbsp;page</A></P></TD><TD  ALIGN="center"><P CLASS="Gotos"><A HREF="ecos-tutorial.15.html">To&nbsp;next&nbsp;page</A></P></TD></TR></TABLE></BODY>
</HTML>
