<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML EXPERIMENTAL 970324//EN">
<HTML>
<HEAD><!--version 1.3.4/Thur May 4 2000-->
<META NAME="GENERATOR" CONTENT="Adobe FrameMaker 5.5/HTML Export Filter">
<LINK REL="STYLESHEET" HREF="cygnus.css">
<TITLE> eCos Interrupt Model</TITLE></HEAD>
<BODY BGCOLOR="#ffffff">
<DIV>
<TABLE STYLE="ECOS" WIDTH="98%" BORDER="0" ALIGN="LEFT" CELLPADDING="1"><TR><TH COLSPAN="3" ALIGN="center"><P CLASS="Gotos">eCos Interrupt Model</P></TH></TR><TR><TD  ALIGN="center"><P CLASS="Gotos"><A HREF="ecos-ref.2.html">To Contents</A></P></TD><TD  ALIGN="center"><P CLASS="Gotos"><A HREF="ecos-ref.b.html">To&nbsp;previous&nbsp;page</A></P></TD><TD ALIGN="center"><P CLASS="Gotos"><A HREF="ecos-ref.c2.html">To&nbsp;next&nbsp;page</A></P></TD></TR></TABLE><P ALIGN="LEFT">&nbsp;</P><BR><BR><HR ALIGN="center"></DIV>
<H2 CLASS="ChapterTitle">
<A NAME="pgfId=1129702">
 </A>
eCos <A NAME="marker=1129901">
 </A>
Interrupt Model<DIV>
<IMG SRC="botclear.gif">
</DIV>
</H2>
<P CLASS="Body">
<A NAME="pgfId=1129711">
 </A>
This chapter describes the <SPAN CLASS="Bold">
eCos</SPAN>
 interrupt model in detail. </P>
<P CLASS="Body">
<A NAME="pgfId=1129715">
 </A>
Interrupt handling is an important part of most real-time systems. Timely handling of interrupt sources is important. This can be severely impacted by certain activities that must be considered atomic (i.e. uninterruptible). Typically these activities are executed with interrupts disabled. In order to keep such activities to a minimum and allow for the smallest possible interrupt latencies, <SPAN CLASS="Bold">
eCos</SPAN>
 uses a split interrupt handling scheme. In this scheme, interrupt handling is separated into two parts. The first part is known as the <A NAME="marker=1129905">
 </A>
Interrupt Service Routine or ISR. The second part is the <A NAME="marker=1129909">
 </A>
Deferred Service Routine or DSR. This separation explicitly allows for the DSRs to be run with interrupts enabled, thus allowing other potentially higher priority interrupts to occur and be processed while processing a lower priority interrupt. </P>
<P CLASS="Body">
<A NAME="pgfId=1129724">
 </A>
In order for this model to work, the ISR should run quickly. If the service requirements for the interrupt are small, the interrupt can be completely handled by the ISR and no DSR is required. However, if servicing the interrupt is more complex, a DSR should be used. The DSR will be run at some later time, at the point when thread scheduling is allowed. Postponing the execution of DSRs until this time allows for simple synchronization methods to be used by the kernel. </P>
<P CLASS="Body">
<A NAME="pgfId=1129729">
 </A>
Further, this controlled calling -- when thread scheduling is allowed -- means that DSRs can interact with the kernel, for example by signalling that an asynchronous operation has completed. </P>
<P CLASS="Body">
<A NAME="pgfId=1129734">
 </A>
In order to allow DSRs to run with interrupts enabled, the ISR for a particular interrupt source (or the hardware) must arrange that that interrupt will not recur until the DSR has completed. In some cases, this is how the hardware works. Once an interrupt is delivered another interrupt will not occur until re-enabled. In the general case, however, it is up to the ISR to enforce this behavior. Typically the ISR will &quot;mask&quot; the interrupt source, thus preventing its recurrence. The DSR will then unmask the interrupt when it has been serviced thus allowing new occurrences of the interrupt to be delivered when they happen. </P>
<P CLASS="Body">
<A NAME="pgfId=1129739">
 </A>
Alternatively, if an ISR is doing very little per interrupt, for example transferring one byte from memory to an IO device, it may only be necessary to interact with the rest of the system when a &quot;transfer&quot; is complete. In such a case an ISR could execute many times and only when it reaches the end of a buffer does it need to request execution of its DSR. </P>
<P CLASS="Body">
<A NAME="pgfId=1129744">
 </A>
If the interrupt source is &quot;bursty&quot;, it may be OK for several interrupts and calls to the ISR to occur before a requested DSR has been executed; the kernel maintains counts for posted DSRs, and in such a case the DSR will eventually be called with a parameter that tells it how many ISRs requested that the DSR be called. Care is needed to get the interrupt code right for such a situation, for one call to the DSR is required to do the work of several. </P>
<P CLASS="Body">
<A NAME="pgfId=1129749">
 </A>
As mentioned above, the DSR will execute at some later time. Depending on the state of the system, it may be executed at a much later time. There are periods during certain kernel operations where thread scheduling is disabled, and hence DSRs are not allowed to operate. These periods have been purposefully made as limited as possible in the <SPAN CLASS="Bold">
eCos</SPAN>
 kernel, but they still exist. In addition, user threads have the ability to suspend scheduling as well, thus affecting the possible DSR execution latency. If a DSR cannot be executed sufficiently quickly, the interrupt source may actually overrun. This would be considered a system failure. </P>
<P CLASS="Body">
<A NAME="pgfId=1129758">
 </A>
One of the problems system designers face is how much stack space to allow each thread in the system. <SPAN CLASS="Bold">
eCos</SPAN>
 does not dictate the size of thread stacks, it is left to the user when the thread is created. The size of the stack depends on the thread requirements as well as some fixed overhead required by the system. In this case, the overhead is enough stack space to hold a complete thread state (the actual amount depends on the CPU architecture). Guidelines for the minimum stack requirements are provided by the HAL using the symbol <EM CLASS="parameter">
CYGNUM_HAL_STACK_SIZE_MINIMUM.</EM>
 </P>
<P CLASS="Body">
<A NAME="pgfId=1129771">
 </A>
A potential problem with this scheme is with nested interrupts. Since interrupts are reenabled during the DSR portion of servicing an interrupt, there is the possibility of a new interrupt (hopefully from a separate source) arriving while this processing takes place. When this new interrupt is serviced some state information about the interrupted processing will be saved on the stack. The amount of this information again depends on the CPU architecture and in some cases it is substantial. This implies that any given stack would need enough space to potentially hold &quot;N&quot; interrupt frames. In a realtime system with many threads this is an untenable situation. To solve this problem, <SPAN CLASS="Bold">
eCos</SPAN>
 allows for a separate interrupt stack to be used while processing interrupts. This stack needs to be large enough to support &quot;N&quot; nested interrupts, but each individual thread stack only needs the overhead of a single interrupt state. This is because the thread state is kept on the thread's own stack, including information about any interrupt that caused the thread to be scheduled. This is a much better situation in the end, however, since only the interrupt stack need be large enough to handle the potential interrupt servicing needs. </P>
<P CLASS="Body">
<A NAME="pgfId=1129784">
 </A>
<SPAN CLASS="Bold">
eCos</SPAN>
 allows for the use of the interrupt stack to be totally configurable. The user can elect to not use a separate interrupt stack. This requires making all thread stacks large enough but does reduce the overhead of switching stacks while processing interrupts. On the other hand, if memory is tight, then choosing a separate interrupt stack would be warranted at the cost of a few machine cycles during the processing of each interrupt. </P>
<P CLASS="Body">
<A NAME="pgfId=1129789">
 </A>
Not all target HALs support this feature from day one anyway; however common configuration features such as this may still be presented in the config tool, and present in include files, even if the actual target selected does not support the feature at this time. </P>
<P CLASS="Body">
<A NAME="pgfId=1129794">
 </A>
The following problem with the interrupt system has been observed. On the mn10300 simulator, interrupts were occurring immediately after they were re-enabled in the DSR. This should really be considered a case of interrupt overrun since there is no possibility of useful [or any] processing between the time an interrupt has been serviced and an subsequent interrupt occurs, hence the system is totally saturated. The problem came about because the stack was overflowing. It was a user [thread] stack that overflowed because DSR processing was taking place on the thread stack. Analysis of this problem led to a rework of how interrupts are processed, in particular the use of a separate interrupt stack during interrupt processing (both ISR and DSR parts). The overflow can still happen, but now it is restricted to only the interrupt stack. The system designer can make accommodations for this by making a suitably large interrupt stack if it is known that the &quot;overrun&quot; is finite, e.g. in the case of a serial device, this could be the depth of some FIFO. In any case, overrun should be avoided, but having only a single stack that needs to suffer multiple interrupt frames allows for this failure to be detected simply. </P>
<P CLASS="Body">
<A NAME="pgfId=1129799">
 </A>
Of course, it is only worthwhile having a separate interrupt stack if you are using an <SPAN CLASS="Bold">
eCos</SPAN>
 configuration that has a scheduler and multiple threads. If there is no kernel, then the C library arranges to call <CODE CLASS="CodeOutput">
main()</CODE>
, or your application may be entered from <CODE CLASS="CodeOutput">
cyg_user_start()</CODE>
, on the startup stack. It runs on the only stack there is in the system. Depending on the design of the particular HAL for your target platform, it is natural to re-use the startup stack as the interrupt stack as soon as the scheduler is running. Since this is only sensible if there is a kernel, HALs typically only implement the separate interrupt stack if the kernel is present. </P>

<TABLE>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
</TD>
</TR>
</TABLE>
<HR ALIGN="center"><TABLE STYLE="ECOS" WIDTH="98%" BORDER="0" ALIGN="LEFT" CELLPADDING="1"><TR><TH COLSPAN="3" ALIGN="center"><P CLASS="Gotos">eCos Interrupt Model</P></TH></TR><TR><TD  ALIGN="center"><P CLASS="Gotos"><A HREF="ecos-ref.2.html">To Contents</A></P></TD><TD  ALIGN="center"><P CLASS="Gotos"><A HREF="ecos-ref.b.html">To&nbsp;previous&nbsp;page</A></P></TD><TD  ALIGN="center"><P CLASS="Gotos"><A HREF="ecos-ref.c2.html">To&nbsp;next&nbsp;page</A></P></TD></TR></TABLE></BODY>
</HTML>
