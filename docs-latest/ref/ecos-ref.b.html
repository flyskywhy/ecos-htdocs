<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML EXPERIMENTAL 970324//EN">
<HTML>
<HEAD><!--version 1.3.4/Thur May 4 2000-->
<META NAME="GENERATOR" CONTENT="Adobe FrameMaker 5.5/HTML Export Filter">
<LINK REL="STYLESHEET" HREF="cygnus.css">
<TITLE> The eCos Hardware Abstraction Layer (HAL)</TITLE></HEAD>
<BODY BGCOLOR="#ffffff">
<DIV>
<TABLE STYLE="ECOS" WIDTH="98%" BORDER="0" ALIGN="LEFT" CELLPADDING="1"><TR><TH COLSPAN="3" ALIGN="center"><P CLASS="Gotos">The eCos Hardware Abstraction Layer (HAL)</P></TH></TR><TR><TD  ALIGN="center"><P CLASS="Gotos"><A HREF="ecos-ref.2.html">To Contents</A></P></TD><TD  ALIGN="center"><P CLASS="Gotos"><A HREF="ecos-ref.a.html">To&nbsp;previous&nbsp;page</A></P></TD><TD ALIGN="center"><P CLASS="Gotos"><A HREF="ecos-ref.c.html">To&nbsp;next&nbsp;page</A></P></TD></TR></TABLE><P ALIGN="LEFT">&nbsp;</P><BR><BR><HR ALIGN="center"></DIV>
<H2 CLASS="ChapterTitle">
<A NAME="pgfId=1076171">
 </A>
<A NAME="11148">
 </A>
The eCos Hardware Abstraction Layer (HAL)<DIV>
<IMG SRC="botclear.gif">
</DIV>
</H2>
<P CLASS="Body">
<A NAME="pgfId=1036312">
 </A>
This is an initial specification of the <SPAN CLASS="Bold">
eCos</SPAN>
 <A NAME="marker=1085017">
 </A>
Hardware Abstraction Layer (HAL). The HAL abstracts the underlying hardware of a processor architecture and/or the platform to a level sufficient for the <SPAN CLASS="Bold">
eCos</SPAN>
 kernel to be ported onto that platform. </P>
<P CLASS="Body">
<A NAME="pgfId=1036349">
 </A>
<EM CLASS="Emphasis">
Caveat</EM>
 This document is an informal description of the HAL capabilities and is not intended to be full documentation, although it may be used as a source for such. It also describes the HAL as it is currently implemented for the architectures targeted in this release. Further work (described in <A HREF="ecos-ref.b.html#19046" CLASS="XRef">
 Future developments</A>
), is needed to complete it. </P>
<DIV>
<H3 CLASS="Heading1">
<A NAME="pgfId=1036360">
 </A>
Architecture, implementation and platform</H3>
<P CLASS="Body">
<A NAME="pgfId=1036409">
 </A>
We have identified three levels at which the HAL must operate. The <EM CLASS="Emphasis">
architecture</EM>
<A NAME="marker=1085021">
 </A>
 HAL abstracts the basic CPU architecture and includes things like interrupt delivery, context switching, CPU startup etc. The <EM CLASS="Emphasis">
platform</EM>
<A NAME="marker=1085024">
 </A>
 HAL abstracts the properties of the current platform and includes things like platform startup, timer devices, I/O register access and interrupt controllers. The <EM CLASS="Emphasis">
implementation</EM>
<A NAME="marker=1085027">
 </A>
 HAL abstracts properties that lie between these two, such as architecture variants and on-chip devices. The boundaries between these three HAL levels are necessarily blurred.</P>
<P CLASS="Body">
<A NAME="pgfId=1036425">
 </A>
In the current HAL structure, there are separate directory trees for the architectural and platform HALs. The implementation HAL is currently supported in one or other of these by means of conditional compilation depending on how generic a particular feature is expected to be. Thus processor variants are handled in the architectural HAL since they are likely to be generic to several implementations. On-chip devices are handled in the platform HAL, if they impact the kernel, or as proper device drivers (and are thus outside the HAL). </P>
<P CLASS="Body">
<A NAME="pgfId=1036451">
 </A>
The one area where there is significant interaction between these HAL layers is in the interrupt delivery VSR. Here the VSR, which is in the architectural HAL, may need to interrogate an interrupt controller to dispatch the correct ISR. The interrupt controller may be defined by the platform or implementation HAL. This is normally only a few instructions so is currently handled by conditional compilation. If this proves to become unwieldy, a mechanism for including platform code in the architectural HAL may be needed. </P>
</DIV>
<DIV>
<H3 CLASS="Heading1">
<A NAME="pgfId=1036476">
 </A>
General principles</H3>
<P CLASS="Body">
<A NAME="pgfId=1036486">
 </A>
The HAL has been implemented according to the following general principles:</P>
<OL>
<P><LI>
<A NAME="pgfId=1036494">
 </A>
The HAL is implemented in C and assembler, although the <EM CLASS="ProductName1">
eCos</EM>
 kernel is largely implemented in C++. This is to permit the HAL the widest possible applicability.</LI>
<P><LI>
<A NAME="pgfId=1036523">
 </A>
All interfaces to the HAL are implemented by CPP macros. This allows them to be implemented as inline C code, inline assembler or function calls to external C or assembler code. This allows the most efficient implementation to be selected without affecting the interface. It also allows them to be redefined if the platform HAL needs to replace or enhance a definition from the architecture HAL.</LI>
<P><LI>
<A NAME="pgfId=1036547">
 </A>
The HAL provides simple, portable mechanisms for dealing with the hardware of a wide range of architectures and platforms. It is always possible to bypass the HAL and program the hardware directly, but this may lead to a loss of portability. </LI>
</OL>
</DIV>
<DIV>
<H3 CLASS="Heading1">
<A NAME="pgfId=1036566">
 </A>
<A NAME="marker=1085036">
 </A>
<A NAME="32299">
 </A>
Architectural HAL files</H3>
<H3 CLASS="Heading2">
<A NAME="pgfId=1036576">
 </A>
	<CODE CLASS="Code">
hal/ARCH/arch/</CODE>
<EM CLASS="Filename3">
v1_3_x</EM>
<CODE CLASS="Code">
/include/basetype.h</CODE>
</H3>
<P CLASS="Body">
<A NAME="pgfId=1036597">
 </A>
This file defines the properties of the base architecture that are used to compile the portable parts of the kernel. It is included automatically by <CODE CLASS="Code">
cyg/infra/cyg_type.h</CODE>
. The following definitions may be included. </P>
<H4 CLASS="Heading3">
<A NAME="pgfId=1036622">
 </A>
Byte order</H4>
<P CLASS="BodyHang1">
<A NAME="pgfId=1036632">
 </A>
<CODE CLASS="Code">
CYG_BYTEORDER</CODE>
 	</P>
<P CLASS="BodyListFollow">
<A NAME="pgfId=1036673">
 </A>
This defines the byte order of the target and must be set to either <CODE CLASS="Code">
CYG_LSBFIRST</CODE>
 or <CODE CLASS="Code">
CYG_MSBFIRST</CODE>
.</P>
<H4 CLASS="Heading3">
<A NAME="pgfId=1036682">
 </A>
Label translation</H4>
<P CLASS="BodyHang1">
<A NAME="pgfId=1036692">
 </A>
<CODE CLASS="CodeOutput">
CYG_LABEL_NAME(name)</CODE>
 	</P>
<P CLASS="BodyListFollow">
<A NAME="pgfId=1036710">
 </A>
This is a wrapper used in some C and C++ files which specify labels defined in assembly code or the linker script. It need only be defined if the default implementation in <CODE CLASS="Code">
cyg/kernel/ktypes.h</CODE>
, which passes the name argument unaltered, is inadequate. The most usual alternative definition of this macro prepends an underscore to the label name. This depends on the labeling convention of the tool set.</P>
<H4 CLASS="Heading3">
<A NAME="pgfId=1036746">
 </A>
Base types</H4>
<PRE CLASS="CodeExample"><A NAME="pgfId=1036756"> </A>
	cyg_halint8
	cyg_halint16
	cyg_halint32
	cyg_halint64
	cyg_halcount8
	cyg_halcount16
	cyg_halcount32
	cyg_halcount64
	cyg_halbool	</PRE>
<P CLASS="Body">
<A NAME="pgfId=1036825">
 </A>
These macros define the C base types that should be used to define variables of the given size. They only need to be defined if the default types specified in <CODE CLASS="Code">
cyg/infra/cyg_type.h</CODE>
 cannot be used. Note that these are only the base types, they will be composed with <CODE CLASS="Code">
signed</CODE>
 and <CODE CLASS="Code">
unsigned</CODE>
 to form full type specifications.</P>
<H5 CLASS="Heading4">
<A NAME="pgfId=1036836">
 </A>
Atomic types</H5>
<PRE CLASS="CodeExample"><A NAME="pgfId=1036846"> </A>
	cyg_halatomic
	CYG_ATOMIC</PRE>
<P CLASS="Body">
<A NAME="pgfId=1036857">
 </A>
These types are guaranteed to be read or written in a single uninterruptible operation. It is architecture defined what size this type is, but it will be at least a byte. </P>
<H3 CLASS="Heading2">
<A NAME="pgfId=1036872">
 </A>
	<CODE CLASS="Code">
hal/ARCH/arch/</CODE>
<EM CLASS="Filename3">
v1_3_x</EM>
<CODE CLASS="Code">
/include/hal_arch.h</CODE>
</H3>
<P CLASS="Body">
<A NAME="pgfId=1036893">
 </A>
This file contains definitions that are related to the basic architecture of the CPU.</P>
<H4 CLASS="Heading3">
<A NAME="pgfId=1036901">
 </A>
Register save format</H4>
<PRE CLASS="CodeExample"><A NAME="pgfId=1036911"> </A>
typedef struct HAL_SavedRegisters
{
/* architecture-dependent list of registers to be saved */ 
} HAL_SavedRegisters;</PRE>
<P CLASS="Body">
<A NAME="pgfId=1036926">
 </A>
This structure describes the layout of a saved machine state on the stack. Such states are saved during thread context switches, interrupts and exceptions. Different quantities of state may be saved during each of these, but usually a thread context state is a subset of the interrupt state which is itself a subset of an exception state. Where these states are significantly different, this structure should contain a union of the three states.</P>
<H4 CLASS="Heading3">
<A NAME="pgfId=1036948">
 </A>
Thread context initialization</H4>
<PRE CLASS="CodeExample"><A NAME="pgfId=1036958"> </A>
	HAL_THREAD_INIT_CONTEXT( sp, arg, entry, id )</PRE>
<P CLASS="Body">
<A NAME="pgfId=1036966">
 </A>
This macro initializes a thread's context so that it may be switched to by <CODE CLASS="CodeOutput">
HAL_THREAD_SWITCH_CONTEXT()</CODE>
. The arguments are:</P>
<P CLASS="BodyHang1">
<A NAME="pgfId=1036986">
 </A>
sp 	</P>
<P CLASS="BodyListFollow">
<A NAME="pgfId=1037000">
 </A>
A location containing the current value of the thread's stack pointer. This should be a variable or a structure field. The SP value will be read out of here and an adjusted value written back.</P>
<P CLASS="BodyHang1">
<A NAME="pgfId=1037018">
 </A>
arg 	</P>
<P CLASS="BodyListFollow">
<A NAME="pgfId=1037028">
 </A>
A value that is passed as the first argument to the entry point function.</P>
<P CLASS="BodyHang1">
<A NAME="pgfId=1037040">
 </A>
entry 	</P>
<P CLASS="BodyListFollow">
<A NAME="pgfId=1037050">
 </A>
The address of an entry point function. This will be called according the C calling conventions, and the value of <EM CLASS="parameter">
arg</EM>
 will be passed as the first argument.</P>
<P CLASS="BodyHang1">
<A NAME="pgfId=1037076">
 </A>
id 	</P>
<P CLASS="BodyListFollow">
<A NAME="pgfId=1037086">
 </A>
A thread id value. This is only used for debugging purposes, it is ORed into the initialization pattern for unused registers and may be used to help identify the thread from its register dump. The least significant 16 bits of this value should be zero to allow space for a register identifier.</P>
<H4 CLASS="Heading3">
<A NAME="pgfId=1037108">
 </A>
Thread context switching</H4>
<PRE CLASS="CodeExample"><A NAME="pgfId=1037118"> </A>
HAL_THREAD_SWITCH_CONTEXT( from, to )</PRE>
<P CLASS="Body">
<A NAME="pgfId=1037125">
 </A>
This macro implements the thread switch code. The arguments are:</P>
<P CLASS="BodyHang1">
<A NAME="pgfId=1037133">
 </A>
from 	</P>
<P CLASS="BodyListFollow">
<A NAME="pgfId=1037147">
 </A>
A pointer to a location where the stack pointer of the current thread will be stored.</P>
<P CLASS="BodyHang1">
<A NAME="pgfId=1037159">
 </A>
to 	</P>
<P CLASS="BodyListFollow">
<A NAME="pgfId=1037169">
 </A>
A pointer to a location from where the stack pointer of the next thread will be read.</P>
<P CLASS="Body">
<A NAME="pgfId=1037205">
 </A>
The state of the current thread is saved onto its stack, using the current value of the stack pointer, and the address of the saved state placed in <EM CLASS="parameter">
*from.</EM>
 The value in <EM CLASS="parameter">
*to</EM>
 is then read and the state of the new thread is loaded from it.</P>
<P CLASS="Body">
<A NAME="pgfId=1037216">
 </A>
Note that interrupts are not disabled during this process, any interrupts that occur will be delivered onto the stack to which the current value of the CPU stack pointer points. Hence the stack pointer should never be invalid, or loaded with a value that might cause the saved state to become corrupted by an interrupt.</P>
<H4 CLASS="Heading3">
<A NAME="pgfId=1037232">
 </A>
Bit indexing</H4>
<PRE CLASS="CodeExample"><A NAME="pgfId=1037242"> </A>
HAL_LSBIT_INDEX( index, mask)
HAL_MSBIT_INDEX( index, mask)</PRE>
<P CLASS="Body">
<A NAME="pgfId=1037251">
 </A>
These macros place in <EM CLASS="parameter">
index</EM>
 the bit index of the least(most) significant bit in mask. Some architectures have instruction level support for one or other of these operations. If no architectural support is available, then these macros may call C functions to do the job.</P>
<H4 CLASS="Heading3">
<A NAME="pgfId=1037276">
 </A>
Idle thread activity</H4>
<PRE CLASS="CodeExample"><A NAME="pgfId=1037286"> </A>
HAL_IDLE_THREAD_ACTION( count )</PRE>
<P CLASS="Body">
<A NAME="pgfId=1037293">
 </A>
It may be necessary under some circumstances for the HAL to execute code in the kernel idle thread's loop. An example might be to execute a processor halt instruction. This macro provides a portable way of doing this. The argument is a copy of the idle thread's loop counter, and may be used to trigger actions at longer intervals than every loop.</P>
<H4 CLASS="Heading3">
<A NAME="pgfId=1037311">
 </A>
Reorder barrier</H4>
<PRE CLASS="CodeExample"><A NAME="pgfId=1037321"> </A>
HAL_REORDER_BARRIER()</PRE>
<P CLASS="Body">
<A NAME="pgfId=1037328">
 </A>
When optimizing the compiler can reorder code. In some parts of multi-threaded systems, where the order of actions is vital, this can sometimes cause problems. This macro may be inserted into places where reordering should not happen and prevents code being migrated across it by the compiler optimizer. It should be placed between statements that must be executed in the order written in the code. </P>
<H4 CLASS="Heading3">
<A NAME="pgfId=1037352">
 </A>
Breakpoint support</H4>
<PRE CLASS="CodeExample"><A NAME="pgfId=1037362"> </A>
HAL_BREAKPOINT( label )
HAL_BREAKINST
HAL_BREAKINST_SIZE</PRE>
<P CLASS="Body">
<A NAME="pgfId=1037373">
 </A>
These macros provide support for breakpoints. </P>
<P CLASS="Body">
<A NAME="pgfId=1037380">
 </A>
<CODE CLASS="CodeOutput">
HAL_BREAKPOINT()</CODE>
 executes a breakpoint instruction. The label is defined at the breakpoint instruction so that exception code can detect which breakpoint was executed. </P>
<P CLASS="Body">
<A NAME="pgfId=1037417">
 </A>
<EM CLASS="parameter">
HAL_BREAKINST</EM>
 contains the breakpoint instruction code as an integer value. <EM CLASS="parameter">
HAL_BREAKINST_SIZE</EM>
 is the size of that breakpoint instruction in bytes. Together these may be used to place a breakpoint in any code. </P>
<H4 CLASS="Heading3">
<A NAME="pgfId=1037431">
 </A>
GDB support</H4>
<PRE CLASS="CodeExample"><A NAME="pgfId=1037441"> </A>
HAL_THREAD_GET_SAVED_REGISTERS( sp, regs )
HAL_GET_GDB_REGISTERS( regval, regs )
HAL_SET_GDB_REGISTERS( regs, regval ) </PRE>
<P CLASS="Body">
<A NAME="pgfId=1037453">
 </A>
These macros provide support for interfacing GDB to the HAL.</P>
<P CLASS="Body">
<A NAME="pgfId=1037494">
 </A>
<CODE CLASS="CodeOutput">
HAL_THREAD_GET_SAVED_REGISTERS()</CODE>
 extracts a pointer to a <EM CLASS="StructName">
HAL_SavedRegisters</EM>
 structure from a stack pointer value. The stack pointer passed in should be the value saved by the thread context macros. The macro will assign a pointer to the <EM CLASS="StructName">
HAL_SavedRegisters</EM>
 structure to the variable passed as the second argument. </P>
<P CLASS="Body">
<A NAME="pgfId=1037550">
 </A>
<CODE CLASS="CodeOutput">
HAL_GET_GDB_REGISTERS()</CODE>
 translates a register state as saved by the HAL and into a register dump in the format expected by GDB. It takes a pointer to a <EM CLASS="StructName">
HAL_SavedRegisters</EM>
 structure in the <EM CLASS="parameter">
regs</EM>
 argument and a pointer to the memory to contain the GDB register dump in the <EM CLASS="parameter">
regval</EM>
 argument. </P>
<P CLASS="Body">
<A NAME="pgfId=1037606">
 </A>
<CODE CLASS="CodeOutput">
HAL_SET_GDB_REGISTERS()</CODE>
 translates a GDB format register dump into a the format expected by the HAL. It takes a pointer to the memory containing the GDB register dump in the <EM CLASS="parameter">
regval</EM>
 argument and a pointer to a <EM CLASS="StructName">
HAL_SavedRegisters</EM>
 structure in the <EM CLASS="parameter">
regs</EM>
 argument. </P>
<H4 CLASS="Heading3">
<A NAME="pgfId=1037616">
 </A>
Setjmp and longjmp support</H4>
<PRE CLASS="CodeExample"><A NAME="pgfId=1037626"> </A>
CYGARC_JMP_BUF_SIZE
hal_jmp_buf[CYGARC_JMP_BUF_SIZE]
hal_setjmp( hal_jmp_buf env )
hal_longjmp( hal_jmp_buf env, int val )</PRE>
<P CLASS="Body">
<A NAME="pgfId=1037659">
 </A>
These functions provide support for the C <CODE CLASS="CodeOutput">
setjmp()</CODE>
 and <CODE CLASS="CodeOutput">
longjmp()</CODE>
 functions. Refer to the C library for further information.</P>
<H3 CLASS="Heading2">
<A NAME="pgfId=1037670">
 </A>
<CODE CLASS="Code">
hal/ARCH/arch/v1_3_x/include/hal_intr.h</CODE>
</H3>
<P CLASS="Body">
<A NAME="pgfId=1037689">
 </A>
This file contains definitions related to interrupt handling.</P>
<H4 CLASS="Heading3">
<A NAME="pgfId=1037697">
 </A>
Vector numbers</H4>
<PRE CLASS="CodeExample"><A NAME="pgfId=1037707"> </A>
CYGNUM_HAL_VECTOR_XXX
CYGNUM_HAL_VSR_MIN
CYGNUM_HAL_VSR_MAX
CYGNUM_HAL_ISR_MIN
CYGNUM_HAL_ISR_MAX
CYGNUM_HAL_EXCEPTION_MIN
CYGNUM_HAL_EXCEPTION_MAX
CYGNUM_HAL_ISR_COUNT
CYGNUM_HAL_VSR_COUNT
CYGNUM_HAL_EXCEPTION_COUNT </PRE>
<P CLASS="Body">
<A NAME="pgfId=1037732">
 </A>
All possible interrupt and exception vectors should be specified here, together with maximum and minimum values for range checking.</P>
<P CLASS="Body">
<A NAME="pgfId=1037742">
 </A>
There are two ranges of numbers, those for the vector service routines and those for the interrupt service routines. The relationship between these two ranges is undefined, and no equivalence should be assumed if vectors from the two ranges coincide.</P>
<P CLASS="Body">
<A NAME="pgfId=1037756">
 </A>
The VSR vectors correspond to the set of exception vectors that can be delivered by the CPU architecture, many of these will be internal exception traps. The ISR vectors correspond to the set of external interrupts that can be delivered and are usually determined by extra decoding of an interrupt controller by the interrupt VSR.</P>
<P CLASS="Body">
<A NAME="pgfId=1037792">
 </A>
Where a CPU supports synchronous exceptions, the range of such exceptions allowed are defined by <EM CLASS="parameter">
CYGNUM_HAL_EXCEPTION_MIN</EM>
 and <EM CLASS="parameter">
CYGNUM_HAL_EXCEPTION_MAX.</EM>
 The actual exception numbers will normally correspond to the VSR exception range. In future other exceptions generated by the system software (such as stack overflow) may be added.</P>
<P CLASS="Body">
<A NAME="pgfId=1037889">
 </A>
<EM CLASS="parameter">
CYGNUM_HAL_ISR_COUNT,</EM>
 <EM CLASS="parameter">
CYGNUM_HAL_VSR_COUNT</EM>
 and <EM CLASS="parameter">
CYGNUM_HAL_EXCEPTION_COUNT</EM>
 define the number of ISRs, VSRs and EXCEPTIONs respectively for the purposes of defining arrays etc. There might be a translation from the supplied vector numbers into array offsets. Hence <EM CLASS="parameter">
CYGNUM_HAL_XXX_COUNT</EM>
 may not simply be <EM CLASS="parameter">
CYGNUM_HAL_XXX_MAX</EM>
 - <EM CLASS="parameter">
CYGNUM_HAL_XXX_MIN</EM>
 or <EM CLASS="parameter">
CYGNUM_HAL_XXX_MAX</EM>
+1.</P>
<H4 CLASS="Heading3">
<A NAME="pgfId=1037898">
 </A>
Interrupt state control</H4>
<PRE CLASS="CodeExample"><A NAME="pgfId=1037908"> </A>
HAL_DISABLE_INTERRUPTS( old )
HAL_RESTORE_INTERRUPTS( old )
HAL_ENABLE_INTERRUPTS()
HAL_QUERY_INTERRUPTS( state ) </PRE>
<P CLASS="Body">
<A NAME="pgfId=1037921">
 </A>
These macros provide control over the state of the CPUs interrupt mask mechanism. They should normally manipulate a CPU status register to enable and disable interrupt delivery. They should not access an interrupt controller.</P>
<P CLASS="Body">
<A NAME="pgfId=1037954">
 </A>
<CODE CLASS="CodeOutput">
HAL_DISABLE_INTERRUPTS()</CODE>
 disables the delivery of interrupts and stores the original state of the interrupt mask in the variable passed in the <EM CLASS="parameter">
old</EM>
 argument.</P>
<P CLASS="Body">
<A NAME="pgfId=1037980">
 </A>
<CODE CLASS="CodeOutput">
HAL_RESTORE_INTERRUPTS()</CODE>
 restores the state of the interrupt mask to that recorded in <EM CLASS="parameter">
old.</EM>
</P>
<P CLASS="Body">
<A NAME="pgfId=1037989">
 </A>
<CODE CLASS="CodeOutput">
HAL_ENABLE_INTERRUPTS()</CODE>
 simply enables interrupts regardless of the current state of the mask.</P>
<P CLASS="Body">
<A NAME="pgfId=1038023">
 </A>
<CODE CLASS="CodeOutput">
HAL_QUERY_INTERRUPTS()</CODE>
 stores the state of the interrupt mask in the variable passed in the <EM CLASS="parameter">
state</EM>
 argument.</P>
<P CLASS="Body">
<A NAME="pgfId=1038032">
 </A>
It is at the HAL implementer's discretion exactly which interrupts are masked by this mechanism. Where a CPU has more than one interrupt type that may be masked separately (e.g. the ARM's IRQ and FIQ) only those that can raise DSRs need to be masked here. A separate architecture specific mechanism may then be used to control the other interrupt types.</P>
<H4 CLASS="Heading3">
<A NAME="pgfId=1038050">
 </A>
ISR and VSR management</H4>
<PRE CLASS="CodeExample"><A NAME="pgfId=1038060"> </A>
HAL_INTERRUPT_ATTACH( vector, isr, data, object )
HAL_INTERRUPT_DETACH( vector, isr )
HAL_VSR_SET( vector, vsr, poldvsr )
HAL_VSR_GET( vector, pvsr )</PRE>
<P CLASS="Body">
<A NAME="pgfId=1038073">
 </A>
These macros manage the attachment of interrupt and vector service routines to interrupt and exception vectors respectively.</P>
<P CLASS="Body">
<A NAME="pgfId=1038083">
 </A>
<CODE CLASS="CodeOutput">
HAL_INTERRUPT_ATTACH()</CODE>
 attaches the ISR, data pointer and object pointer to the given vector. When an interrupt occurs on this vector the ISR is called using the C calling convention and the vector number and data pointer are passed to it as the first and second arguments respectively.</P>
<P CLASS="Body">
<A NAME="pgfId=1038106">
 </A>
<CODE CLASS="CodeOutput">
HAL_INTERRUPT_DETACH()</CODE>
 detaches the ISR from the vector.</P>
<P CLASS="Body">
<A NAME="pgfId=1038162">
 </A>
<CODE CLASS="CodeOutput">
HAL_VSR_SET()</CODE>
 replaces the VSR attached to the <EM CLASS="parameter">
vector</EM>
 with the replacement supplied in <EM CLASS="parameter">
vsr.</EM>
 The old VSR is returned in the location pointed to by <EM CLASS="parameter">
pvsr.</EM>
</P>
<P CLASS="Body">
<A NAME="pgfId=1038188">
 </A>
<CODE CLASS="CodeOutput">
HAL_VSR_GET()</CODE>
 assigns a copy of the VSR to the location pointed to by <EM CLASS="parameter">
pvsr.</EM>
</P>
<H4 CLASS="Heading3">
<A NAME="pgfId=1038197">
 </A>
Interrupt controller management</H4>
<PRE CLASS="CodeExample"><A NAME="pgfId=1038207"> </A>
HAL_INTERRUPT_MASK( vector )
HAL_INTERRUPT_UNMASK( vector )
HAL_INTERRUPT_ACKNOWLEDGE( vector )
HAL_INTERRUPT_CONFIGURE( vector, level, up )
HAL_INTERRUPT_SET_LEVEL( vector, level )</PRE>
<P CLASS="Body">
<A NAME="pgfId=1038222">
 </A>
These macros exert control over any prioritized interrupt controller that is present. If no priority controller exists, then these macros should be empty.</P>
<P CLASS="Body">
<A NAME="pgfId=1038234">
 </A>
<CODE CLASS="CodeOutput">
HAL_INTERRUPT_MASK()</CODE>
 causes the interrupt associated with the given vector to be blocked.</P>
<P CLASS="Body">
<A NAME="pgfId=1038251">
 </A>
<CODE CLASS="CodeOutput">
HAL_INTERRUPT_UNMASK()</CODE>
 causes the interrupt associated with the given vector to be unblocked.</P>
<P CLASS="Body">
<A NAME="pgfId=1038268">
 </A>
<CODE CLASS="CodeOutput">
HAL_INTERRUPT_ACKNOWLEDGE()</CODE>
 acknowledges the current interrupt from the given vector. This is usually executed from the ISR for this vector when it is prepared to allow further interrupts. Most interrupt controllers need some form of acknowledge action before the next interrupt is allowed through. Executing this macro may cause another interrupt to be delivered. Whether this interrupts the current code depends on the state of the CPU interrupt mask.</P>
<P CLASS="Body">
<A NAME="pgfId=1038296">
 </A>
<CODE CLASS="CodeOutput">
HAL_INTERRUPT_CONFIGURE()</CODE>
 provides control over how an interrupt signal is detected. The arguments are:</P>
<P CLASS="BodyHang1">
<A NAME="pgfId=1038312">
 </A>
vector 	</P>
<P CLASS="BodyListFollow">
<A NAME="pgfId=1038326">
 </A>
The interrupt to be configured.</P>
<P CLASS="BodyHang1">
<A NAME="pgfId=1038336">
 </A>
level 	</P>
<P CLASS="BodyListFollow">
<A NAME="pgfId=1038369">
 </A>
Set to <CODE CLASS="Code">
true</CODE>
 if the interrupt is detected by level, and <CODE CLASS="Code">
false</CODE>
 if it is edge triggered.</P>
<P CLASS="BodyHang1">
<A NAME="pgfId=1038380">
 </A>
up 	</P>
<P CLASS="BodyListFollow">
<A NAME="pgfId=1038440">
 </A>
If the interrupt is set to level detect, then if this is <CODE CLASS="Code">
true</CODE>
 it is detected by a high signal level, and if <CODE CLASS="Code">
false</CODE>
 by a low signal level. If the interrupt is set to edge triggered, then if this is <CODE CLASS="Code">
true</CODE>
 it is triggered by a rising edge and if <CODE CLASS="Code">
false</CODE>
 by a falling edge.</P>
<P CLASS="Body">
<A NAME="pgfId=1038451">
 </A>
<CODE CLASS="CodeOutput">
HAL_INTERRUPT_SET_LEVEL()</CODE>
 provides control over the hardware priority of the interrupt. The arguments are:</P>
<P CLASS="BodyHang1">
<A NAME="pgfId=1038468">
 </A>
vector 	</P>
<P CLASS="BodyListFollow">
<A NAME="pgfId=1038482">
 </A>
The interrupt whose level is to be set.</P>
<P CLASS="BodyHang1">
<A NAME="pgfId=1038492">
 </A>
level 	</P>
<P CLASS="BodyListFollow">
<A NAME="pgfId=1038530">
 </A>
The priority level to which the interrupt is to set. In some architectures the set interrupt level is also used as an interrupt enable/disable. Hence this function and <CODE CLASS="CodeOutput">
HAL_INTERRUPT_MASK()</CODE>
 and <CODE CLASS="CodeOutput">
HAL_INTERRUPT_UNMASK()</CODE>
 may interfere with each other.</P>
<H4 CLASS="Heading3">
<A NAME="pgfId=1038541">
 </A>
Clock control</H4>
<PRE CLASS="CodeExample"><A NAME="pgfId=1038551"> </A>
HAL_CLOCK_INITIALIZE( period )
HAL_CLOCK_RESET( vector, period )
HAL_CLOCK_READ( pvalue )</PRE>
<P CLASS="Body">
<A NAME="pgfId=1038562">
 </A>
These macros provide control over a clock or timer device that may be used by the kernel to provide time-out, delay and scheduling services. The clock is assumed to be implemented by some form of counter that is incremented or decremented by some external source and which raises an interrupt when it reaches zero.</P>
<P CLASS="Body">
<A NAME="pgfId=1038578">
 </A>
<CODE CLASS="CodeOutput">
HAL_CLOCK_INITIALIZE()</CODE>
 initializes the clock device to interrupt at the given period. The period is essentially the value used to initialize the clock counter and must be calculated from the clock frequency and the desired interrupt rate.</P>
<P CLASS="Body">
<A NAME="pgfId=1038599">
 </A>
<CODE CLASS="CodeOutput">
HAL_CLOCK_RESET()</CODE>
 re-initializes the clock to provoke the next interrupt. This macro is only really necessary when the clock device needs to be reset in some way after each interrupt.</P>
<P CLASS="Body">
<A NAME="pgfId=1038637">
 </A>
<CODE CLASS="CodeOutput">
HAL_CLOCK_READ()</CODE>
 reads the current value of the clock counter and puts the value in the location pointed to by <EM CLASS="parameter">
pvalue.</EM>
 The value stored will always be the number of clock ``ticks'' since the last interrupt, and hence ranges between zero and the initial period value.</P>
<H3 CLASS="Heading2">
<A NAME="pgfId=1038652">
 </A>
<CODE CLASS="Code">
hal/ARCH/arch/v1_3_x/include/hal_io.h</CODE>
</H3>
<P CLASS="Body">
<A NAME="pgfId=1038671">
 </A>
This file contains definitions for supporting access to device control registers in an architecture neutral fashion.</P>
<H4 CLASS="Heading3">
<A NAME="pgfId=1038681">
 </A>
Register address</H4>
<PRE CLASS="CodeExample"><A NAME="pgfId=1038691"> </A>
HAL_IO_REGISTER</PRE>
<P CLASS="Body">
<A NAME="pgfId=1038698">
 </A>
This type is used to store the address of an I/O register. It will normally be a memory address, an integer port address or an offset into an I/O space. More complex architectures may need to code an address space plus offset pair into a single word, or may represent it as a structure.</P>
<P CLASS="Body">
<A NAME="pgfId=1038714">
 </A>
Values of variables and constants of this type will usually be supplied by configuration mechanisms.</P>
<H4 CLASS="Heading3">
<A NAME="pgfId=1038722">
 </A>
Register read</H4>
<PRE CLASS="CodeExample"><A NAME="pgfId=1038732"> </A>
HAL_READ_XXX( register, value )
HAL_READ_XXX_VECTOR( register, buffer, count, stride )</PRE>
<P CLASS="Body">
<A NAME="pgfId=1038782">
 </A>
These macros support the reading of I/O registers in various sizes. The XXX component of the name may be UINT8, UINT16, UINT32.</P>
<P CLASS="Body">
<A NAME="pgfId=1038791">
 </A>
<CODE CLASS="CodeOutput">
HAL_READ_XXX()</CODE>
 reads the appropriately sized value from the register and stores it in the variable passed as the second argument.</P>
<P CLASS="Body">
<A NAME="pgfId=1038846">
 </A>
<CODE CLASS="CodeOutput">
HAL_READ_XXX_VECTOR()</CODE>
 reads <EM CLASS="parameter">
count</EM>
 values of the appropriate size into <EM CLASS="parameter">
buffer.</EM>
 The <EM CLASS="parameter">
stride</EM>
 controls how the pointer advances through the register space. A stride of zero will read the same register repeatedly, and a stride of one will read adjacent registers of the given size. Greater strides will step by larger amounts, to allow for sparsely mapped registers for example.</P>
<H4 CLASS="Heading3">
<A NAME="pgfId=1038865">
 </A>
Register write</H4>
<PRE CLASS="CodeExample"><A NAME="pgfId=1038875"> </A>
HAL_WRITE_XXX( register, value )
HAL_WRITE_XXX_VECTOR( register, buffer, count, stride )</PRE>
<P CLASS="Body">
<A NAME="pgfId=1038925">
 </A>
These macros support the writing of I/O registers in various sizes. The <CODE CLASS="Code">
XXX</CODE>
 component of the name may be <CODE CLASS="Code">
UINT8</CODE>
, <CODE CLASS="Code">
UINT16</CODE>
, <CODE CLASS="Code">
UINT32</CODE>
.</P>
<P CLASS="Body">
<A NAME="pgfId=1038934">
 </A>
<CODE CLASS="CodeOutput">
HAL_WRITE_XXX()</CODE>
 writes the appropriately sized value from the variable passed as the second argument stored it in the register.</P>
<P CLASS="Body">
<A NAME="pgfId=1038989">
 </A>
<CODE CLASS="CodeOutput">
HAL_WRITE_XXX_VECTOR()</CODE>
 writes <EM CLASS="parameter">
count</EM>
 values of the appropriate size from <EM CLASS="parameter">
buffer.</EM>
 The <EM CLASS="parameter">
stride</EM>
 controls how the pointer advances through the register space. A stride of zero will write the same register repeatedly, and a stride of one will write adjacent registers of the given size. Greater strides will step by larger amounts, to allow for sparsely mapped registers for example.</P>
<H3 CLASS="Heading2">
<A NAME="pgfId=1039008">
 </A>
<CODE CLASS="Code">
hal/ARCH/arch/v1_3_x/include/hal_cache.h</CODE>
</H3>
<P CLASS="Body">
<A NAME="pgfId=1039027">
 </A>
This file contains definitions for supporting control of the caches on the CPU. </P>
<P CLASS="Body">
<A NAME="pgfId=1039036">
 </A>
There are versions of the macros defined here for both the Data and Instruction caches. these are distinguished by the use of either DCACHE or ICACHE in the macro names. In the following descriptions, XCACHE is also used to stand for either of these. Where there are issues specific to a particular cache, this will be explained in the text. </P>
<P CLASS="Body">
<A NAME="pgfId=1039053">
 </A>
There might be restrictions on the use of some of the macros which it is the user's responsibility to comply with. Such restrictions are documented in the <CODE CLASS="Code">
hal_cache.h</CODE>
 file. </P>
<P CLASS="Body">
<A NAME="pgfId=1039074">
 </A>
Note that destructive cache macros should be used with caution. Preceding a cache invalidation with a cache synchronization is not safe in itself since an interrupt may happen after the synchronization but before the invalidation. This might cause the state of dirty data lines created during the interrupt to be lost. </P>
<P CLASS="Body">
<A NAME="pgfId=1039091">
 </A>
Depending on the architecture's capabilities, it may be possible to temporarily disable the cache while doing the synchronization and invalidation which solves the problem (no new data would be cached during an interrupt). Otherwise it is necessary to disable interrupts while manipulating the cache which may take a long time. </P>
<H4 CLASS="Heading3">
<A NAME="pgfId=1039108">
 </A>
Cache dimensions</H4>
<PRE CLASS="CodeExample"><A NAME="pgfId=1039118"> </A>
HAL_XCACHE_SIZE
HAL_XCACHE_LINE_SIZE
HAL_XCACHE_WAYS
HAL_XCACHE_SETS</PRE>
<P CLASS="Body">
<A NAME="pgfId=1039131">
 </A>
These macros define the size and dimensions of the Instruction and Data caches.</P>
<P CLASS="BodyHang1">
<A NAME="pgfId=1039139">
 </A>
HAL_XCACHE_SIZE 	</P>
<P CLASS="BodyListFollow">
<A NAME="pgfId=1039153">
 </A>
gives the total size of the cache in bytes.</P>
<P CLASS="BodyHang1">
<A NAME="pgfId=1039165">
 </A>
HAL_XCACHE_LINE_SIZE 	</P>
<P CLASS="BodyListFollow">
<A NAME="pgfId=1039175">
 </A>
gives the cache line size in bytes.</P>
<P CLASS="BodyHang1">
<A NAME="pgfId=1039185">
 </A>
HAL_XCACHE_WAYS 	</P>
<P CLASS="BodyListFollow">
<A NAME="pgfId=1039195">
 </A>
gives the number of ways in each set and defines its level of associativity. This would be 1 for a direct mapped cache.</P>
<P CLASS="BodyHang1">
<A NAME="pgfId=1039209">
 </A>
HAL_XCACHE_SETS 	</P>
<P CLASS="BodyListFollow">
<A NAME="pgfId=1039219">
 </A>
gives the number of sets in the cache, and is derived from the previous values.</P>
<H4 CLASS="Heading3">
<A NAME="pgfId=1039231">
 </A>
Global cache control</H4>
<PRE CLASS="CodeExample"><A NAME="pgfId=1039241"> </A>
HAL_XCACHE_ENABLE()
HAL_XCACHE_DISABLE()
HAL_XCACHE_INVALIDATE_ALL()
HAL_XCACHE_SYNC()
HAL_XCACHE_BURST_SIZE( size )
HAL_DCACHE_WRITE_MODE( mode )
HAL_XCACHE_LOCK( base, size )
HAL_XCACHE_UNLOCK( base, size )
HAL_XCACHE_UNLOCK_ALL()</PRE>
<P CLASS="Body">
<A NAME="pgfId=1039264">
 </A>
These macros affect the state of the entire cache, or a large part of it. </P>
<P CLASS="BodyHang1">
<A NAME="pgfId=1039273">
 </A>
HAL_XCACHE_ENABLE() and HAL_XCACHE_DISABLE() 	</P>
<P CLASS="BodyListFollow">
<A NAME="pgfId=1039289">
 </A>
enable and disable the cache.</P>
<P CLASS="BodyHang1">
<A NAME="pgfId=1039299">
 </A>
HAL_XCACHE_INVALIDATE_ALL() 	</P>
  <P CLASS="BodyListFollow"> <A NAME="pgfId=1039309"> </A> causes the entire contents 
    of the cache to be invalidated. Depending on the hardware, this may require 
    the cache to be disabled during the invalidation process. If so, the implementation 
    must use HAL_XCACHE_IS_ENABLED to save and restore the previous state.</P>
<P CLASS="BodyHang1">
<A NAME="pgfId=1039321">
 </A>
HAL_XCACHE_SYNC() 	</P>
<P CLASS="BodyListFollow">
<A NAME="pgfId=1039331">
 </A>
causes the contents of the cache to be brought into synchronization with the contents of memory. In some implementations this may be equivalent to HAL_XCACHE_INVALIDATE_ALL().</P>
<P CLASS="BodyHang1">
<A NAME="pgfId=1039347">
 </A>
HAL_XCACHE_BURST_SIZE() 	</P>
<P CLASS="BodyListFollow">
<A NAME="pgfId=1039357">
 </A>
allows the size of cache to/from memory bursts to be controlled. This macro will only be defined if this functionality is available.</P>
<P CLASS="BodyHang1">
<A NAME="pgfId=1039371">
 </A>
HAL_DCACHE_WRITE_MODE() 	</P>
<P CLASS="BodyListFollow">
<A NAME="pgfId=1039381">
 </A>
controls the way in which data cache lines are written back to memory. There will be definitions for the possible modes. Typical definitions are HAL_DCACHE_WRITEBACK_MODE and HAL_DCACHE_WRITETHRU_MODE. This macro will only be defined if this functionality is available.</P>
<P CLASS="BodyHang1">
<A NAME="pgfId=1039401">
 </A>
HAL_XCACHE_LOCK() 	</P>
<P CLASS="BodyListFollow">
<A NAME="pgfId=1039411">
 </A>
causes data to be locked into the cache. The base and size arguments define the memory region that will be locked into the cache. It is architecture dependent whether more than one locked region is allowed at any one time, and whether this operation causes the cache to cease acting as a cache for addresses outside the region during the duration of the lock. This macro will only be defined if this functionality is available.</P>
<P CLASS="BodyHang1">
<A NAME="pgfId=1039441">
 </A>
HAL_XCACHE_UNLOCK() 	</P>
<P CLASS="BodyListFollow">
<A NAME="pgfId=1039451">
 </A>
cancels the locking of the memory region given. This should normally correspond to a region supplied in a matching lock call. This macro will only be defined if this functionality is available.</P>
<P CLASS="BodyHang1">
<A NAME="pgfId=1039469">
 </A>
HAL_XCACHE_UNLOCK_ALL() 	</P>
<P CLASS="BodyListFollow">
<A NAME="pgfId=1039479">
 </A>
cancels all existing locked memory regions. This may be required as part of the cache initialization on some architectures. This macro will only be defined if this functionality is available.</P>
<H4 CLASS="Heading3">
<A NAME="pgfId=1039497">
 </A>
Cache line control</H4>
<PRE CLASS="CodeExample"><A NAME="pgfId=1039507"> </A>
HAL_DCACHE_ALLOCATE( base , size )
HAL_DCACHE_FLUSH( base , size )
HAL_XCACHE_INVALIDATE( base , size )
HAL_DCACHE_STORE( base , size )
HAL_DCACHE_READ_HINT( base , size )
HAL_DCACHE_WRITE_HINT( base , size )
HAL_DCACHE_ZERO( base , size )</PRE>
<P CLASS="Body">
<A NAME="pgfId=1039526">
 </A>
All of these macros apply a cache operation to all cache lines that match the memory address region defined by the base and size arguments. These macros will only be defined if the described functionality is available. Also, it is not guaranteed that the cache function will only be applied to just the described regions, in some architectures it may be applied to the whole cache.</P>
<P CLASS="BodyHang1">
<A NAME="pgfId=1039544">
 </A>
HAL_DCACHE_ALLOCATE() 	</P>
<P CLASS="BodyListFollow">
<A NAME="pgfId=1039558">
 </A>
allocates lines in the cache for the given region without reading their contents from memory, hence the contents of the lines is undefined. This is useful for preallocating lines which are to be completely overwritten, for example in a block copy operation.</P>
<P CLASS="BodyHang1">
<A NAME="pgfId=1039578">
 </A>
HAL_DCACHE_FLUSH() 	</P>
<P CLASS="BodyListFollow">
<A NAME="pgfId=1039588">
 </A>
invalidates all cache lines in the region after writing any dirty lines to memory.</P>
<P CLASS="BodyHang1">
<A NAME="pgfId=1039600">
 </A>
HAL_XCACHE_INVALIDATE() 	</P>
<P CLASS="BodyListFollow">
<A NAME="pgfId=1039610">
 </A>
invalidates all cache lines in the region. Any dirty lines are invalidated without being written to memory.</P>
<P CLASS="BodyHang1">
<A NAME="pgfId=1039624">
 </A>
HAL_DCACHE_STORE() 	</P>
<P CLASS="BodyListFollow">
<A NAME="pgfId=1039634">
 </A>
writes all dirty lines in the region to memory, but does not invalidate any lines.</P>
<P CLASS="BodyHang1">
<A NAME="pgfId=1039646">
 </A>
HAL_DCACHE_READ_HINT() 	</P>
<P CLASS="BodyListFollow">
<A NAME="pgfId=1039656">
 </A>
hints to the cache that the region is going to be read from in the near future. This may cause the region to be speculatively read into the cache.</P>
<P CLASS="BodyHang1">
<A NAME="pgfId=1039672">
 </A>
HAL_DCACHE_WRITE_HINT() 	</P>
<P CLASS="BodyListFollow">
<A NAME="pgfId=1039682">
 </A>
hints to the cache that the region is going to be written to in the near future. This may have the identical behavior to HAL_DCACHE_READ_HINT().</P>
<P CLASS="BodyHang1">
<A NAME="pgfId=1039698">
 </A>
HAL_DCACHE_ZERO() 	</P>
<P CLASS="BodyListFollow">
<A NAME="pgfId=1039708">
 </A>
allocates and zeroes lines in the cache for the given region without reading memory. This is useful if a large area of memory is to be cleared.</P>
<H3 CLASS="Heading2">
<A NAME="pgfId=1039724">
 </A>
<CODE CLASS="Code">
hal/ARCH/arch/v1_3_x/src/ARCH.ld</CODE>
<A NAME="42603">
 </A>
</H3>
<P CLASS="Body">
<A NAME="pgfId=1039743">
 </A>
This is the architecture specific linker script file. It defines the section types required for the architecture. During preprocessing, the memory layout specified for the chosen platform and startup type is included, defining region, alignment and location parameters for the sections.</P>
<H3 CLASS="Heading2">
<A NAME="pgfId=1039759">
 </A>
<CODE CLASS="Code">
hal/ARCH/arch/v1_3_x/src/vectors.S</CODE>
</H3>
<P CLASS="Body">
<A NAME="pgfId=1039778">
 </A>
This file contains code to deal with exception and interrupt vectors. Since the reset entry point is usually implemented as one of these it also deals with system startup.</P>
<P CLASS="Body">
<A NAME="pgfId=1039788">
 </A>
The exact implementation of this code is under the control of the HAL implementer. So long as it interacts correctly with the macros defined in <CODE CLASS="Code">
hal_intr.h</CODE>
 it may take any form. However, all current implementation follow the same pattern, and there should be a very good reason to break with this. The rest of this section describes how the standard HAL implementation operates.</P>
<P CLASS="Body">
<A NAME="pgfId=1039816">
 </A>
This file usually contains the following sections of code:</P>
<UL>
<P><LI>
<A NAME="pgfId=1039824">
 </A>
Startup and initialization code.</LI>
<P><LI>
<A NAME="pgfId=1039838">
 </A>
Exception delivery.</LI>
<P><LI>
<A NAME="pgfId=1039848">
 </A>
Default handling of synchronous exception.</LI>
<P><LI>
<A NAME="pgfId=1039858">
 </A>
Default handling of interrupts.</LI>
</UL>
<H4 CLASS="Heading3">
<A NAME="pgfId=1039868">
 </A>
<A NAME="marker=1085042">
 </A>
<A NAME="10648">
 </A>
HAL startup</H4>
<P CLASS="Body">
<A NAME="pgfId=1039878">
 </A>
Execution normally begins at the reset vector with the machine in a minimal startup state.</P>
<P CLASS="Body">
<A NAME="pgfId=1039886">
 </A>
The following is a list of the jobs that need to be done in approximately the order in which they should be accomplished. Many of these will not be needed in some configurations.</P>
<UL>
<P><LI>
<A NAME="pgfId=1039898">
 </A>
Initialize various CPU status registers. Most importantly, the CPU interrupt mask should be set to disable interrupts. </LI>
<P><LI>
<A NAME="pgfId=1039917">
 </A>
Set up any CPU memory controller to access RAM, ROM and I/O devices correctly. Until this is done it may not be possible to access RAM. </LI>
<P><LI>
<A NAME="pgfId=1039932">
 </A>
Enable the cache, if it is to be used. This may require enabling the CPU's memory management system since that is often the only way of controlling the cacheability of memory. If this is necessary, a direct one-to-one mapping between physical and virtual memory is most desirable. </LI>
<P><LI>
<A NAME="pgfId=1039955">
 </A>
Set up the stack pointer, this allows subsequent initialization code to make procedure calls. </LI>
<P><LI>
<A NAME="pgfId=1039970">
 </A>
Initialize any global pointer register needed for access to globally defined variables. This allows subsequent initialization code to access global variables. </LI>
<P><LI>
<A NAME="pgfId=1040012">
 </A>
Perform any platform specific initialization. This is best accomplished by calling an initialization routine in <CODE CLASS="Code">
PLATFORM.S</CODE>
 (see <A HREF="ecos-ref.b.html#28396" CLASS="XRef">
 hal/ARCH/PLATFORM/v1_3_x/src/PLATFORM.S</A>
).</LI>
<P><LI>
<A NAME="pgfId=1040043">
 </A>
If the system is starting from ROM, copy the ROM template of the <CODE CLASS="Code">
.data</CODE>
 section out to its correct position in RAM. (See <A HREF="ecos-ref.b.html#42603" CLASS="XRef">
 hal/ARCH/arch/v1_3_x/src/ARCH.ld</A>
). </LI>
<P><LI>
<A NAME="pgfId=1040052">
 </A>
Zero the <CODE CLASS="Code">
BSS</CODE>
 section. </LI>
<P><LI>
<A NAME="pgfId=1040072">
 </A>
Create a suitable C call stack frame. </LI>
<P><LI>
<A NAME="pgfId=1040083">
 </A>
Call <CODE CLASS="CodeOutput">
cyg_hal_invoke_constructors()</CODE>
 to run any static constructors.</LI>
<P><LI>
<A NAME="pgfId=1040128">
 </A>
Call <CODE CLASS="CodeOutput">
cyg_start()</CODE>
. If <CODE CLASS="CodeOutput">
cyg_start()</CODE>
 returns, drop into an infinite loop.</LI>
</UL>
<H4 CLASS="Heading3">
<A NAME="pgfId=1040139">
 </A>
<A NAME="marker=1085055">
 </A>
Vectors and VSRs</H4>
<P CLASS="Body">
<A NAME="pgfId=1040149">
 </A>
The CPU delivers all <A NAME="marker=1085051">
 </A>
exceptions whether synchronous or interrupts to a set of vectors. Depending on the architecture, these may be implemented in a number of different ways. Examples of existing mechanisms are:</P>
<P CLASS="BodyHang1">
<A NAME="pgfId=1040163">
 </A>
PowerPC 	</P>
<P CLASS="BodyListFollow">
<A NAME="pgfId=1040177">
 </A>
Exceptions are vectored to locations 256 bytes apart starting at either zero or <CODE CLASS="Code">
0xFFF00000</CODE>
. There are 16 such vectors defined by the architecture and extra vectors may be defined by specific implementations.</P>
<P CLASS="BodyHang1">
<A NAME="pgfId=1040205">
 </A>
MIPS 	</P>
<P CLASS="BodyListFollow">
<A NAME="pgfId=1040215">
 </A>
All exceptions are vectored to a single address and software is responsible for reading the exception code from a CPU register to discover its true source.</P>
<P CLASS="BodyHang1">
<A NAME="pgfId=1040231">
 </A>
MN10300 	</P>
<P CLASS="BodyListFollow">
<A NAME="pgfId=1040271">
 </A>
External interrupts are vectored to an address stored in one of seven interrupt vector registers. These only supply the lower 16 bits of the address, the upper 16 bits are fixed to <CODE CLASS="Code">
0x4000XXXX</CODE>
. Hence the service routine is constrained to the 64k range starting at <CODE CLASS="Code">
0x40000000</CODE>
.</P>
<P CLASS="BodyHang1">
<A NAME="pgfId=1040280">
 </A>
Pentium 	</P>
<P CLASS="BodyListFollow">
<A NAME="pgfId=1040290">
 </A>
Exceptions are delivered via an Interrupt Descriptor Table (IDT) which is essentially an indirection table indexed by exception type. The IDT may be placed anywhere in memory. In PC hardware the interrupt controller can be programmed to deliver the external interrupts to a block of 16 vectors at any offset in the IDT.</P>
<P CLASS="BodyHang1">
<A NAME="pgfId=1040314">
 </A>
680X0 	</P>
<P CLASS="BodyListFollow">
<A NAME="pgfId=1040324">
 </A>
Exceptions are delivered via an indirection table described by a CPU base register (for X &gt; 0). External interrupts are either delivered via a set of level-specific vectors defined by the architecture, or a vector number may be supplied by the device in which case another entry in the table may be used.</P>
<P CLASS="Body">
<A NAME="pgfId=1040414">
 </A>
The model adopted by the HAL is that VSRs should be easily replaceable with a pointer to an alternative routine. Of the above architectures, only the Pentium and 680X0 allow this directly in the hardware. In the other three, extra software is required. The code attached directly to the vector is a short trampoline that indirects by way of a HAL supplied VSR table to the true VSR. In the PowerPC and MN10300 the table offset is implicit in the vector routine called, for the MIPS the code reads the <EM CLASS="parameter">
cause</EM>
 register and indirects through the appropriate table entry.</P>
<H3 CLASS="Heading2">
<A NAME="pgfId=1040425">
 </A>
<A NAME="marker=1085058">
 </A>
Default exception handling</H3>
<P CLASS="Body">
<A NAME="pgfId=1040435">
 </A>
Most synchronous exception vectors will point to a default exception VSR which is responsible for handling all exceptions in a generic manner.</P>
<P CLASS="Body">
<A NAME="pgfId=1040445">
 </A>
Since most exceptions handled by this VSR are errors (or breakpoints when a program is being debugged), its default behavior should be to save the entire machine state, disable interrupts, and invoke the debugger's entry point, passing it a pointer to the saved state.</P>
<P CLASS="Body">
<A NAME="pgfId=1040459">
 </A>
If the debugger returns then the saved state is restored and the interrupted code resumed. Since the debugger may adjust the saved state while it runs a little care must be taken to restore the state correctly.</P>
<H3 CLASS="Heading2">
<A NAME="pgfId=1040471">
 </A>
<A NAME="marker=1085061">
 </A>
Default interrupt handling</H3>
<P CLASS="Body">
<A NAME="pgfId=1040481">
 </A>
Most external interrupt vectors will point to a default interrupt VSR which decode the actual interrupt being delivered and invokes the appropriate ISR.</P>
<P CLASS="Body">
<A NAME="pgfId=1040491">
 </A>
The default interrupt VSR has a number of responsibilities if it is going to interact with the Kernel cleanly and allow interrupts to cause thread preemption.</P>
<P CLASS="Body">
<A NAME="pgfId=1040503">
 </A>
To support this VSR an ISR vector table is needed. For each valid vector three pointers need to be stored: the ISR, its data pointer and an interrupt object pointer needed by the kernel. It is implementation defined whether these are stored in a single table of triples, or in three separate tables.</P>
<P CLASS="Body">
<A NAME="pgfId=1040519">
 </A>
The VSR should follow the following approximate plan:</P>
<UL>
<P><LI>
<A NAME="pgfId=1040525">
 </A>
Save the CPU state. In non-debug configurations, it may be possible to get away with saving less than the entire machine state.</LI>
<P><LI>
<A NAME="pgfId=1040544">
 </A>
Increment the kernel scheduler lock. This is a static member of the Cyg_Scheduler class. It may be necessary to look at a objdump or assembler listing of <CODE CLASS="Code">
sched.cxx</CODE>
 to discover its mangled label.</LI>
<P><LI>
<A NAME="pgfId=1040570">
 </A>
(Optional) Switch to an interrupt stack if not already running on it. This allows nested interrupts to be delivered without needing every thread to have a stack large enough to take the maximum possible nesting. It is implementation defined how to detect whether this is a nested interrupt.</LI>
<P><LI>
<A NAME="pgfId=1040590">
 </A>
(Optional) Re-enable interrupts to permit nesting.</LI>
<P><LI>
<A NAME="pgfId=1040603">
 </A>
Decode the actual external interrupt being delivered from the interrupt controller. This will yield the ISR vector number.</LI>
<P><LI>
<A NAME="pgfId=1040617">
 </A>
Using the ISR vector number as an index, retrieve the ISR pointer and its data pointer from the ISR vector table.</LI>
<P><LI>
<A NAME="pgfId=1040631">
 </A>
Construct a C call stack frame.</LI>
<P><LI>
<A NAME="pgfId=1040641">
 </A>
Call the ISR, passing the vector number and data pointer. The vector number and a pointer to the saved state should be preserved across this call, preferably by storing them in registers that are defined to be callee-saved by the calling conventions.</LI>
<P><LI>
<A NAME="pgfId=1040660">
 </A>
If this is an un-nested interrupt and a separate interrupt stack is being used, switch back to the interrupted thread's own stack.</LI>
<P><LI>
<A NAME="pgfId=1040675">
 </A>
(Optional) If interrupts were not enabled above, enable them here since the <CODE CLASS="CodeOutput">
interrupt_end()</CODE>
 function must be called with interrupts enabled.</LI>
<P><LI>
<A NAME="pgfId=1040699">
 </A>
Use the saved ISR vector number to get the interrupt object pointer from the ISR vector table.</LI>
<P><LI>
<A NAME="pgfId=1040713">
 </A>
Call <CODE CLASS="CodeOutput">
interrupt_end()</CODE>
 passing it the return value from the ISR, the interrupt object pointer and a pointer to the saved CPU state. This function is implemented by the Kernel and is responsible for finishing off the interrupt handling. Specifically, it may post a DSR depending on the ISR return value, and will decrement the scheduler lock. If the lock is zeroed by this then it may result in a thread context switch. </LI>
<P><LI>
<A NAME="pgfId=1040747">
 </A>
When <CODE CLASS="CodeOutput">
interrupt_end()</CODE>
 returns, restore the machine state and resume execution of the interrupted thread. Depending on the architecture, it may be necessary to disable interrupts again for part of this.</LI>
</UL>
<P CLASS="Body">
<A NAME="pgfId=1040773">
 </A>
The detailed order of these steps may vary slightly depending on the architecture, in particular where interrupts are enabled and disabled.</P>
<H3 CLASS="Heading2">
<A NAME="pgfId=1040783">
 </A>
<CODE CLASS="Code">
hal/ARCH/arch/v1_3_x/src/hal_misc.c</CODE>
</H3>
<P CLASS="Body">
<A NAME="pgfId=1040802">
 </A>
This file contains any miscellaneous functions that are reference by the HAL. Typical functions that might go here are C implementations of the least- and most- significant bit index routines, constructor calling functions such as <CODE CLASS="CodeOutput">
cyg_hal_invoke_constructors()</CODE>
 and support routines for the exception and interrupt vector handling.</P>
<H3 CLASS="Heading2">
<A NAME="pgfId=1040830">
 </A>
<CODE CLASS="Code">
hal/ARCH/PLATFORM/v1_3_x/include/pkgconf/STARTUP.mlt </CODE>
</H3>
<P CLASS="Body">
<A NAME="pgfId=1040849">
 </A>
For each startup type (STARTUP) the memory layout of the sections is defined. This information may be edited using the <SPAN CLASS="Bold">
Configuration Tool</SPAN>
 only. </P>
<H3 CLASS="Heading2">
<A NAME="pgfId=1040869">
 </A>
<CODE CLASS="Code">
hal/ARCH/PLATFORM/v1_3_x/include/pkgconf/STARTUP.ldi </CODE>
</H3>
<P CLASS="Body">
<A NAME="pgfId=1040942">
 </A>
For each startup type (STARTUP) the memory layout of the sections is exported by the <SPAN CLASS="Bold">
Configuration Tool</SPAN>
 as a linker script fragment suitable for inclusion within the architecture-specific linker script file during preprocessing. The linker script fragment to be included is specified by the CYGHWR_MEMORY_LAYOUT_LDI macro in the <CODE CLASS="Code">
system.h</CODE>
 header file. The linker script fragments will be overwritten by the <SPAN CLASS="Bold">
Configuration Tool</SPAN>
 and should only edited manually where the <SPAN CLASS="Bold">
Configuration Tool</SPAN>
 is not in use. </P>
<H3 CLASS="Heading2">
<A NAME="pgfId=1040954">
 </A>
<CODE CLASS="Code">
hal/ARCH/PLATFORM/v1_3_x/include/hal_diag.h </CODE>
</H3>
<P CLASS="Body">
<A NAME="pgfId=1040973">
 </A>
During early development it is useful to have the ability to output messages to some default destination. This may be a memory buffer, a simulator supported output channel, a ROM emulator virtual UART or a serial line. This file defines set of macros that provide simple, polled output for this purpose.</P>
<P CLASS="Body">
<A NAME="pgfId=1040989">
 </A>
<CODE CLASS="CodeOutput">
HAL_DIAG_INIT()</CODE>
 performs any initialization required on the device being used to generate diagnostic output. This may include setting baud rate, and stop, parity and character bits.</P>
<P CLASS="Body">
<A NAME="pgfId=1041008">
 </A>
<CODE CLASS="CodeOutput">
HAL_DIAG_WRITE_CHAR(c)</CODE>
 writes the character supplied to the diagnostic output device.</P>
<P CLASS="Body">
<A NAME="pgfId=1041023">
 </A>
These macros may either implement the required functionality directly, or may call functions elsewhere in the HAL to do it. In the latter case these should be in the file hal/ARCH/PLATFORM/v1_3_x/src/hal_diag.c. </P>
<H3 CLASS="Heading2">
<A NAME="pgfId=1041051">
 </A>
<CODE CLASS="Code">
hal/ARCH/PLATFORM/v1_3_x/src/PLATFORM.S</CODE>
<A NAME="28396">
 </A>
</H3>
<P CLASS="Body">
<A NAME="pgfId=1041070">
 </A>
This is a platform specific assembly code file. Its main purpose is to contain any platform specific startup code called from <CODE CLASS="Code">
vectors.S</CODE>
.</P>
<H3 CLASS="Heading2">
<A NAME="pgfId=1041089">
 </A>
<CODE CLASS="Code">
hal/ARCH/PLATFORM/v1_3_x/src/context.S</CODE>
</H3>
<P CLASS="Body">
<A NAME="pgfId=1041108">
 </A>
If present, this is an assembly code file that contains the code to support thread contexts. The routines to switch between various contexts, as well as initialize a thread context may be present in this file. </P>
<H3 CLASS="Heading2">
<A NAME="pgfId=1041127">
 </A>
<CODE CLASS="Code">
hal/ARCH/PLATFORM/v1_3_x/src/hal_diag.c</CODE>
</H3>
<P CLASS="Body">
<A NAME="pgfId=1041146">
 </A>
If present, this file contains the implementation of the HAL diagnostic support routines.</P>
</DIV>
<DIV>
<H3 CLASS="Heading1">
<A NAME="pgfId=1041154">
 </A>
<A NAME="marker=1085074">
 </A>
<A NAME="19046">
 </A>
Future developments</H3>
<P CLASS="Body">
<A NAME="pgfId=1041164">
 </A>
The HAL is not complete, and will evolve and increase over time. Among the intended developments are:</P>
<UL>
<P><LI>
<A NAME="pgfId=1041172">
 </A>
Common macros for interpreting the contents of a saved machine context. These would allow portable code, such as debug stubs, to extract such values as the program counter and stack pointer from a state without having to interpret a <EM CLASS="StructName">
HAL_SavedRegisters</EM>
 structure directly.</LI>
<P><LI>
<A NAME="pgfId=1041204">
 </A>
Debugging support. Macros to set and clear hardware and software breakpoints. Access to other areas of machine state may also be supported.</LI>
<P><LI>
<A NAME="pgfId=1041218">
 </A>
Floating point support. The saving and restoring of floating point state may need to added to the HAL for those architectures that support it. The exact mechanisms provided need to be defined.</LI>
<P><LI>
<A NAME="pgfId=1041234">
 </A>
Static initialization support. The current HAL provides a dynamic interface to things like thread context initialization and ISR attachment. We also need to be able to define the system entirely statically so that it is ready to go on restart, without needing to run code. This will require extra macros to define these initializations. Such support may have a consequential effect on the current HAL specification.</LI>
<P><LI>
<A NAME="pgfId=1041258">
 </A>
CPU state control. Many CPUs have both kernel and user states. Although it is not intended to run any code in user state for the foreseeable future, it is possible that this may happen eventually. If this is the case, then some minor changes may be needed to the current HAL API to accommodate this. These should mostly be extensions, but minor changes in semantics may also be required.</LI>
<P><LI>
<A NAME="pgfId=1041284">
 </A>
Physical memory management. Many embedded systems have multiple memory areas with varying properties such as base address, size, speed, bus width, cacheability and persistence. An API is needed to support the discovery of this information about the machine's physical memory map.</LI>
<P><LI>
<A NAME="pgfId=1041304">
 </A>
Memory management control. Some embedded processors have a memory management unit. In some cases this must be enabled to allow the cache to be controlled, particularly if different regions of memory must have different caching properties. For some purposes, in some systems, it will be useful to manipulate the MMU settings dynamically.</LI>
<P><LI>
<A NAME="pgfId=1041326">
 </A>
Power management. Macros to access and control any power management mechanisms available on the CPU implementation. These would provide a substrate for a more general power management system that also involved device drivers and other hardware components.</LI>
<P><LI>
<A NAME="pgfId=1041344">
 </A>
Generic serial line macros. Most serial line devices operate in the same way, the only real differences being exactly which bits in which registers perform the standard functions. It should be possible to develop a set of HAL macros that provide basic serial line services such as baud rate setting, enabling interrupts, polling for transmit or receive ready, transmitting and receiving data etc. Given these it should be possible to create a generic serial line device driver that will allow rapid bootstrapping on any new platform. It may be possible to extend this mechanism to other device types.</LI>
<P><LI>
<A NAME="pgfId=1041374">
 </A>
Porting Guide. As the HAL develops it will become important to perform a port to a new architecture in the correct way. </LI>
</UL>
</DIV>
<DIV>
<H3 CLASS="Heading1">
<A NAME="pgfId=1041389">
 </A>
<A NAME="marker=1085083">
 </A>
Kernel porting notes</H3>
<P CLASS="Body">
<A NAME="pgfId=1041399">
 </A>
This section briefly describes the issues involved in porting <SPAN CLASS="Bold">
eCos</SPAN>
 to a new target platform and/or architecture. </P>
<H3 CLASS="Heading2">
<A NAME="pgfId=1041416">
 </A>
Porting overview</H3>
<P CLASS="Body">
<A NAME="pgfId=1041426">
 </A>
The effort required to port <SPAN CLASS="Bold">
eCos</SPAN>
 to a new target varies. Adding support for a new platform/board may require almost no effort, while adding support for a new architecture is more demanding. Additionally, new device drivers may have to be written if there is no existing support for the target's devices. </P>
<P CLASS="Body">
<A NAME="pgfId=1041474">
 </A>
Given that there are usually more target platforms using the same microprocessor or microcontroller, adding <SPAN CLASS="Bold">
eCos</SPAN>
 support for a new target would often be a question of adding support for the new target platform. The architectures supported by <SPAN CLASS="Bold">
eCos</SPAN>
 include the following: ARM7, MIPS (TX39), MN10300, PowerPC (MPC8xx), and SPARClite. </P>
<P CLASS="Body">
<A NAME="pgfId=1041507">
 </A>
Adding a new architecture support is a bigger job and also requires tool support (<SPAN CLASS="BOLD">
GCC,</SPAN>
 <SPAN CLASS="Bold">
GDB</SPAN>
 and binutils) which is a big undertaking in itself. </P>
<H4 CLASS="Heading3">
<A NAME="pgfId=1041519">
 </A>
<A NAME="marker=1085101">
 </A>
Platform support</H4>
<P CLASS="Body">
<A NAME="pgfId=1041529">
 </A>
Adding support for a new platform requires (a subset of): </P>
<OL>
<P><LI>
<A NAME="pgfId=1041536">
 </A>
Adding <EM CLASS="ProductName1">
eCos</EM>
 configuration information. </LI>
<P><LI>
<A NAME="pgfId=1041560">
 </A>
Memory layout description. </LI>
<P><LI>
<A NAME="pgfId=1041571">
 </A>
Memory controller initialization. </LI>
<P><LI>
<A NAME="pgfId=1041582">
 </A>
Interrupt controller handling. </LI>
<P><LI>
<A NAME="pgfId=1041593">
 </A>
Minimal serial device driver for <SPAN CLASS="Bold">
GDB</SPAN>
 interaction and simple diagnostics output. </LI>
<P><LI>
<A NAME="pgfId=1087795">
 </A>
System timer initialization and control.</LI>
<P><LI>
<A NAME="pgfId=1087801">
 </A>
Wallclock driver.</LI>
</OL>
<P CLASS="BodyListFollow">
<A NAME="pgfId=1087807">
 </A>
A wallclock emulation based on the system timer is provided with the standard <SPAN CLASS="Bold">
eCos</SPAN>
 distribution. For those hardware platforms where a battery backed-up clock device or other means of determining actual wallclock time exists, a wallclock driver may be implemented more fully.</P>
<P CLASS="Body">
<A NAME="pgfId=1041616">
 </A>
If the architecture in question is a microcontroller (as opposed to a microprocessor), the job of porting may be as simple as adding configuration information and defining a new memory layout (items one and two). Currently <SPAN CLASS="Bold">
eCos</SPAN>
 supports the following microcontrollers: MN10300, MPC8xx, and TX39. </P>
<H4 CLASS="Heading3">
<A NAME="pgfId=1041641">
 </A>
<A NAME="marker=1085104">
 </A>
Architectural support</H4>
<P CLASS="Body">
<A NAME="pgfId=1041651">
 </A>
Adding support for a new architecture requires: </P>
<OL>
<P><LI>
<A NAME="pgfId=1041658">
 </A>
Adding <EM CLASS="ProductName1">
eCos</EM>
 configuration information. </LI>
<P><LI>
<A NAME="pgfId=1041682">
 </A>
Writing a HAL for the CPU core's register model, interrupt and exception model, cache model, and possibly simple handling for the MMU model. </LI>
<P><LI>
<A NAME="pgfId=1041697">
 </A>
For microcontrollers the HAL should also support the memory controller, interrupt controller and a possible on-MCP serial controller for <SPAN CLASS="Bold">
GDB</SPAN>
 interaction and simple diagnostics output, system timer initialization and control, and a wallclock driver. </LI>
</OL>
<P CLASS="Body">
<A NAME="pgfId=1041725">
 </A>
If there is already support for a member of the same architecture family, the porting job may just consist of adding extra feature support to the existing HAL. Or if the new target architecture only defines a subset of the architecture family, the HAL may need additional configuration control, allowing parts of the existing HAL code to be disabled. </P>
<H3 CLASS="Heading2">
<A NAME="pgfId=1041744">
 </A>
Adding <A NAME="marker=1085108">
 </A>
configuration information</H3>
<P CLASS="Body">
<A NAME="pgfId=1041808">
 </A>
Architecture and platform configuration information resides in two top-level files <CODE CLASS="Code">
targets</CODE>
 and <CODE CLASS="Code">
packages</CODE>
 as well as in architecture and platform specific configuration files (<CODE CLASS="Code">
hal/&lt;arch&gt;/arch/current/include/pkgconf/hal_&lt;arch&gt;.h</CODE>
 and <CODE CLASS="Code">
hal/&lt;arch&gt;/&lt;platform&gt;/current/include/pkgconf/hal_&lt;arch&gt;_&lt;platform&gt;.h.</CODE>
 Furthermore, each platform must define memory layouts for each startup type. </P>
<H5 CLASS="Heading4">
<A NAME="pgfId=1041838">
 </A>
targets</H5>
<P CLASS="Body">
<A NAME="pgfId=1041852">
 </A>
Architecture and platform information must be added to the <CODE CLASS="Code">
targets</CODE>
 file. </P>
<PRE CLASS="CodeExampleWide"><A NAME="pgfId=1041869"> </A>
target powerpc {
    alias               { PowerPC powerpc-eabi }
    command_prefix      powerpc-eabi
    packages            { CYGPKG_HAL_POWERPC }
    hal                 hal/powerpc/arch

    cflags {
        ARCHFLAGS       &quot;-mcpu=860 -D_SOFT_FLOAT&quot;
        ERRFLAGS        &quot;-Wall -Wpointer-arith -Wstrict-prototypes -Winline -Wundef&quot;
        CXXERRFLAGS     &quot;-Woverloaded-virtual&quot;
        LANGFLAGS       &quot;-ffunction-sections -fdata-sections&quot;
        DBGFLAGS        &quot;-g -O2&quot;
        CXXLANGFLAGS    &quot;-fno-rtti -fno-exceptions -fvtable-gc -finit-priority&quot;
        LDLANGFLAGS     &quot;-Wl,--gc-sections -Wl,-static&quot;
    }

    platform cogent {
        alias           { &quot;Cogent board&quot; }
        startup         { ram rom stubs }
        packages        {
            CYGPKG_HAL_POWERPC_COGENT
            CYGPKG_DEVICES_WALLCLOCK
            CYGPKG_DEVICES_WATCHDOG
        }
    }
}           </PRE>
<P CLASS="Body">
<A NAME="pgfId=1042155">
 </A>
<SPAN CLASS="Bold">
pkgconf</SPAN>
<A NAME="marker=1085098">
 </A>
 uses the entries in <CODE CLASS="Code">
targets</CODE>
 to create a build tree. The <EM CLASS="Emphasis">
--target</EM>
 option matches target name (<CODE CLASS="Code">
powerpc</CODE>
) or its aliases (<CODE CLASS="Code">
PowerPC</CODE>
 <CODE CLASS="Code">
powerpc-eabi</CODE>
), just as the <EM CLASS="Emphasis">
--platform</EM>
 option matches platform name (<CODE CLASS="Code">
cogent</CODE>
) or its aliases (<CODE CLASS="Code">
Cogent board</CODE>
). The same is true for the <EM CLASS="Emphasis">
--startup</EM>
 option which matches on the list of valid startup types (<CODE CLASS="Code">
ram</CODE>
, <CODE CLASS="Code">
rom</CODE>
 and <CODE CLASS="Code">
stubs</CODE>
). </P>
<P CLASS="Body">
<A NAME="pgfId=1091513">
 </A>
The <CODE CLASS="Code">
command_prefix</CODE>
 is the prefix on the cross compiler tools, usually the same target triplet used when configuring the tools (<CODE CLASS="Code">
powerpc-eabi</CODE>
). </P>
<P CLASS="Body">
<A NAME="pgfId=1091526">
 </A>
<CODE CLASS="Code">
packages</CODE>
 lists the hardware-related packages that should be enabled if this target is selected. Typically this will just be the appropriate architectural HAL package provided for this architecture (<CODE CLASS="Code">
CYGPKG_HAL_POWERPC</CODE>
), while <CODE CLASS="Code">
hal</CODE>
 specifies the relative path of the source files. </P>
<P CLASS="Body">
<A NAME="pgfId=1091547">
 </A>
<CODE CLASS="Code">
cflags</CODE>
 specifies the compiler and linker flags. The <EM CLASS="Emphasis">
-finit-priority</EM>
 flag is required for proper initialization of <SPAN CLASS="BOLD">
eCos,</SPAN>
 while <EM CLASS="Emphasis">
-ffunction-sections,</EM>
 <EM CLASS="Emphasis">
-fdata-sections,</EM>
 and <EM CLASS="Emphasis">
-Wl,--gc-sections</EM>
 are required to provide linker garbage collection which removes functions and initialized data that are not going to be used. The other <CODE CLASS="Code">
FLAGS</CODE>
 definitions can be set according to preference, taking care to ensure that <CODE CLASS="Code">
ARCHFLAGS</CODE>
 contains all necessary flags for the particular architecture. </P>
<P CLASS="Body">
<A NAME="pgfId=1091580">
 </A>
The <CODE CLASS="Code">
platform</CODE>
 option is used to define a new target platform. There can be several of these for each architecture. The name and startup types are defined using <CODE CLASS="Code">
platform</CODE>
, <CODE CLASS="Code">
alias</CODE>
, and <CODE CLASS="Code">
startup</CODE>
 as described above. <CODE CLASS="Code">
packages</CODE>
 defines the set of packages supported by this particular platform. This set must include the platform HAL package (<CODE CLASS="Code">
CYGPKG_HAL_POWERPC_COGENT</CODE>
), but can name other packages (<CODE CLASS="Code">
CYGPKG_DEVICES_WALLCLOCK</CODE>
 and <CODE CLASS="Code">
CYGPKG_DEVICES_WATCHDOG</CODE>
) which will be enabled per default when selecting this architecture/platform configuration. </P>
<H5 CLASS="Heading4">
<A NAME="pgfId=1042452">
 </A>
packages</H5>
<P CLASS="Body">
<A NAME="pgfId=1042466">
 </A>
The individual packages must be defined in the <CODE CLASS="Code">
packages</CODE>
 file. </P>
<PRE CLASS="CodeExampleWide"><A NAME="pgfId=1042483"> </A>
package CYGPKG_HAL_POWERPC {
        alias           { &quot;PowerPC common HAL&quot; hal_powerpc powerpc_hal powerpc_arch_hal }
        directory       hal/powerpc/arch
        include_dir     cyg/hal
        hardware
}

package CYGPKG_HAL_POWERPC_COGENT {
        alias           { &quot;PowerPC Cogent board support&quot; hal_powerpc_cogent powerpc_cogent_hal }
        directory       hal/powerpc/cogent
        include_dir     cyg/hal
        hardware
} </PRE>
<P CLASS="Body">
<A NAME="pgfId=1042579">
 </A>
These are the definitions of the two packages named in the <CODE CLASS="Code">
targets</CODE>
 file. The aliases can be used with the <EM CLASS="Emphasis">
--disable-</EM>
 and <EM CLASS="Emphasis">
--enable-</EM>
 options of <SPAN CLASS="BOLD">
pkgconf.</SPAN>
 </P>
<P CLASS="Body">
<A NAME="pgfId=1042620">
 </A>
<CODE CLASS="Code">
directory</CODE>
 specifies the relative path of the source files, <CODE CLASS="Code">
include_dir</CODE>
 where header files provided by the package should be copied to in the install directory, and <CODE CLASS="Code">
hardware</CODE>
 specifies that these packages is normally associated with specific hardware and should only be enabled for the appropriate hardware. </P>
<H4 CLASS="Heading3">
<A NAME="pgfId=1042634">
 </A>
<A NAME="marker=1085116">
 </A>
Package-specific configuration</H4>
<P CLASS="Body">
<A NAME="pgfId=1042672">
 </A>
The package-specific configuration files provide presentation information used by the Configuration Tool, dependencies on other packages and of course additional fine-grained options that are architecture and/or target specific. See the two files <CODE CLASS="Code">
hal/powerpc/arch/current/include/pkgconf/hal_powerpc.h</CODE>
 and <CODE CLASS="Code">
hal/powerpc/cogent/current/include/pkgconf/hal_powerpc_cogent.h</CODE>
 for an example. </P>
<H4 CLASS="Heading3">
<A NAME="pgfId=1042696">
 </A>
<A NAME="marker=1085119">
 </A>
Memory layout information</H4>
<P CLASS="Body">
<A NAME="pgfId=1042787">
 </A>
For each target platform must be defined the memory layout used for any given startup type. This information resides in two files <CODE CLASS="Code">
mlt_&lt;arch&gt;_&lt;platform&gt;_&lt;startup&gt;.ldi</CODE>
 and <CODE CLASS="Code">
mlt_&lt;arch&gt;_&lt;platform&gt;_&lt;startup&gt;.mlt</CODE>
 in the directory <CODE CLASS="Code">
hal/&lt;arch&gt;/&lt;platform&gt;/current/include/pkgconf/</CODE>
. The former is a linker script fragment, the latter a file describing the layout for the <SPAN CLASS="Bold">
eCos</SPAN>
 <SPAN CLASS="BOLD">
Configuration Tool.</SPAN>
 </P>
<P CLASS="Body">
<A NAME="pgfId=1042842">
 </A>
Redefining the memory layout can be done in the <SPAN CLASS="BOLD">
Configuration Tool,</SPAN>
 which will create the linker script (the <CODE CLASS="Code">
.ldi</CODE>
 file). It is also possible to do by hand, in which case only the linker script should be created; when no <CODE CLASS="Code">
.mlt</CODE>
 file exists, the <SPAN CLASS="Bold">
Configuration Tool</SPAN>
 will not overwrite the default linker script. </P>
<H3 CLASS="Heading2">
<A NAME="pgfId=1042854">
 </A>
<A NAME="marker=1085122">
 </A>
Platform porting</H3>
<P CLASS="Body">
<A NAME="pgfId=1042864">
 </A>
Platform porting basically consists of making a copy of an existing platform directory and changing the code to match the new platform. The header and source files in the platform directory and their contents are described in <A HREF="ecos-ref.b.html#32299" CLASS="XRef">
 Architectural HAL files</A>
. </P>
<P CLASS="Body">
<A NAME="pgfId=1042907">
 </A>
In particular the configuration information and memory layout need changing, as may the board initialization code and the minimal serial drivers used by <CODE CLASS="Code">
hal_diag.c</CODE>
 and <CODE CLASS="Code">
plf_stub.c</CODE>
. </P>
<P CLASS="Body">
<A NAME="pgfId=1042917">
 </A>
Another useful reference for porting to a new platform is the GNUPro documentation on <CODE CLASS="Code">
gdb</CODE>
 stubs, which can be found at </P>
<P CLASS="Ulink">
<A NAME="pgfId=1091660">
 </A>
<CODE CLASS="Code">
http://www.cygnus.com/pubs/gnupro/3_GNUPro_Debugging_Tools/b_Debugging_with_GDB/gdbThe_GDB_remote_serial_protocol.html</CODE>
</P>
<H3 CLASS="Heading2">
<A NAME="pgfId=1042938">
 </A>
<A NAME="marker=1085125">
 </A>
Architectural porting</H3>
<P CLASS="Body">
<A NAME="pgfId=1043001">
 </A>
The easiest way to make a new architectural port of <SPAN CLASS="Bold">
eCos</SPAN>
 is to make a copy of an existing HAL and change the code to suit the new CPU. This guide will use the PowerPC Cogent board as an example. Wherever <EM CLASS="Emphasis">
powerpc,</EM>
 <EM CLASS="Emphasis">
ppc,</EM>
 or <EM CLASS="Emphasis">
cogent</EM>
 is mentioned in this guide or in the source files, you should replace the strings with appropriate architecture and platform names. There are also a few files that need renaming. </P>
<P CLASS="Body">
<A NAME="pgfId=1043019">
 </A>
If there is simulator support for the new CPU it is possible to test big parts of the HAL and the rest of the <SPAN CLASS="Bold">
eCos</SPAN>
 kernel before a port to a specific platform is attempted. This is an advantage as doing a platform port can cause problems of it own, making it difficult to determine whether the architectural or platform parts of the port in progress are to blame when something is not working properly. </P>
<P CLASS="Body">
<A NAME="pgfId=1043048">
 </A>
When no simulator support exists, the starting point of a port is to produce a minimal GDB stub for the target platform, which will allow code to be downloaded, executed and/or debugged on the board. This guide is based on a situation where no simulator exists as it would be the most likely scenario. </P>
<H4 CLASS="Heading3">
<A NAME="pgfId=1043085">
 </A>
Writing an eCos <A NAME="marker=1085128">
 </A>
GDB stub</H4>
<P CLASS="Body">
<A NAME="pgfId=1043094">
 </A>
A <SPAN CLASS="Bold">
GDB</SPAN>
 stub has both a architectural part (description of the CPUs registers, exception decoding, breakpoint and stepping model, etc.) and a platform part (board initialization and simple serial driver). </P>
<P CLASS="Body">
<A NAME="pgfId=1043154">
 </A>
Writing a stub is a subset of the work required to a full architectural and platform port of the HAL (and thus <SPAN CLASS="Bold">
eCos</SPAN>
). The below sections will be a rough list of minimal requirements for a stub; remaining elements of the files can be fleshed out when extending the port to include full <SPAN CLASS="Bold">
eCos</SPAN>
 functionality. The files and their contents are described in <A HREF="ecos-ref.b.html#32299" CLASS="XRef">
 Architectural HAL files</A>
. </P>
<H3 CLASS="Label">
<A NAME="pgfId=1043163">
 </A>
TIP</H3>
<P CLASS="Note">
<A NAME="pgfId=1043210">
 </A>
If the target board has an existing download stub (not necessarily <SPAN CLASS="Bold">
GDB</SPAN>
 compliant), the <SPAN CLASS="Bold">
GDB</SPAN>
 stub can be tested by changing it to run from RAM rather than ROM (using <CODE CLASS="Code">
ram</CODE>
 startup instead of <CODE CLASS="Code">
stubs</CODE>
 startup). </P>
<P CLASS="Note">
<A NAME="pgfId=1043220">
 </A>
After downloading the stub and starting it, it should be possible to connect <SPAN CLASS="Bold">
GDB</SPAN>
 to the target. Note that trying to download another application may cause the memory of the stub to be overwritten, so some consideration is required when defining the memory layout. </P>
<P CLASS="Note">
<A NAME="pgfId=1085180">
 </A>
If the target board does not have an existing download stub and requires a new EPROM to be burned for each testing cycle, you may want to start with writing a <EM CLASS="Emphasis">
minimal</EM>
 stub which can only be used for downloading data to the target board. </P>
<P CLASS="Note">
<A NAME="pgfId=1085200">
 </A>
For this purpose you can skip the exception support code in <CODE CLASS="Code">
vectors.S</CODE>
 and hack <CODE CLASS="Code">
hal/common/current/src/stubrom/stubrom.c</CODE>
 to jump directly to the stub code without using a breakpoint. </P>
<H3 CLASS="Label">
<A NAME="pgfId=1091200">
 </A>
TIP</H3>
<P CLASS="Note">
<A NAME="pgfId=1091217">
 </A>
While working on improving the stub code or other parts of the HAL you can use the simple diagnostics output functions (by way of diag_printf) as a crude way of providing debugging feedback until you get full <SPAN CLASS="Bold">
GDB</SPAN>
 stub functionality in place. </P>
<H3 CLASS="Label">
<A NAME="pgfId=1091320">
 </A>
TIP</H3>
<P CLASS="Note">
<A NAME="pgfId=1091344">
 </A>
A good way of debugging the stub itself is to enable remote debugging in <SPAN CLASS="Bold">
GDB</SPAN>
 (<CODE CLASS="Code">
set remotedebug 1</CODE>
). This makes <SPAN CLASS="Bold">
GDB</SPAN>
 display any communication between itself and the stub on the target. Consult the <SPAN CLASS="Bold">
GDB</SPAN>
 file <CODE CLASS="Code">
remote.c</CODE>
 for details on the protocol. </P>
<H5 CLASS="Heading4">
<A NAME="pgfId=1091299">
 </A>
Architecture files</H5>
<P CLASS="BodyHang1">
<A NAME="pgfId=1043410">
 </A>
<CODE CLASS="Code">
include/basetype.h</CODE>
 	</P>
<P CLASS="BodyListFollow">
<A NAME="pgfId=1043432">
 </A>
Implement in full. Little effort. </P>
<P CLASS="BodyHang1">
<A NAME="pgfId=1043443">
 </A>
<CODE CLASS="Code">
include/hal_arch.h</CODE>
 	</P>
<P CLASS="BodyListFollow">
<A NAME="pgfId=1043523">
 </A>
The following macros are required for the stub: <CODE CLASS="Code">
HAL_SavedRegisters</CODE>
, <CODE CLASS="Code">
HAL_BREAKPOINT</CODE>
, <CODE CLASS="Code">
HAL_BREAKINST</CODE>
, <CODE CLASS="Code">
HAL_BREAKINST_SIZE</CODE>
, <CODE CLASS="CodeOutput">
HAL_GET_GDB_REGISTERS</CODE>
, and <CODE CLASS="CodeOutput">
HAL_SET_GDB_REGISTERS</CODE>
. </P>
<P CLASS="BodyHang1">
<A NAME="pgfId=1043533">
 </A>
<CODE CLASS="Code">
include/hal_cache.h</CODE>
 	</P>
<P CLASS="BodyListFollow">
<A NAME="pgfId=1043547">
 </A>
The macros in this file can be left as empty if caches are kept disabled. This is definitely the best way to start porting, avoiding cache problems entirely. The cache is not of much use until <SPAN CLASS="Bold">
eCos</SPAN>
 can be used with applications anyway. </P>
<P CLASS="BodyHang1">
<A NAME="pgfId=1043575">
 </A>
<CODE CLASS="Code">
include/hal_intr.h</CODE>
 	</P>
<P CLASS="BodyListFollow">
<A NAME="pgfId=1043589">
 </A>
It is necessary to implement enough exception handling code to properly handle breakpoints. </P>
<P CLASS="BodyListFollow">
<A NAME="pgfId=1043602">
 </A>
As the porting job progresses, asynchronous break points (CYGDBG_HAL_DEBUG_GDB_BREAK_SUPPORT) may come in handy. These require a minimal interrupt system to be in place. </P>
<P CLASS="BodyHang1">
<A NAME="pgfId=1043615">
 </A>
<CODE CLASS="Code">
include/hal_io.h</CODE>
 	</P>
<P CLASS="BodyListFollow">
<A NAME="pgfId=1043629">
 </A>
Should be fully implemented. Usually zero effort. </P>
<P CLASS="BodyHang1">
<A NAME="pgfId=1043640">
 </A>
<CODE CLASS="Code">
include/&lt;arch&gt;_regs.h</CODE>
 	</P>
<P CLASS="BodyListFollow">
<A NAME="pgfId=1043658">
 </A>
Can be filled in piecemeal as the porting job progresses. </P>
<P CLASS="BodyHang1">
<A NAME="pgfId=1043669">
 </A>
<CODE CLASS="Code">
include/&lt;arch&gt;_stub.h</CODE>
 	</P>
<P CLASS="BodyListFollow">
<A NAME="pgfId=1043776">
 </A>
Redefine <CODE CLASS="Code">
NUMREGS</CODE>
, <CODE CLASS="Code">
REGSIZE</CODE>
, and <CODE CLASS="Code">
regnames</CODE>
 using the same register layout as <SPAN CLASS="BOLD">
GDB.</SPAN>
 The register definitions can be found in the <CODE CLASS="Code">
config/&lt;arch&gt;/tm-&lt;arch&gt;.h</CODE>
 file in the <SPAN CLASS="Bold">
GDB</SPAN>
 sources. The definitions for the PowerPC were found in <CODE CLASS="Code">
config/rs6000/tm-rs6000.h</CODE>
. </P>
<P CLASS="BodyListFollow">
<A NAME="pgfId=1043832">
 </A>
Discrepancies between what <SPAN CLASS="Bold">
GDB</SPAN>
 expects and what is defined in the stub will show up when you use the <CODE CLASS="Code">
info reg</CODE>
 command in <SPAN CLASS="Bold">
GDB</SPAN>
 (and know what the register contents on the target should be). Be careful to get the <CODE CLASS="Code">
REGSIZE</CODE>
 macro defined correctly. </P>
<P CLASS="BodyHang1">
<A NAME="pgfId=1043844">
 </A>
<CODE CLASS="Code">
src/context.c</CODE>
 	</P>
<P CLASS="BodyListFollow">
<A NAME="pgfId=1043858">
 </A>
Nothing here required by the stub. </P>
<P CLASS="BodyHang1">
<A NAME="pgfId=1043869">
 </A>
<CODE CLASS="Code">
src/hal_misc.c</CODE>
 	</P>
<P CLASS="BodyListFollow">
<A NAME="pgfId=1043920">
 </A>
The two functions <CODE CLASS="CodeOutput">
cyg_hal_invoke_constructors</CODE>
 and <CODE CLASS="CodeOutput">
cyg_hal_exception_handler</CODE>
 must be implemented. The former is the same on most architectures and the latter just needs to call <CODE CLASS="CodeOutput">
__handle_exception</CODE>
. </P>
<P CLASS="BodyHang1">
<A NAME="pgfId=1043930">
 </A>
<CODE CLASS="Code">
src/&lt;arch&gt;.ld</CODE>
 	</P>
<P CLASS="BodyListFollow">
<A NAME="pgfId=1043948">
 </A>
The linker script must be properly defined. </P>
<P CLASS="BodyHang1">
<A NAME="pgfId=1043959">
 </A>
<CODE CLASS="Code">
src/&lt;arch&gt;_stub.c</CODE>
 	</P>
<P CLASS="BodyListFollow">
<A NAME="pgfId=1043977">
 </A>
This file must be fully implemented. </P>
<P CLASS="BodyListFollow">
<A NAME="pgfId=1043988">
 </A>
<CODE CLASS="CodeOutput">
__computeSignal</CODE>
 can be defined to just return SIGTRAP as a minimal implementation. Proper signal decoding may help debugging though. </P>
<P CLASS="BodyListFollow">
<A NAME="pgfId=1044008">
 </A>
Single-stepping can be implemented in one of two ways. Some architectures (such as the PowerPC) have hardware support to control single-stepping making it simple to implement. Other architectures require use of breakpoints to implement the functionality, which requires instruction decoding. Examples of the latter approach can be found in the ARM, MIPS, and MN10300 stubs. Implementing instruction decoding obviously requires more effort. </P>
<P CLASS="BodyHang1">
<A NAME="pgfId=1044035">
 </A>
<CODE CLASS="Code">
src/vectors.S</CODE>
 	</P>
<P CLASS="BodyListFollow">
<A NAME="pgfId=1044049">
 </A>
This is the core file of the architecture HAL. It is hard to define what the minimal implementation requirements are for stubs to work. It may be worth and/or necessary to do a full implementation of this file to start with, but here are some pointers anyway. </P>
<P CLASS="BodyListFollow">
<A NAME="pgfId=1044068">
 </A>
<CODE CLASS="Code">
_start</CODE>
 as defined for the PowerPC is about the minimum requirement, but you can ignore MMU and cache setup while working on the stub. </P>
<P CLASS="BodyListFollow">
<A NAME="pgfId=1044127">
 </A>
<CODE CLASS="Code">
__default_exception_vsr</CODE>
 and <CODE CLASS="Code">
restore_state</CODE>
 must preserve enough state to allow breakpoints without trashing CPU state for the application code. If you need asynchronous <SPAN CLASS="Bold">
GDB</SPAN>
 breakpoints <CODE CLASS="Code">
__default_interrupt_vsr</CODE>
 must also be defined well enough to allow interrupts without trashing the CPU state of the interrupted application code. </P>
<P CLASS="BodyListFollow">
<A NAME="pgfId=1044143">
 </A>
Assorted tables also need to be defined, depending on how much of the exception and interrupt handlers is implemented. </P>
<P CLASS="Body">
<A NAME="pgfId=1044152">
 </A>
 </P>
<H5 CLASS="Heading4">
<A NAME="pgfId=1044157">
 </A>
Platform files</H5>
<P CLASS="BodyHang1">
<A NAME="pgfId=1044167">
 </A>
<CODE CLASS="Code">
include/hal_diag.h</CODE>
 	</P>
<P CLASS="BodyListFollow">
<A NAME="pgfId=1044189">
 </A>
Shouldn't require any changes. </P>
<P CLASS="BodyHang1">
<A NAME="pgfId=1044200">
 </A>
<CODE CLASS="Code">
include/plf_stub.h</CODE>
 	</P>
<P CLASS="BodyListFollow">
<A NAME="pgfId=1044214">
 </A>
This file provides the interface to the platform stub functions for the <CODE CLASS="Code">
generic-stub.c</CODE>
 code. </P>
<P CLASS="BodyListFollow">
<A NAME="pgfId=1044293">
 </A>
The minimal stub (no asynchronous <SPAN CLASS="Bold">
GDB</SPAN>
 breakpoints) only requires <CODE CLASS="Code">
HAL_STUB_PLATFORM_INIT_SERIAL</CODE>
, <CODE CLASS="Code">
HAL_STUB_PLATFORM_GET_CHAR</CODE>
, and <CODE CLASS="Code">
HAL_STUB_PLATFORM_PUT_CHAR</CODE>
 and the matching functions in <CODE CLASS="Code">
plf_stub.c</CODE>
 to be defined. </P>
<P CLASS="BodyHang1">
<A NAME="pgfId=1044303">
 </A>
<CODE CLASS="Code">
src/&lt;platform&gt;.c</CODE>
 	</P>
<P CLASS="BodyListFollow">
<A NAME="pgfId=1044321">
 </A>
This file defines <CODE CLASS="Code">
hal_hardware_init</CODE>
 which takes care of initializing the board. For the Cogent board this includes watchdog initialization and memory controller setup. Other boards may have different requirements. </P>
<P CLASS="BodyHang1">
<A NAME="pgfId=1044350">
 </A>
<CODE CLASS="Code">
src/hal_diag.c</CODE>
 	</P>
<P CLASS="BodyListFollow">
<A NAME="pgfId=1044399">
 </A>
This file defines three functions that provide simple diagnostics output; <CODE CLASS="Code">
hal_diag_init</CODE>
, <CODE CLASS="Code">
hal_diag_write_char</CODE>
, and <CODE CLASS="Code">
hal_diag_read_char</CODE>
. Normally these would implement a very simple serial driver. They could also address an LCD or just some LEDs. </P>
<P CLASS="BodyListFollow">
<A NAME="pgfId=1044434">
 </A>
The simple serial driver for the Cogent board is implemented in a separate file, <CODE CLASS="Code">
cma_ser.c</CODE>
, which is shared with the <CODE CLASS="Code">
plf_stub.c</CODE>
 file. </P>
<P CLASS="BodyHang1">
<A NAME="pgfId=1044444">
 </A>
<CODE CLASS="Code">
src/plf_stub.c</CODE>
 	</P>
<P CLASS="BodyListFollow">
<A NAME="pgfId=1044532">
 </A>
This file implements the serial driver needed by the <SPAN CLASS="Bold">
GDB</SPAN>
 stub. The minimal stub only requires <CODE CLASS="CodeOutput">
init</CODE>
, <CODE CLASS="CodeOutput">
putc</CODE>
, and <CODE CLASS="CodeOutput">
getc</CODE>
 functions. A stub which supports asynchronous breakpoints also requires functions to handle serial interrupts. For example implementations see <CODE CLASS="Code">
cma_ser.c</CODE>
 or the <CODE CLASS="Code">
plf_stub.c</CODE>
 file for the MN10300 stdeval1 board. </P>
<P CLASS="Body">
<A NAME="pgfId=1044542">
 </A>
 </P>
<H4 CLASS="Heading3">
<A NAME="pgfId=1044547">
 </A>
<A NAME="marker=1085269">
 </A>
Building the stub</H4>
<OL>
<P><LI>
<A NAME="pgfId=1044582">
 </A>
Prepare a build directory, configuring <EM CLASS="ProductName1">
eCos</EM>
<EM CLASS="Para1">
 for </EM>
<CODE CLASS="Code">
stubs</CODE>
 startup. </LI>
<P><LI>
<A NAME="pgfId=1044646">
 </A>
Disable all packages except <EM CLASS="ProductName">
eCos</EM>
<EM CLASS="Emphasis">
 common HAL,</EM>
 <EM CLASS="Emphasis">
infrastructure,</EM>
 <EM CLASS="Emphasis">
&lt;arch&gt; common HAL,</EM>
 and <EM CLASS="Emphasis">
&lt;arch&gt; &lt;platform&gt; board support.</EM>
 </LI>
<P><LI>
<A NAME="pgfId=1044687">
 </A>
Disable the HAL common options <EM CLASS="Emphasis">
CYGFUN_HAL_COMMON_KERNEL_SUPPORT</EM>
 and <EM CLASS="Emphasis">
CYGDBG_HAL_DEBUG_GDB_THREAD_SUPPORT.</EM>
 </LI>
</OL>
<P CLASS="Body">
<A NAME="pgfId=1044697">
 </A>
Enable the HAL common option <EM CLASS="Emphasis">
CYGDBG_HAL_DEBUG_GDB_INCLUDE_STUBS.</EM>
 </P>
<OL>
<P><LI>
<A NAME="pgfId=1044714">
 </A>
Build libtarget. </LI>
<P><LI>
<A NAME="pgfId=1044793">
 </A>
Change to the directory <CODE CLASS="Code">
hal/common/current/src/stubrom</CODE>
 and type <CODE CLASS="Code">
make</CODE>
. This should result in an <SPAN CLASS="Bold">
eCos</SPAN>
 <SPAN CLASS="Bold">
GDB</SPAN>
 stub image file called <CODE CLASS="Code">
stubrom</CODE>
. This can be converted to SRECord or binary format (using <CODE CLASS="Code">
objcopy</CODE>
) which can be used by EPROM burner or PROM emulator software. </LI>
</OL>
<H4 CLASS="Heading3">
<A NAME="pgfId=1044805">
 </A>
Filling in the blanks</H4>
<P CLASS="Body">
<A NAME="pgfId=1044815">
 </A>
When a <SPAN CLASS="Bold">
GDB</SPAN>
 stub has been written and is working, finishing the HAL port is pretty much a question of completing the header files and writing the functions that were not needed for the stub. </P>
<TABLE>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
</TD>
</TR>
</TABLE>
</DIV>
<HR ALIGN="center"><TABLE STYLE="ECOS" WIDTH="98%" BORDER="0" ALIGN="LEFT" CELLPADDING="1"><TR><TH COLSPAN="3" ALIGN="center"><P CLASS="Gotos">The eCos Hardware Abstraction Layer (HAL)</P></TH></TR><TR><TD  ALIGN="center"><P CLASS="Gotos"><A HREF="ecos-ref.2.html">To Contents</A></P></TD><TD  ALIGN="center"><P CLASS="Gotos"><A HREF="ecos-ref.a.html">To&nbsp;previous&nbsp;page</A></P></TD><TD  ALIGN="center"><P CLASS="Gotos"><A HREF="ecos-ref.c.html">To&nbsp;next&nbsp;page</A></P></TD></TR></TABLE></BODY>
</HTML>
