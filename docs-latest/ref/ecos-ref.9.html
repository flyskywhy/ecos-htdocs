<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML EXPERIMENTAL 970324//EN">
<HTML>
<HEAD><!--version 1.3.4/Thur May 4 2000-->
<META NAME="GENERATOR" CONTENT="Adobe FrameMaker 5.5/HTML Export Filter">
<LINK REL="STYLESHEET" HREF="cygnus.css">
<TITLE> Native kernel C language API</TITLE></HEAD>
<BODY BGCOLOR="#ffffff">
<DIV>
<TABLE STYLE="ECOS" WIDTH="98%" BORDER="0" ALIGN="LEFT" CELLPADDING="1"><TR><TH COLSPAN="3" ALIGN="center"><P CLASS="Gotos">Native kernel C language API</P></TH></TR><TR><TD  ALIGN="center"><P CLASS="Gotos"><A HREF="ecos-ref.2.html">To Contents</A></P></TD><TD  ALIGN="center"><P CLASS="Gotos"><A HREF="ecos-ref.8.html">To&nbsp;previous&nbsp;page</A></P></TD><TD ALIGN="center"><P CLASS="Gotos"><A HREF="ecos-ref.a.html">To&nbsp;next&nbsp;page</A></P></TD></TR></TABLE><P ALIGN="LEFT">&nbsp;</P><BR><BR><HR ALIGN="center"></DIV>
<H2 CLASS="ChapterTitle">
<A NAME="pgfId=1076163">
 </A>
Native kernel C language API<DIV>
<IMG SRC="botclear.gif">
</DIV>
</H2>
<P CLASS="Body">
<A NAME="pgfId=1020566">
 </A>
The <SPAN CLASS="Bold">
eCos</SPAN>
 kernel, like many other real-time kernels, is a library to which the programmer links an application. System calls resemble library API calls, and there is no trap mechanism to switch from user to system mode. </P>
<P CLASS="Body">
<A NAME="pgfId=1020609">
 </A>
We present here the <SPAN CLASS="Bold">
eCos</SPAN>
 <A NAME="marker=1084682">
 </A>
kernel API and the APIs for other kernels provided as compatibility layers on top of <SPAN CLASS="BOLD">
eCos.</SPAN>
 </P>
<P CLASS="Body">
<A NAME="pgfId=1020619">
 </A>
Since this API sits on top of a configurable system, the semantics are only weakly defined. The exact semantics and even the API itself depend on the configuration. For example if returned error codes were supported this would change the prototype of the functions. The semantics given in this chapter describe the default configuration.</P>
<P CLASS="Body">
<A NAME="pgfId=1020639">
 </A>
As mentioned above, all source files which use the kernel C API should have the following <CODE CLASS="Code">
#include</CODE>
 statement:</P>
<PRE CLASS="CodeExample"><A NAME="pgfId=1020657"> </A>
#include &lt;cyg/kernel/kapi.h&gt;</PRE>
<P CLASS="Body">
<A NAME="pgfId=1020666">
 </A>
at the head of the file. </P>
<DIV>
<H3 CLASS="Heading1">
<A NAME="pgfId=1020673">
 </A>
Types used in programming eCos</H3>
<P CLASS="Body">
<A NAME="pgfId=1020710">
 </A>
We now describe the types defined for use with <SPAN CLASS="BOLD">
eCos.</SPAN>
 These are available to programs that include <CODE CLASS="Code">
kapi.h</CODE>
. </P>
<P CLASS="Body">
<A NAME="pgfId=1020720">
 </A>
Most of these types are meant to be <EM CLASS="Emphasis">
opaque</EM>
 -- in other words, programmers do not need to know (and probably should not know) how they are defined. But the types that are numeric are marked, since it can be useful to use comparison operators.</P>
<P CLASS="Body">
<A NAME="pgfId=1020746">
 </A>
The definitions for these types can be found in the installed tree, in the file <CODE CLASS="Code">
include/cyg/kernel/kapi.h</CODE>
. </P>
<P CLASS="Body">
<A NAME="pgfId=1020765">
 </A>
The <SPAN CLASS="Bold">
eCos</SPAN>
 kernel uses the following naming convention for types: </P>
<UL>
<P><LI>
<A NAME="pgfId=1020783">
 </A>
Types that can be treated as completely opaque usually have _t suffix.</LI>
<P><LI>
<A NAME="pgfId=1020808">
 </A>
Types for which it is necessary to know the implementation do not have a _t suffix.</LI>
</UL>
<H3 CLASS="Heading2">
<A NAME="pgfId=1020830">
 </A>
<A NAME="marker=1084702">
 </A>
cyg_addrword_t</H3>
<P CLASS="Body">
<A NAME="pgfId=1020844">
 </A>
A type which is large enough to store the larger of an address and a machine word. This is used for convenience when a function is passed data which could be either a pointer to a block of data or a single word. </P>
<H3 CLASS="Heading2">
<A NAME="pgfId=1020859">
 </A>
<A NAME="marker=1084707">
 </A>
cyg_handle_t</H3>
<P CLASS="Body">
<A NAME="pgfId=1020903">
 </A>
A <EM CLASS="Emphasis">
handle</EM>
 is a variable used to refer to <SPAN CLASS="Bold">
eCos</SPAN>
 system objects (such as a thread or an alarm). Most <SPAN CLASS="Bold">
eCos</SPAN>
 system calls that create system objects will return a handle that is used to access that object from then on.</P>
<H3 CLASS="Heading2">
<A NAME="pgfId=1020916">
 </A>
<A NAME="marker=1084712">
 </A>
cyg_priority_t</H3>
<P CLASS="Body">
<A NAME="pgfId=1020930">
 </A>
A numeric type used to represent the priority of a thread, or the priority of an interrupt level. A lower number means a higher (i.e. more important) priority thread. </P>
<H3 CLASS="Heading2">
<A NAME="pgfId=1020943">
 </A>
<A NAME="marker=1084715">
 </A>
cyg_code_t</H3>
<P CLASS="Body">
<A NAME="pgfId=1020957">
 </A>
A numeric type used for various error or status codes, such as exception numbers.</P>
<H3 CLASS="Heading2">
<A NAME="pgfId=1020965">
 </A>
<A NAME="marker=1084718">
 </A>
cyg_vector_t</H3>
<P CLASS="Body">
<A NAME="pgfId=1020979">
 </A>
A numeric type used to identify an interrupt vector. Its value is called the interrupt vector <EM CLASS="Emphasis">
id.</EM>
 This type is used for both ISR vector ids and VSR vector ids.</P>
<H3 CLASS="Heading2">
<A NAME="pgfId=1021001">
 </A>
<A NAME="marker=1084721">
 </A>
cyg_tick_count_t</H3>
<P CLASS="Body">
<A NAME="pgfId=1021015">
 </A>
A numeric type used to count counter ticks. The resolution and other details regarding tick quantities depend on the configuration, but this is a 64 bit type, and no matter what configuration is chosen it should still last for centuries before it overflows.</P>
<H3 CLASS="Heading2">
<A NAME="pgfId=1021031">
 </A>
<A NAME="marker=1084724">
 </A>
cyg_bool_t</H3>
<P CLASS="Body">
<A NAME="pgfId=1021045">
 </A>
A boolean type whose values can be false (0) or true (1).</P>
<H3 CLASS="Heading2">
<A NAME="pgfId=1021053">
 </A>
<A NAME="marker=1084727">
 </A>
cyg_thread_entry_t</H3>
<P CLASS="Body">
<A NAME="pgfId=1021067">
 </A>
A function type for functions that are entry points for threads. It is used in the thread creation call <CODE CLASS="CodeOutput">
cyg_thread_create()</CODE>
.</P>
<P CLASS="Body">
<A NAME="pgfId=1021087">
 </A>
To help write thread entry point functions, here is how cyg_thread_entry_t is defined:</P>
<PRE CLASS="CodeExample"><A NAME="pgfId=1021103"> </A>
typedef void cyg_thread_entry_t(void *);</PRE>
<P CLASS="Body">
<A NAME="pgfId=1021110">
 </A>
Examples of thread functions can be found in the programming tutorial in <EM CLASS="Emphasis">
Getting Started with </EM>
<EM CLASS="ProductName">
eCos.</EM>
 </P>
<H3 CLASS="Heading2">
<A NAME="pgfId=1021135">
 </A>
<A NAME="marker=1084730">
 </A>
cyg_exception_handler_t</H3>
<P CLASS="Body">
<A NAME="pgfId=1021149">
 </A>
A function type used for installing exception handlers. It is defined as: </P>
<PRE CLASS="CodeExample"><A NAME="pgfId=1021158"> </A>
typedef void cyg_exception_handler_t(
 cyg_addrword_t data,
 cyg_code_t exception_number,
 cyg_addrword_t info
);</PRE>
<H3 CLASS="Heading2">
<A NAME="pgfId=1021260">
 </A>
<A NAME="marker=1084733">
 </A>
cyg_thread, <A NAME="marker=1084736">
 </A>
cyg_interrupt, <A NAME="marker=1084739">
 </A>
cyg_counter, <A NAME="marker=1084742">
 </A>
cyg_clock, <A NAME="marker=1084745">
 </A>
cyg_alarm, <A NAME="marker=1084748">
 </A>
cyg_mbox, <A NAME="marker=1084751">
 </A>
cyg_mempool_var, and <A NAME="marker=1084754">
 </A>
cyg_mempool_fix</H3>
<P CLASS="Body">
<A NAME="pgfId=1021266">
 </A>
These types are of the appropriate size to contain the memory used by the respective kernel objects. These types are only used in the corresponding create call where the programmer allocates the memory for the object and passes the address to the kernel. After creation the provided handle is used to reference the object.</P>
<H3 CLASS="Heading2">
<A NAME="pgfId=1021286">
 </A>
<A NAME="marker=1084757">
 </A>
cyg_mempool_info</H3>
<P CLASS="Body">
<A NAME="pgfId=1021300">
 </A>
Contains information about a memory pool. </P>
<PRE CLASS="CodeExample"><A NAME="pgfId=1021307"> </A>
typedef struct {
 cyg_int32 totalmem;
 cyg_int32 freemem;
 void *base;
 cyg_int32 size;
 cyg_int32 blocksize;
 cyg_int32 maxfree; // The largest free block
} cyg_mempool_info;</PRE>
<H3 CLASS="Heading2">
<A NAME="pgfId=1021367">
 </A>
<A NAME="marker=1084760">
 </A>
cyg_sem_t, <A NAME="marker=1084763">
 </A>
cyg_mutex_t, and <A NAME="marker=1084766">
 </A>
cyg_cond_t</H3>
<P CLASS="Body">
<A NAME="pgfId=1021373">
 </A>
These types are of the appropriate size to contain the memory used by their respective kernel objects. These objects are always referred to by a pointer to an object of this type.</P>
<H3 CLASS="Heading2">
<A NAME="pgfId=1021416">
 </A>
<A NAME="marker=1084769">
 </A>
cyg_VSR_t, <A NAME="marker=1084772">
 </A>
cyg_ISR_t, and <A NAME="marker=1084775">
 </A>
cyg_DSR_t</H3>
<P CLASS="Body">
<A NAME="pgfId=1021422">
 </A>
These are function types used when vector, interrupt and delayed service routines are installed. </P>
<PRE CLASS="CodeExample"><A NAME="pgfId=1021431"> </A>
typedef void cyg_VSR_t();
typedef cyg_uint32 cyg_ISR_t(cyg_vector_t vector,
 cyg_addrword_t data);
typedef void cyg_DSR_t(cyg_uint32 vector,
 cyg_ucount32 count,
 cyg_addrword_t data);</PRE>
<H3 CLASS="Heading2">
<A NAME="pgfId=1021457">
 </A>
<A NAME="marker=1084778">
 </A>
<A NAME="29032">
 </A>
cyg_resolution_t</H3>
<P CLASS="Body">
<A NAME="pgfId=1021471">
 </A>
Stores the resolution of a clock. The resolution is defined to be (dividend/divisor) nanoseconds per tick. </P>
  <PRE CLASS="CodeExample"><A NAME="pgfId=1021482"> </A>
typedef struct { cyg_uint32 dividend;
 cyg_uint32 divisor; }
cyg_resolution_t;</PRE>
<H3 CLASS="Heading2">
<A NAME="pgfId=1021502">
 </A>
<A NAME="marker=1084781">
 </A>
cyg_alarm_t</H3>
<P CLASS="Body">
<A NAME="pgfId=1021516">
 </A>
The function type used for alarm handlers. </P>
<PRE CLASS="CodeExample"><A NAME="pgfId=1087861"> </A>
typedef void cyg_alarm_t(cyg_handle_t alarm,
 cyg_addrword_t data);</PRE>
</DIV>
<DIV> <A NAME="THREAD-OPERATIONS"></a> 
  <H3 CLASS="Heading1"> <A NAME="pgfId=1087874"> </A> <A NAME="marker=1087871"> 
    </A> <A NAME="38132"> </A> Thread operations</H3>
  <PRE CLASS="CodeExampleWide"><A NAME="pgfId=1087897"> </A>
void <CODE CLASS="CodeOutput">cyg_scheduler_start</CODE>( void )</PRE>
  <P CLASS="Body"> <A NAME="pgfId=1087901"> </A> Starts the scheduler with the 
    threads that have been created. It never returns. The scheduler has been chosen 
    at configuration time. <SPAN CLASS="Bold"> eCos</SPAN> currently ships with 
    three schedulers: a bitmap scheduler, a multi-level scheduler (selected by 
    default), and an experimental &quot;lottery&quot; scheduler which is under 
    development. It is unsupported and currently unusable.</P>
  <P CLASS="Body"> <A NAME="pgfId=1451703"> </A> The configuration tool can be 
    used to select between schedulers. The configuration options are <BR>
    <EM CLASS="parameter"> CYGSEM_SCHED_BITMAP,</EM> <EM CLASS="parameter"> CYGSEM_SCHED_MLQUEUE</EM> 
    and <EM CLASS="parameter"> CYGSEM_SCHED_LOTTERY.</EM> </P>
  <H3 CLASS="Label"> <A NAME="pgfId=1087934"> </A> NOTE</H3>
  <P CLASS="Note"> <A NAME="pgfId=1087938"> </A> Interrupts are not enabled until 
    the scheduler has been started with <CODE CLASS="CodeOutput"> cyg_scheduler_start()</CODE> 
    .</P>
  <PRE CLASS="CodeExampleWide"><A NAME="pgfId=1087967"> </A>
void <CODE CLASS="CodeOutput">cyg_scheduler_lock</CODE>( void )</PRE>
  <P CLASS="Body"> <A NAME="pgfId=1087971"> </A> Locks the scheduler so that a 
    context switch cannot occur. This can be used to protect data shared between 
    a thread and a DSR, or between multiple threads, by surrounding the critical 
    region with <CODE CLASS="CodeOutput"> cyg_scheduler_lock()</CODE> and <CODE CLASS="CodeOutput"> 
    cyg_scheduler_unlock()</CODE> . </P>
  <PRE CLASS="CodeExampleWide"><A NAME="pgfId=1088003"> </A>
void <CODE CLASS="CodeOutput">cyg_scheduler_unlock</CODE>( void )</PRE>
  <P CLASS="Body"> <A NAME="pgfId=1305781"> </A> Unlocks the scheduler so that 
    context switching can occur again.</P>
  <PRE CLASS="CodeExampleWide">void <CODE CLASS="CodeOutput">cyg_thread_create</CODE>( 
    cyg_addrword_t <EM CLASS="Emphasis">sched_info,</EM>
    cyg_thread_entry_t *<EM CLASS="Emphasis">entry,</EM>
    cyg_addrword_t <EM CLASS="Emphasis">entry_data,</EM>
    char *<EM CLASS="Emphasis">name,</EM>
    void *<EM CLASS="Emphasis">stack_base,</EM>
    cyg_ucount32 <EM CLASS="Emphasis">stack_size,</EM>
    cyg_handle_t *<EM CLASS="Emphasis">handle,</EM>
    cyg_thread *<EM CLASS="Emphasis">thread )</EM>
</PRE>
  <P CLASS="Body"> <A NAME="pgfId=1088124"> </A> Creates a thread in a suspended 
    state. The thread will not run until it has been resumed with <CODE CLASS="CodeOutput"> 
    cyg_thread_resume()</CODE> and the scheduler has been started with <CODE CLASS="CodeOutput"> 
    cyg_scheduler_start()</CODE> .</P>
  <P CLASS="Body"> <A NAME="pgfId=1088142"> </A> Here is a description of the 
    parameters of <CODE CLASS="CodeOutput"> cyg_thread_create()</CODE> :</P>
  <P CLASS="BodyHang1"> <A NAME="pgfId=1088160"> </A> <EM CLASS="parameter"> sched_info</EM> 
  </P>
  <P CLASS="BodyListFollow"> <A NAME="pgfId=1088167"> </A> Information to be passed 
    to the scheduler. For almost all schedulers this is a simple priority value, 
    and you can simply pass a non-negative integer when you create the thread. 
    Even when this holds, some schedulers may have restrictions on how priorities 
    can be used. For example, the bitmap scheduler can only have one thread at 
    each priority, so if an already-occupied slot is quoted, the next free slot 
    of lower priority is chosen.</P>
  <P CLASS="BodyHang1"> <A NAME="pgfId=1088185"> </A> <EM CLASS="parameter"> entry</EM> 
  </P>
  <P CLASS="BodyListFollow"> <A NAME="pgfId=1088192"> </A> A user-supplied function: 
    it is a routine that begins execution of the new thread. This function takes 
    a single argument of type cyg_addrword_t, which is usually a pointer to a 
    block of data, which allows <CODE CLASS="CodeOutput"> cyg_scheduler_start()</CODE> 
    to pass data to this particular thread.</P>
  <P CLASS="BodyListFollow"> <A NAME="pgfId=1088210"> </A> Here is a typedef for 
    the <EM CLASS="parameter"> entry</EM> function: </P>
  <PRE CLASS="CodeExample"><A NAME="pgfId=1088214"> </A>
typedef void cyg_thread_entry_t(cyg_addrword_t);</PRE>
  <P CLASS="BodyHang1"> <A NAME="pgfId=1088232"> </A> <EM CLASS="parameter"> entry_data</EM> 
  </P>
  <P CLASS="BodyListFollow"> <A NAME="pgfId=1088243"> </A> A data value passed 
    to the <EM CLASS="parameter"> entry</EM> function. This may be either a machine 
    word datum or the address of a block of data.</P>
  <P CLASS="BodyHang1"> <A NAME="pgfId=1088261"> </A> <EM CLASS="parameter"> name</EM> 
  </P>
  <P CLASS="BodyListFollow"> <A NAME="pgfId=1088271"> </A> A C string with the 
    name of this thread.</P>
  <P CLASS="BodyHang1"> <A NAME="pgfId=1088286"> </A> <EM CLASS="parameter"> stack_base</EM> 
  </P>
  <P CLASS="BodyListFollow"> <A NAME="pgfId=1088297"> </A> The address of the 
    stack base. If this value is <EM CLASS="parameter"> NULL</EM> then <CODE CLASS="CodeOutput"> 
    cyg_thread_create()</CODE> will choose a stack base.</P>
  <H3 CLASS="Label"> <A NAME="pgfId=1088309"> </A> NOTE</H3>
  <P CLASS="Note"> <A NAME="pgfId=1088317"> </A> Passing a stack base of <EM CLASS="parameter"> 
    NULL</EM> is not supported in this release. You must pass a real address for 
    the stack base.</P>
  <P CLASS="BodyHang1"> <A NAME="pgfId=1088336"> </A> <EM CLASS="parameter"> stack_size</EM> 
  </P>
  <P CLASS="BodyListFollow"> <A NAME="pgfId=1088343"> </A> The size of the stack 
    for this thread. If this is 0, the default stack size will be used for this 
    thread.</P>
  <H3 CLASS="Label"> <A NAME="pgfId=1088351"> </A> NOTE</H3>
  <P CLASS="Note"> <A NAME="pgfId=1088355"> </A> Passing a stack size of 0 is 
    not supported in this release. You must pass a real stack size.</P>
  <P CLASS="BodyHang1"> <A NAME="pgfId=1088374"> </A> <EM CLASS="parameter"> handle</EM> 
  </P>
  <P CLASS="BodyListFollow"> <A NAME="pgfId=1088388"> </A> <CODE CLASS="CodeOutput"> 
    cyg_thread_create()</CODE> returns the thread handle in this location.</P>
  <P CLASS="BodyHang1"> <A NAME="pgfId=1088403"> </A> <EM CLASS="parameter"> thread</EM> 
  </P>
  <P CLASS="BodyListFollow"> <A NAME="pgfId=1088410"> </A> The thread housekeeping 
    information is placed in the memory pointed to by this parameter. If this 
    pointer is <EM CLASS="parameter"> NULL</EM> then the memory will be allocated. 
  </P>
  <H3 CLASS="Label"> <A NAME="pgfId=1088421"> </A> NOTE</H3>
  <P CLASS="Note"> <A NAME="pgfId=1088425"> </A> Passing a NULL value for the 
    thread data structure address is not supported in this release. You must pass 
    a valid address. </P>
  <P CLASS="BodyListFollow"> <A NAME="pgfId=1088432"> </A> </P>
  <PRE CLASS="CodeExampleWide"><A NAME="pgfId=1088455"> </A>
void <CODE CLASS="CodeOutput">cyg_thread_exit</CODE>( void )</PRE>
  <P CLASS="Body"> <A NAME="pgfId=1088460"> </A> Exits the current thread. At 
    present this simply puts the thread into suspended state.</P>
  <PRE CLASS="CodeExampleWide"><A NAME="pgfId=1088475"> </A>
void <CODE CLASS="CodeOutput">cyg_thread_suspend</CODE>(
    cyg_handle_t <EM CLASS="Emphasis">thread )</EM>
</PRE>
  <P CLASS="Body"> <A NAME="pgfId=1452259"> </A> Suspends the <EM CLASS="parameter"> 
    thread.</EM> A thread may be suspended multiple times, in which case it will 
    need to be resumed the same number of times before it will run. </P>
  <PRE CLASS="CodeExampleWide"><A NAME="pgfId=1452260"> </A>
void <CODE CLASS="CodeOutput">cyg_thread_resume</CODE>(
&nbsp;&nbsp;&nbsp;&nbsp;cyg_handle_t <EM CLASS="Emphasis">thread )</EM>
</PRE>
  <P CLASS="Body"> <A NAME="pgfId=1088533"> </A> Resumes <EM CLASS="parameter"> 
    thread.</EM> If a thread has been suspended multiple times it will need to 
    be resumed the same number of times before it will run. Threads are created 
    in a suspended state and must be resumed before they will run.</P>
  <PRE CLASS="CodeExampleWide"><A NAME="pgfId=1088557"> </A>
void <CODE CLASS="CodeOutput">cyg_thread_yield</CODE>( void )</PRE>
  <P CLASS="Body"> <A NAME="pgfId=1088561"> </A> Yields control to the next runnable 
    thread of equal priority. If no such thread exists, then this function has 
    no effect.</P>
  <PRE CLASS="CodeExampleWide"><A NAME="pgfId=1088577"> </A>
void <CODE CLASS="CodeOutput">cyg_thread_kill</CODE>( 
    cyg_handle_t <EM CLASS="Emphasis">thread )</EM>
</PRE>
  <P CLASS="Body"> <A NAME="pgfId=1452295"> </A> Kills <EM CLASS="parameter"> 
    thread.</EM> </P>
  <PRE CLASS="CodeExampleWide">cyg_bool_t cyg_thread_delete( <br>    cyg_handle_t <i>thread</i><br></PRE>
  <br>
  Kills <EM>thread</EM> and deletes it from the scheduler. If necessary, it will 
  kill <EM>thread</EM> first using cyg_thread_kill(<EM>thread</EM>).<br>
  If <EM>thread</EM> does not terminate in response to the kill message, this 
  function returns false, indicating failure.<br>
  <br>
  This function differs from <i>cyg_thread_kill()</i> (or calling <i>cyg_thread_exit()</i> 
  for the current thread) by deregistering the thread from the scheduler. As a 
  result, the thread handle, thread stack and space passed for the thread housekeeping 
  information can then be reused. <br>
  This is not the case if just <i>cyg_thread_kill()</i>or <i>cyg_thread_exit()</i>is 
  invoked for the thread.<br>
  <br>
  <b>NOTE</b><br>
  <font size="4"><font size="3"><i>cyg_thread_delete()</i></font> </font>only 
  deregisters the thread from the scheduler, it does not free up any resources 
  that had been allocated by the thread such as dynamic memory, nor does it unlock 
  any synchronization objects owned by the thread. This is the responsibility 
  of the programmer. Additionally, unlike <i>cyg_thread_kill()</i>, the <i>cyg_thread_delete()</i> 
  function cannot be self-referencing. 
  <p CLASS="CodeExampleWide"><b>EXAMPLE</b></p>
  <p CLASS="CodeExampleWide"><font face="Courier New, Courier, mono">// Delete 
    another thread. This must be done in a loop, waiting for<br>
    // the call to return true. If it returns false, go to sleep for a<br>
    // while, so that the killed thread gets a chance to run and <br>
    // complete its business.<br>
    while (!cyg_thread_delete(&lt;tyhread_handle&gt;) {<br>
    cyg_thread_delay(1);<br>
    } </font><br>
  </p>
  <PRE CLASS="CodeExampleWide">cyg_handle_t <CODE CLASS="CodeOutput">cyg_thread_self</CODE>( void )</PRE>
  <P CLASS="Body"> <A NAME="pgfId=1452297"> </A> Returns the handle of the current 
    thread.</P>
  <PRE CLASS="CodeExampleWide"><A NAME="pgfId=1089001"> </A>
void <CODE CLASS="CodeOutput">cyg_thread_release</CODE>( 
    cyg_handle_t <EM CLASS="Emphasis">thread )</EM>
</PRE>
  <P CLASS="Body"> <A NAME="pgfId=1089104"> </A> Break the thread out of any wait 
    it is currently in. Exactly how the thread returns from the wait operation, 
    and how, if at all, the break is indicated, depends on the synchronization 
    object it was waiting on.</P>
  <PRE CLASS="CodeExampleWide"><A NAME="pgfId=1089108"> </A>
cyg_ucount32 <CODE CLASS="CodeOutput">cyg_thread_new_data_index</CODE>( void )</PRE>
  <P CLASS="Body"> <A NAME="pgfId=1089095"> </A> Allocates a new per-thread data 
    index from those still available. If no more indexes are available, and assertions 
    are enabled, an assertion will be raised.</P>
  <PRE CLASS="CodeExampleWide"><A NAME="pgfId=1089126"> </A>
void <CODE CLASS="CodeOutput">cyg_thread_free_data_index</CODE>( 
     cyg_ucount32 <EM CLASS="Emphasis">index )</EM>
</PRE>
  <P CLASS="Body"> <A NAME="pgfId=1089143"> </A> Return the per-thread data index 
    to the pool.</P>
  <PRE CLASS="CodeExampleWide"><A NAME="pgfId=1089169"> </A>
CYG_ADDRWORD <CODE CLASS="CodeOutput">cyg_thread_get_data</CODE>( 
     cyg_ucount32 <EM CLASS="Emphasis">index )</EM>
</PRE>
  <P CLASS="Body"> <A NAME="pgfId=1089186"> </A> Retrieve the per-thread data 
    at the given index for the current thread.</P>
  <PRE CLASS="CodeExampleWide"><A NAME="pgfId=1089217"> </A>
CYG_ADDRWORD <CODE CLASS="CodeOutput">*cyg_thread_get_data_ptr</CODE>( 
     cyg_ucount32 <EM CLASS="Emphasis">index )</EM>
</PRE>
  <P CLASS="Body"> <A NAME="pgfId=1089235"> </A> Return a pointer to the per-thread 
    data at the given index for the current thread. This should be used with some 
    care since in some future implementation the per-thread data may be managed 
    by a dynamic mechanism that might invalidate this pointer at any time. This 
    pointer should only be considered valid until the next call to the per-thread 
    data functions.</P>
  <PRE CLASS="CodeExampleWide"><A NAME="pgfId=1089301"> </A>
void <CODE CLASS="CodeOutput">cyg_thread_set_data</CODE>( 
     cyg_ucount32 index, CYG_ADDRWORD data )</PRE>
  <P CLASS="Body"> <A NAME="pgfId=1089319"> </A> Store the data in the per-thread 
    data for the current thread at the given index.</P>
</DIV>
<DIV>
<H3 CLASS="Heading1">
<A NAME="pgfId=1088638">
 </A>
<A NAME="marker=1088635">
 </A>
Priority manipulation</H3>
  <PRE CLASS="CodeExampleWide"><A NAME="pgfId=1088653"> </A>
void <CODE CLASS="CodeOutput">cyg_thread_set_priority</CODE>( 
     cyg_handle_t <EM CLASS="Emphasis">thread,
</EM>     cyg_priority_t <EM CLASS="Emphasis">priority )</EM>
</PRE>
<P CLASS="Body">
<A NAME="pgfId=1088682">
 </A>
Sets the priority of the given thread to the given value. The smaller the value, the higher the priority of the thread.</P>
<P CLASS="Body">
<A NAME="pgfId=1088687">
 </A>
Allowed priorities range between 1 and 64. The values of these parameters are configuration-dependent because they depend on which scheduler has been selected, and what value has been configured for the <EM CLASS="parameter">
CYGNUM_KERNEL_SCHED_PRIORITIES</EM>
 configuration parameter (see <A HREF="ecos-ref.9.html#38132" CLASS="XRef">
 Thread operations</A>
 and &quot;Option: Number of priority levels&quot; in Section V&quot;).</P>
<P CLASS="Body">
<A NAME="pgfId=1088704">
 </A>
There is always an idle thread, owned by the kernel, running at <EM CLASS="parameter">
CYG_THREAD_MIN_PRIORITY.</EM>
 Because of this, ordinary threads should never be run at the lowest priority. </P>
  <PRE CLASS="CodeExampleWide"><A NAME="pgfId=1088724"> </A>
cyg_priority_t <CODE CLASS="CodeOutput">cyg_thread_get_priority</CODE>( 
      cyg_handle_t <EM CLASS="Emphasis">thread )</EM>
</PRE>
<P CLASS="Body">
<A NAME="pgfId=1088742">
 </A>
Returns the priority of the given thread.</P>
  <PRE CLASS="CodeExampleWide"><A NAME="pgfId=1088757"> </A>
void <CODE CLASS="CodeOutput">cyg_thread_delay</CODE>( 
     cyg_tick_count_t <EM CLASS="Emphasis">delay )</EM>
</PRE>
<P CLASS="Body">
<A NAME="pgfId=1088778">
 </A>
Puts the current thread to sleep for <EM CLASS="parameter">
delay</EM>
 ticks. In a default configuration there are approximately 100 ticks a second. The actual length of the ticks is given by the resolution of the real-time clock. See <A HREF="ecos-ref.9.html#13357" CLASS="XRef">
 Counters, clocks and alarms</A>
 for more information on counter resolution. </P>
</DIV>
<DIV>
<H3 CLASS="Heading1">
<A NAME="pgfId=1088792">
 </A>
<A NAME="marker=1088789">
 </A>
<A NAME="27837">
 </A>
Exception handling</H3>
<P CLASS="Body">
<A NAME="pgfId=1022785">
 </A>
Exception handlers can be installed to deal with various system-level exceptions, such as alignment errors, resets, timers and so forth. Exception handling is a configurable feature of <SPAN CLASS="Bold">
eCos</SPAN>
 and is enabled by default.</P>
<P CLASS="Body">
<A NAME="pgfId=1022832">
 </A>
The range of values for the <EM CLASS="parameter">
exception_number</EM>
 parameter in the functions below is hardware-dependent, as are the individual exceptions. See <CODE CLASS="Code">
hal/ARCH/arch/</CODE>
<EM CLASS="Filename">
v1_3_x</EM>
<CODE CLASS="Code">
/include/hal_intr</CODE>
 for the exception vector definitions specific to a given architecture. </P>
<P CLASS="Body">
<A NAME="pgfId=1022849">
 </A>
The exception handler is a function of the following type: </P>
<PRE CLASS="CodeExample"><A NAME="pgfId=1022856"> </A>

typedef void cyg_exception_handler_t(
 cyg_addrword_t data,
 cyg_code_t exception_number,
 cyg_addrword_t info
);</PRE>
<P CLASS="Body">
<A NAME="pgfId=1022899">
 </A>
cyg_exception_handler_t is the type used for functions which are called as a result of an exception. It is used in the function <CODE CLASS="CodeOutput">
cyg_exception_set_handler()</CODE>
. </P>
  <PRE CLASS="CodeExampleWide"><A NAME="pgfId=1022909"> </A>
void <CODE CLASS="CodeOutput">cyg_exception_set_handler</CODE>( 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cyg_code_t <EM CLASS="Emphasis">exception_number,
</EM>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cyg_exception_handler_t *<EM CLASS="Emphasis">new_handler,
</EM>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cyg_addrword_t <EM CLASS="Emphasis">new_data,
</EM>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cyg_exception_handler_t **<EM CLASS="Emphasis">old_handler,
</EM>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void **<EM CLASS="Emphasis">old_data )</EM>
</PRE>
<P CLASS="Body">
<A NAME="pgfId=1022992">
 </A>
Replace current exception handler. This may apply to either the thread, or to a global exception handler, according to how exception handling was configured (global or per-thread). The exception may be ignored, or used to specify a particular handler.</P>
  <PRE CLASS="CodeExampleWide"><A NAME="pgfId=1023009"> </A>
void <CODE CLASS="CodeOutput">cyg_exception_call_handler</CODE>( 
    cyg_handle_t <EM CLASS="Emphasis">thread,</EM>
    cyg_code_t <EM CLASS="Emphasis">exception_number,</EM>
    cyg_addrword_t <EM CLASS="Emphasis">exception_info )</EM>
</PRE>
<P CLASS="Body">
<A NAME="pgfId=1023065">
 </A>
Invoke exception handler for the given exception number. The exception handler will be invoked with <EM CLASS="parameter">
exception_info</EM>
 as its third argument.</P>
</DIV>
<DIV>
<H3 CLASS="Heading1">
<A NAME="pgfId=1023071">
 </A>
<A NAME="marker=1084825">
 </A>
<A NAME="37728">
 </A>
Interrupt handling</H3>
<P CLASS="Body">
<A NAME="pgfId=1023081">
 </A>
Interrupt handling is by nature machine-specific. The <SPAN CLASS="Bold">
eCos</SPAN>
 kernel aims to provide efficiency and flexibility in this area, while maintaining a very low interrupt latency. To allow the programmer direct access to hardware, the semantics and the interface can vary from one architecture to another.</P>
<P CLASS="Body">
<A NAME="pgfId=1023108">
 </A>
The interrupt vectors for a given architecture are defined in <CODE CLASS="Code">
hal/ARCH/arch/</CODE>
<EM CLASS="Filename">
v1_3_x</EM>
<CODE CLASS="Code">
/include/hal_intr.h</CODE>
 where also special semantics and caveats of the interrupt capabilities would be described.</P>
<PRE CLASS="CodeExample"><A NAME="pgfId=1023132"> </A>

typedef void cyg_VSR_t();
typedef cyg_uint32 cyg_ISR_t(cyg_vector_t vector,
 cyg_addrword_t data);
typedef void cyg_DSR_t(cyg_vector_t vector,
 cyg_ucount32 count,
 cyg_addrword_t data);

enum cyg_ISR_results
{
 CYG_ISR_HANDLED = 1, /* Interrupt was handled */
 CYG_ISR_CALL_DSR = 2 /* Schedule DSR */
}; </PRE>
  <PRE CLASS="CodeExampleWide"><A NAME="pgfId=1023179"> </A>
void <CODE CLASS="CodeOutput">cyg_interrupt_create</CODE>( 
    cyg_vector_t <EM CLASS="Emphasis">vector,</EM>
    cyg_priority_t <EM CLASS="Emphasis">priority,</EM>
    cyg_addrword_t <EM CLASS="Emphasis">data,</EM>
    cyg_ISR_t *<EM CLASS="Emphasis">isr,</EM>
    cyg_DSR_t *<EM CLASS="Emphasis">dsr,</EM>
    cyg_handle_t *<EM CLASS="Emphasis">handle,</EM>
    cyg_interrupt *<EM CLASS="Emphasis">intr )</EM>
</PRE>
<P CLASS="Body">
<A NAME="pgfId=1023328">
 </A>
Creates an interrupt object and returns a handle to it. The object contains information about which interrupt <EM CLASS="parameter">
vector</EM>
 to use and the ISR and DSR that will be called after the interrupt object is attached. The interrupt object will be allocated in the memory passed in the <EM CLASS="parameter">
intr</EM>
 parameter. The interrupt object is not immediately attached; it must be attached with the <CODE CLASS="CodeOutput">
cyg_interrupt_attach()</CODE>
 call.</P>
  <PRE CLASS="CodeExampleWide"><A NAME="pgfId=1023337"> </A>
void <CODE CLASS="CodeOutput">cyg_interrupt_delete</CODE>( 
    cyg_handle_t <EM CLASS="Emphasis">interrupt )</EM>
</PRE>
<P CLASS="Body">
<A NAME="pgfId=1023367">
 </A>
Detaches the <EM CLASS="parameter">
interrupt</EM>
 from the vector and frees the corresponding memory.</P>
  <PRE CLASS="CodeExampleWide">void <CODE CLASS="CodeOutput">cyg_interrupt_attach</CODE>( 
cyg_handle_t <EM CLASS="Emphasis">interrupt )</EM>
</PRE>
  <P CLASS="Body"> <a name="pgfId=1023414"> </a>Attaches <EM CLASS="parameter"> 
    interrupt.</EM> </P>
  <PRE CLASS="CodeExampleWide"><A NAME="pgfId=1023430"> </A>
void <CODE CLASS="CodeOutput">cyg_interrupt_detach</CODE>( 
    cyg_handle_t <EM CLASS="Emphasis">interrupt )</EM>
</PRE>
<P CLASS="Body">
<A NAME="pgfId=1023460">
 </A>
Detaches <EM CLASS="parameter">
interrupt.</EM>
 </P>
  <PRE CLASS="CodeExampleWide">void <CODE CLASS="CodeOutput">cyg_interrupt_get_vsr</CODE>( 
    cyg_vector_t <EM CLASS="Emphasis">vector,</EM>
    cyg_VSR_t **<EM CLASS="Emphasis">vsr )</EM>
</PRE>
  <P CLASS="Body"> <A NAME="pgfId=1023518"> </A> Returns a pointer to the VSR 
    currently installed on <EM CLASS="parameter"> vector.</EM></P>
  <P CLASS="Body"><A NAME="pgfId=1023535"> </A> void <CODE CLASS="CodeOutput">cyg_interrupt_set_vsr</CODE> 
    (<br>
    cyg_vector_t <EM CLASS="Emphasis">vector,<br>
    </EM> cyg_VSR_t *<EM CLASS="Emphasis">vsr )</EM> </P>
  <P CLASS="Body"> <A NAME="pgfId=1023577"> </A> Sets the current VSR on <EM CLASS="parameter"> 
    vector.</EM> A VSR directly attaches to the hardware interrupt vector and 
    needs to be written in assembler.</P>
  <P CLASS="Body"><A NAME="pgfId=1023598"> </A> void <CODE CLASS="CodeOutput">cyg_interrupt_disable</CODE> 
    ( void )</P>
<P CLASS="Body">
<A NAME="pgfId=1023620">
 </A>
Disables all interrupts.</P>
  <PRE CLASS="CodeExampleWide">void <CODE CLASS="CodeOutput">cyg_interrupt_enable</CODE>( void )</PRE>
<P CLASS="Body">
<A NAME="pgfId=1023648">
 </A>
Enables all interrupts.</P>
  <PRE CLASS="CodeExampleWide">void <CODE CLASS="CodeOutput">cyg_interrupt_mask</CODE>( <br>    cyg_vector_t <EM CLASS="Emphasis">vector )</EM>
</PRE>
<P CLASS="Body">
<A NAME="pgfId=1023684">
 </A>
Programs the interrupt controller to stop delivery of interrupts on <EM CLASS="parameter">
vector.</EM>
 On some architectures this will also disable all lower priority interrupts while on others they remain enabled. </P>
  <PRE CLASS="CodeExampleWide">void <CODE CLASS="CodeOutput">cyg_interrupt_unmask</CODE>( <br>    cyg_vector_t <EM CLASS="Emphasis">vector )</EM>
</PRE>
<P CLASS="Body">
<A NAME="pgfId=1023738">
 </A>
Programs the interrupt controller to allow delivery of interrupts on the given interrupt <EM CLASS="parameter">
vector.</EM>
 </P>
  <PRE CLASS="CodeExampleWide">
void <CODE CLASS="CodeOutput">cyg_interrupt_acknowledge</CODE>( <br>    cyg_vector_t <EM CLASS="Emphasis">vector )</EM>
</PRE>
<P CLASS="Body">
<A NAME="pgfId=1023787">
 </A>
Should be used from inside an ISR to acknowledge receipt of the interrupt. The interrupt must be acknowledged. If an interrupt is not acknowledged, the interrupt may trigger immediately after the ISR returns, causing the ISR to be called again in a loop. </P>
  <PRE CLASS="CodeExampleWide">void <CODE CLASS="CodeOutput">cyg_interrupt_configure</CODE>( 
    cyg_vector_t <EM CLASS="Emphasis">vector,</EM>
    cyg_bool_t <EM CLASS="Emphasis">level,</EM>
    cyg_bool_t <EM CLASS="Emphasis">up )</EM>
</PRE>
<P CLASS="Body">
<A NAME="pgfId=1023881">
 </A>
On some interrupt controllers the way an interrupt is detected may be configured. The <EM CLASS="parameter">
level</EM>
 parameter chooses between level- or edge-triggered interrupts. The <EM CLASS="parameter">
up</EM>
 parameter chooses between high and low level for level triggered interrupts or rising and falling edges for edge triggered interrupts. </P>
</DIV>
<DIV>
<A NAME="CLOCKS-AND-ALARMS"></a>
<H3 CLASS="Heading1">
<A NAME="pgfId=1023895">
 </A>
<A NAME="13357">
 </A>
Counters, clocks and alarms</H3>
<H3 CLASS="Heading2">
<A NAME="pgfId=1023905">
 </A>
<A NAME="marker=1084828">
 </A>
Counters</H3>
<P CLASS="Body">
<A NAME="pgfId=1023915">
 </A>
The counter objects provided by the kernel provide an abstraction of the clock facility that is generally provided. Application code can associate alarms with counters, where an alarm is identified by the number of ticks until it triggers, the action to be taken on triggering, and whether or not the alarm should be repeated. </P>
<P CLASS="Body">
<A NAME="pgfId=1023934">
 </A>
There are two different implementations of the counter objects. The first stores all alarms in a single linked list. The alternative implementation uses a table of linked lists, with the size of the table being a separate configurable option. A single list is more efficient in terms of memory usage and is generally adequate when the application only makes use of a small number of alarms. For more complicated operations it is better to have a table of lists since this reduces the amount of computation whenever the timer goes off. Assuming a table size of 8 (the default value) on average the timer code will only need to check 1/8 of the pending alarms instead of all of them.</P>
<P CLASS="Body">
<A NAME="pgfId=1024005">
 </A>
The configuration options which select the counter implementation are <EM CLASS="parameter">
CYGIMP_KERNEL_COUNTERS_MULTI_LIST</EM>
 (&quot;Option: Implement counters using a table of lists&quot; in Section V) and <EM CLASS="parameter">
CYGIMP_KERNEL_COUNTERS_SINGLE_LIST</EM>
 (&quot;Option: Implement counters using a single list&quot;, in Section V). </P>
<P CLASS="Body">
<A NAME="pgfId=1024014">
 </A>
The following functions can be used to create and manipulate counters:</P>
  <PRE CLASS="CodeExampleWide">
void <CODE CLASS="CodeOutput">cyg_counter_create</CODE>( <br>    cyg_handle_t <EM CLASS="Emphasis">*counter,</EM>
    cyg_counter *<EM CLASS="Emphasis">the_counter )</EM>
</PRE>
<P CLASS="Body">
<A NAME="pgfId=1024089">
 </A>
Creates a new counter and places it in the space pointed to by <EM CLASS="parameter">
counter.</EM>
 A counter stores a value that is incremented by <CODE CLASS="CodeOutput">
cyg_counter_tick()</CODE>
. Alarms may be attached to counters, and the alarms will trigger when the counter reaches a specified value.</P>
  <PRE CLASS="CodeExampleWide">void <CODE CLASS="CodeOutput">cyg_counter_delete</CODE>( 
    cyg_handle_t <EM CLASS="Emphasis">counter )</EM>
</PRE>
<P CLASS="Body">
<A NAME="pgfId=1024132">
 </A>
Deletes the given counter and frees the corresponding memory.</P>
  <PRE CLASS="CodeExampleWide">cyg_tick_count_t <CODE CLASS="CodeOutput">cyg_counter_current_value</CODE>( 
    cyg_handle_t <EM CLASS="Emphasis">counter )</EM>
</PRE>
<P CLASS="Body">
<A NAME="pgfId=1024169">
 </A>
Returns the current value of the given counter.</P>
  <PRE CLASS="CodeExampleWide">void <CODE CLASS="CodeOutput">cyg_counter_set_value</CODE>( <br>    cyg_handle_t <EM CLASS="Emphasis">counter,</EM><A NAME="pgfId=1024205"> </A>
    cyg_tick_count_t <EM CLASS="Emphasis">new_value )</EM>
</PRE>
<P CLASS="Body">
<A NAME="pgfId=1024218">
 </A>
Sets the counter's value to <EM CLASS="parameter">
new_value.</EM>
</P>
  <PRE CLASS="CodeExampleWide">void <CODE CLASS="CodeOutput">cyg_counter_tick</CODE>(<A NAME="pgfId=1024251"> </A>
    cyg_handle_t <EM CLASS="Emphasis">counter )</EM>
</PRE>
<P CLASS="Body">
<A NAME="pgfId=1024264">
 </A>
Advances the counter by one tick.</P>
<H3 CLASS="Heading2">
<A NAME="pgfId=1024270">
 </A>
C<A NAME="marker=1084831">
 </A>
locks</H3>
<P CLASS="Body">
<A NAME="pgfId=1024280">
 </A>
Clocks are counters which are associated with a stream of ticks that represent time periods. Clocks have a resolution associated with them, whereas counters do not. </P>
<P CLASS="Body">
<A NAME="pgfId=1451717">
 </A>
The most frequently used clock is the <EM CLASS="Emphasis">
real-time clock</EM>
 which serves two special purposes. First, it is necessary to support clock and alarm related functions such as <CODE CLASS="CodeOutput">
cyg_thread_delay()</CODE>
. Second, it is needed to implement timeslicing in the mlqueue and lottery schedulers. If the application does not require either of these facilities, then it is possible to disable the real-time clock support completely. It is also possible to disable just timeslicing with the configuration option <EM CLASS="parameter">
CYGSEM_KERNEL_SCHED_TIMESLICE,</EM>
 or just the clock and alarm functions, using the option <EM CLASS="parameter">
CYGFUN_KERNEL_THREADS_TIMER.</EM>
.</P>
<P CLASS="Body">
<A NAME="pgfId=1451721">
 </A>
The real-time clock is available if the configuration option <EM CLASS="parameter">
CYGVAR_KERNEL_COUNTERS_CLOCK</EM>
  is defined. </P>
<P CLASS="Body">
<A NAME="pgfId=1024423">
 </A>
Clock resolution is stored in variables of type cyg_resolution_t (see <A HREF="ecos-ref.9.html#29032" CLASS="XRef">
 cyg_resolution_t</A>
).</P>
  <PRE CLASS="CodeExampleWide">void <CODE CLASS="CodeOutput">cyg_clock_create</CODE>( <br>    cyg_resolution_t <EM CLASS="Emphasis">resolution,</EM>
    cyg_handle_t *<EM CLASS="Emphasis">handle,</EM><A NAME="pgfId=1024475"> </A>
    cyg_clock *<EM CLASS="Emphasis">clock )</EM>
</PRE>
  <P CLASS="Body"> <A NAME="pgfId=1024508"> </A> Creates a clock object with the 
    given <EM CLASS="parameter"> resolution</EM> and places it in the space pointed 
    to by <EM CLASS="parameter"> clock.</EM> A clock is a counter driven by a 
    regular source of ticks. For example the system real-time clock is driven 
    by a clock interrupt.</P>
  <P CLASS="Body"> <A NAME="pgfId=1024524"> </A> void <CODE CLASS="CodeOutput">cyg_clock_delete</CODE> 
    ( <br>
    cyg_handle_t <EM CLASS="Emphasis">clock )</EM> </P>
  <P CLASS="Body"> <A NAME="pgfId=1024553"> </A> Deletes a clock object and frees 
    the associated memory.</P>
  <P CLASS="Body"><A NAME="pgfId=1024561"> </A> void <CODE CLASS="CodeOutput">cyg_clock_to_counter</CODE> 
    (<br>
    cyg_handle_t <EM CLASS="Emphasis">clock,<br>
    </EM>cyg_handle_t *<EM CLASS="Emphasis">counter 
    )</EM> </P>
  <P CLASS="Body">
<A NAME="pgfId=1024604">
 </A>
Converts a clock handle to a counter handle. The counter functions can then be used with the counter handle.</P>
  <PRE CLASS="CodeExampleWide">void <CODE CLASS="CodeOutput">cyg_clock_set_resolution</CODE>( <br>    cyg_handle_t <EM CLASS="Emphasis">clock,</EM><A NAME="pgfId=1024643"> </A>
    cyg_resolution_t <EM CLASS="Emphasis">resolution )</EM>
</PRE>
  <P CLASS="Body"> <A NAME="pgfId=1024656"> </A> Changes the resolution of a given 
    clock object.</P>
  <P CLASS="Body"><A NAME="pgfId=1024662"> </A> cyg_resolution_t <CODE CLASS="CodeOutput">cyg_clock_get_resolution</CODE> 
    ( <br>
    cyg_handle_t <EM CLASS="Emphasis">clock )</EM> </P>
  <P CLASS="Body"> <A NAME="pgfId=1024692"> </A> Returns the resolution of <EM CLASS="parameter"> 
    clock.</EM></P>
  <P CLASS="Body"><A NAME="pgfId=1024708"> </A> cyg_handle <CODE CLASS="CodeOutput">cyg_real_time_clock</CODE> 
    ( void )</P>
  <P CLASS="Body"> <A NAME="pgfId=1024730"> </A> Returns a handle to the system-supplied 
    real-time clock.</P>
  <P CLASS="Body"><A NAME="pgfId=1024740"> </A> cyg_tick_count_t <CODE CLASS="CodeOutput">cyg_current_time</CODE> 
    ( void )</P>
<P CLASS="Body">
<A NAME="pgfId=1024762">
 </A>
Returns the real-time clock's counter. This is equivalent to executing the code:</P>
  <PRE CLASS="CodeExample"> cyg_clock_to_counter(cyg_real_time_clock(), &amp;h),
 cyg_counter_current_value(h); </PRE>
<H3 CLASS="Heading2">
<A NAME="pgfId=1024786">
 </A>
<A NAME="marker=1084835">
 </A>
Alarms</H3>
  <PRE CLASS="CodeExample">
typedef void cyg_alarm_t(cyg_handle_t alarm,
 cyg_addrword_t data);</PRE>
  <P CLASS="Body"> <A NAME="pgfId=1024827"> </A> cyg_alarm_t is the type used 
    for functions which are used to handle alarm events. It is used in the function 
    <CODE CLASS="CodeOutput"> cyg_alarm_create()</CODE> .</P>
  <P CLASS="Body"><A NAME="pgfId=1024837"> </A> void <CODE CLASS="CodeOutput">cyg_alarm_create</CODE> 
    (<br>
    cyg_handle_t <EM CLASS="Emphasis">counter,<br>
    </EM>cyg_alarm_t *<EM CLASS="Emphasis">alarm_fn,</EM><br>
    cyg_addrword_t <EM CLASS="Emphasis">data,</EM> <br>
    cyg_handle_t *<EM CLASS="Emphasis">handle,<br>
    </EM>cyg_alarm *<EM CLASS="Emphasis">alarm 
    )</EM> </P>
  <P CLASS="Body">
<A NAME="pgfId=1024957">
 </A>
Creates an alarm object. The alarm is attached to the <EM CLASS="parameter">
counter</EM>
 and is created in the memory pointed to by <EM CLASS="parameter">
alarm.</EM>
 When the alarm triggers, the handler function <EM CLASS="parameter">
alarmfn</EM>
 is called and is passed <EM CLASS="parameter">
data</EM>
 as a parameter. The alarm handler executes in the context of the function that incremented the counter and thus triggered the alarm.</P>
<H3 CLASS="Label">
<A NAME="pgfId=1024972">
 </A>
NOTE</H3>
<P CLASS="Note">
<A NAME="pgfId=1025011">
 </A>
If the alarm is associated with the real-time clock, the alarm handler <EM CLASS="parameter">
alarmfn</EM>
 will be invoked by the delayed service routine (DSR) that services the real-time clock. This means that real-time clock alarm handlers (which are possibly the most frequently used) must follow the rules of behavior for DSRs. These rules are outlined in <A HREF="ecos-ref.7.html#33307" CLASS="XRef">
 Interrupt and exception handlers</A>
. </P>
  <PRE CLASS="CodeExampleWide"><A NAME="pgfId=1025020"> </A>
void <CODE CLASS="CodeOutput">cyg_alarm_delete</CODE>(
    cyg_handle_t <EM CLASS="Emphasis">alarm )</EM>
</PRE>
  <P CLASS="Body">
<A NAME="pgfId=1025048">
 </A>
Disables the alarm, detaches from the counter, invalidates handles, and frees memory if it was dynamically allocated by <CODE CLASS="CodeOutput">
cyg_alarm_create()</CODE>
.</P>
  <PRE CLASS="CodeExampleWide">void <CODE CLASS="CodeOutput">cyg_alarm_initialize</CODE>( 
    cyg_handle_t <EM CLASS="Emphasis">alarm,</EM>
    cyg_tick_count_t <EM CLASS="Emphasis">trigger,</EM>
    cyg_tick_count_t <EM CLASS="Emphasis">interval )</EM>
</PRE>
  <P CLASS="Body"> <A NAME="pgfId=1025197"> </A> Initialize an alarm. This sets 
    it to trigger at the tick with value <EM CLASS="parameter"> trigger.</EM> 
    When an alarm triggers, this event is dealt with by calling the <EM CLASS="parameter"> 
    alarmfn</EM> parameter which was passed when the alarm was created using <CODE CLASS="CodeOutput"> 
    cyg_alarm_create()</CODE> . If <EM CLASS="parameter"> interval</EM> is non-zero, 
    then after the alarm has triggered it will set itself to trigger again after 
    <EM CLASS="parameter"> interval</EM> ticks. Otherwise, if <EM CLASS="parameter"> 
    interval</EM> is zero, the alarm is will be disabled automatically once it 
    has triggered.</P>
  <P CLASS="Body"><A NAME="pgfId=1025211"> </A> void <CODE CLASS="CodeOutput">cyg_alarm_enable</CODE> 
    (<br>
    cyg_handle_t <EM CLASS="Emphasis">alarm )</EM> </P>
  <P CLASS="Body">
<A NAME="pgfId=1025240">
 </A>
Enables an alarm that has been disabled by calling <CODE CLASS="CodeOutput">
cyg_alarm_disable()</CODE>
. </P>
  <PRE CLASS="CodeExampleWide"><A NAME="pgfId=1025257"> </A>
void <CODE CLASS="CodeOutput">cyg_alarm_disable</CODE>( 
    cyg_handle_t <EM CLASS="Emphasis">alarm )</EM>
</PRE>
<P CLASS="Body">
<A NAME="pgfId=1025312">
 </A>
Disables an alarm. After an alarm is disabled it will not be triggered unless it is subsequently re-enabled by calling <CODE CLASS="CodeOutput">
cyg_alarm_enable()</CODE>
 or is reinitialized by calling <CODE CLASS="CodeOutput">
cyg_alarm_initialize()</CODE>
.</P>
<P CLASS="Body">
<A NAME="pgfId=1025359">
 </A>
Note, though, that if a periodic alarm that has been disabled is re-enabled without reinitializing it will be in phase with the <EM CLASS="Emphasis">
original</EM>
 sequence of alarms. If it is <EM CLASS="Emphasis">
reinitialized,</EM>
 the new sequence of alarms will be in phase with the moment in which <CODE CLASS="CodeOutput">
cyg_alarm_initialize()</CODE>
 was called. </P>
</DIV>
<DIV>
<H3 CLASS="Heading1">
<A NAME="pgfId=1025371">
 </A>
Synchronization</H3>
<H3 CLASS="Heading2">
<A NAME="pgfId=1025381">
 </A>
Semaphores</H3>
<P CLASS="Body">
<A NAME="pgfId=1025391">
 </A>
The <A NAME="marker=1084838">
 </A>
semaphores defined by the type cyg_sem_t are counting semaphores. These objects are not referred to by handles, but rather by the pointer to the variable in which the semaphore is created.</P>
  <PRE CLASS="CodeExampleWide">void <CODE CLASS="CodeOutput">cyg_semaphore_init</CODE>( 
    cyg_sem_t *<EM CLASS="Emphasis">sem,</EM>
    cyg_ucount32 <EM CLASS="Emphasis">val )</EM>
</PRE>
<P CLASS="Body">
<A NAME="pgfId=1025456">
 </A>
Initializes a semaphore. The initial semaphore count is set to <EM CLASS="parameter">
val.</EM>
</P>
  <PRE CLASS="CodeExampleWide">void <CODE CLASS="CodeOutput">cyg_semaphore_destroy</CODE>( 
    cyg_sem_t *<EM CLASS="Emphasis">sem )</EM>
</PRE>
<P CLASS="Body">
<A NAME="pgfId=1025504">
 </A>
Destroys a semaphore. This must not be done while there are any threads waiting on it. </P>
  <PRE CLASS="CodeExampleWide">void <CODE CLASS="CodeOutput">cyg_semaphore_wait</CODE>( 
    cyg_sem_t *<EM CLASS="Emphasis">sem )</EM>
</PRE>
<P CLASS="Body">
<A NAME="pgfId=1025543">
 </A>
If the semaphore count is zero, the current thread will wait on the semaphore. If the count is non-zero, it will be decremented and the thread will continue running. </P>
  <PRE CLASS="CodeExampleWide">cyg_bool_t <CODE CLASS="CodeOutput">cyg_semaphore_trywait</CODE>( 
    cyg_sem_t *<EM CLASS="Emphasis">sem )</EM>
</PRE>
<P CLASS="Body">
<A NAME="pgfId=1025626">
 </A>
A non-blocking version of <CODE CLASS="CodeOutput">
cyg_semaphore_wait()</CODE>
. This attempts to decrement the semaphore count. If the count is positive, then the semaphore is decremented and <EM CLASS="parameter">
true</EM>
 is returned. If the count is zero then the semaphore remains unchanged, and <EM CLASS="parameter">
false</EM>
 is returned, but the current thread continues to run. </P>
  <PRE CLASS="CodeExampleWide">cyg_bool_t <CODE CLASS="CodeOutput">cyg_semaphore_timed_wait</CODE>( 
    cyg_sem_t *<EM CLASS="Emphasis">sem,</EM>
    cyg_tick_count_t <EM CLASS="Emphasis">abstime )</EM>
</PRE>
  <P CLASS="Body"> <A NAME="pgfId=1025737"> </A> A time-out version of <CODE CLASS="CodeOutput"> 
    cyg_semaphore_wait()</CODE> . This attempts to decrement the semaphore count. 
    If the count is positive, then the semaphore is decremented and <EM CLASS="parameter"> 
    true</EM> is returned. If the count is zero, it will wait for the semaphore 
    to increment. If however the <EM CLASS="parameter"> abstime</EM> time-out 
    is reached first, it will return <EM CLASS="parameter"> false</EM> without 
    changing state, and the current thread will continue to run.</P>
  The <i>cyg_tick_count_t</i> parameter is an absolute time. If a relative time 
  is required, you should use <code class="CodeOutput">cyg_current_time</code> 
  with an offset. For example, to time out 200 ticks from the present you would 
  use: <font face="Courier New, Courier, mono"><br>
  </font>
  <pre CLASS="Body"><font face="Courier New, Courier, mono">cyg_semaphore_timed_wait(&sem, cyg_current_time() + 200);</font></pre>
  <P CLASS="Body">
<A NAME="pgfId=1025776">
 </A>
<CODE CLASS="CodeOutput">
cyg_semaphore_timed_wait()</CODE>
 is only available if the configuration option <EM CLASS="parameter">
CYGFUN_KERNEL_THREADS_TIMER</EM>
  is set. </P>
  <PRE CLASS="CodeExampleWide">void <CODE CLASS="CodeOutput">cyg_semaphore_post</CODE>( 
    cyg_sem_t *<EM CLASS="Emphasis">sem )</EM>
</PRE>
<P CLASS="Body">
<A NAME="pgfId=1025816">
 </A>
If there are threads waiting on this semaphore this will wake exactly one of them. Otherwise it simply increments the semaphore count.</P>
  <PRE CLASS="CodeExampleWide">void <CODE CLASS="CodeOutput">cyg_semaphore_peek</CODE>( 
    cyg_sem_t *<EM CLASS="Emphasis">sem,</EM>
    cyg_count32 *<EM CLASS="Emphasis">val )</EM>
</PRE>
<P CLASS="Body">
<A NAME="pgfId=1025869">
 </A>
Returns the current semaphore count in the variable pointed to by <EM CLASS="parameter">
val.</EM>
 </P>
<H3 CLASS="Heading2">
<A NAME="pgfId=1025886">
 </A>
<A NAME="MUTEXES">
 </A>
Mutexes</H3>
<P CLASS="Body">
<A NAME="pgfId=1025896">
 </A>
<A NAME="marker=1084842">
 </A>
Mutexes (mutual exclusion locks) are used in a similar way to semaphores. A mutex only has two states, locked and unlocked. Mutexes are used to protect accesses to shared data or resources. When a thread locks a mutex it becomes the owner. Only the mutex's owner may unlock it. While a mutex remains locked, the owner should not lock it again, as the behavior is undefined and probably dangerous. </P>
<P CLASS="Body">
<A NAME="pgfId=1025934">
 </A>
If non-owners try to lock the mutex, they will be suspended until the mutex is available again, at which point they will own the mutex. </P>
  <PRE CLASS="CodeExampleWide">void <CODE CLASS="CodeOutput">cyg_mutex_init</CODE>( 
    cyg_mutex_t *<EM CLASS="Emphasis">mutex )</EM>
</PRE>
  <P CLASS="Body"> <A NAME="pgfId=1025974"> </A> Initializes a mutex. It is initialized 
    in the unlocked state.</P>
  <P CLASS="Body"><A NAME="pgfId=1025983"> </A> void <CODE CLASS="CodeOutput">cyg_mutex_destroy</CODE> 
    ( </P>
  <P CLASS="Body">cyg_mutex_t *<EM CLASS="Emphasis">mutex )</EM> </P>
<P CLASS="Body">
<A NAME="pgfId=1026011">
 </A>
Destroys a mutex. A mutex should not be destroyed in the locked state, as the behavior is undefined. </P>
  <PRE CLASS="CodeExampleWide">cyg_bool_t <CODE CLASS="CodeOutput">cyg_mutex_lock</CODE>( 
    cyg_mutex_t *<EM CLASS="Emphasis">mutex )</EM>
</PRE>
<P CLASS="Body">
<A NAME="pgfId=1089486">
 </A>
Changes the nutex from the unlocked state to the locked state. When this happens the mutex becomes owned by the current thread. If the mutex is locked, the current thread will wait until the mutex becomes unlocked before performing this operation. The result of this function will be TRUE if the mutex has been locked, or FALSE if it has not. A FALSE result can result if the thread has been released from its wait by a call to <CODE CLASS="CodeOutput">
cyg_thread_release()</CODE>
 or <CODE CLASS="CodeOutput">
cyg_mutex_release()</CODE>
.</P>
  <PRE CLASS="CodeExampleWide">void <CODE CLASS="CodeOutput">cyg_mutex_unlock</CODE>( 
    cyg_mutex_t *<EM CLASS="Emphasis">mutex )</EM>
</PRE>
<P CLASS="Body">
<A NAME="pgfId=1026152">
 </A>
Changes the mutex from the locked state to the unlocked state. This function may only be called by the thread which locked the mutex, and should not be called on an unlocked mutex. </P>
  <PRE CLASS="CodeExampleWide">void <CODE CLASS="CodeOutput">cyg_mutex_release</CODE>( 
    cyg_mutex_t *<EM CLASS="Emphasis">mutex )</EM>
</PRE>
<P CLASS="Body">
<A NAME="pgfId=1089543">
 </A>
Release all threads waiting on the mutex pointed to by the mutex argument. These threads will return from cyg_mutex_lock() with a FALSE result and will not have claimed the mutex. This function has no effect on any thread that may haev the mutex claimed.</P>
<H3 CLASS="Heading2">
<A NAME="pgfId=1026167">
 </A>
<A NAME="CONDITION-VARIABLES">
 </A>
Condition Variables</H3>
<P CLASS="Body">
<A NAME="pgfId=1026177">
 </A>
<A NAME="marker=1084848">
 </A>
<A NAME="marker=cond_var">
 </A>
Condition variables are a synchronization mechanism which (used with a mutex) grants several threads mutually exclusive access to shared data and to broadcast availability of that data to all the other threads.</P>
<P CLASS="Body">
<A NAME="pgfId=1026235">
 </A>
A typical example of the use of condition variables is when one thread (the producer) is producing data and several other (consumer) threads are waiting for that data to be ready. The consumers will wait by invoking <CODE CLASS="CodeOutput">
cyg_cond_wait()</CODE>
. The producer will lock access to the data with a mutex, and when it has generated enough data for the other processes to consume, it will invoke <CODE CLASS="CodeOutput">
cyg_cond_broadcast()</CODE>
 to wake up the consumers. The <EM CLASS="Emphasis">
Getting Started with </EM>
<EM CLASS="ProductName">
eCos</EM>
 book has example programs which use condition variables to implement a simple message passing system between threads. </P>
  <PRE CLASS="CodeExampleWide">void <CODE CLASS="CodeOutput">cyg_cond_init</CODE>( 
    cyg_cond_t *<EM CLASS="Emphasis">cond,</EM>
    cyg_mutex_t *<EM CLASS="Emphasis">mutex )</EM>
</PRE>
<P CLASS="Body">
<A NAME="pgfId=1026297">
 </A>
Initializes the condition variable. A condition variable is attached to a specific mutex. </P>
  <PRE CLASS="CodeExampleWide">void <CODE CLASS="CodeOutput">cyg_cond_destroy</CODE>( 
    cyg_cond_t *<EM CLASS="Emphasis">cond )</EM>
</PRE>
<P CLASS="Body">
<A NAME="pgfId=1026336">
 </A>
Destroys the condition variable <EM CLASS="parameter">
cond.</EM>
 This must not be done on a condition variable which is in use. After it has been destroyed, it may be subsequently reinitialized. </P>
  <PRE CLASS="CodeExampleWide">void <CODE CLASS="CodeOutput">cyg_cond_wait</CODE>( 
    cyg_cond_t *<EM CLASS="Emphasis">cond )</EM>
</PRE>
<P CLASS="Body">
<A NAME="pgfId=1026389">
 </A>
Causes the current thread to wait on the condition variable, while simultaneously unlocking the corresponding mutex. <CODE CLASS="CodeOutput">
cyg_cond_wait()</CODE>
 may be called by a thread which has the corresponding mutex locked.</P>
<P CLASS="Body">
<A NAME="pgfId=1026445">
 </A>
The thread can only be awakened by a call to <CODE CLASS="CodeOutput">
cyg_cond_signal()</CODE>
 or <CODE CLASS="CodeOutput">
cyg_cond_broadcast()</CODE>
 on the same condition variable. When the thread is awakened, the mutex will be reclaimed before this function proceeds. Since it may have to wait for this, <CODE CLASS="CodeOutput">
cyg_cond_wait()</CODE>
 should only be used in a loop since the condition may become false in the meantime. This is shown in the following example: </P>
  <PRE CLASS="CodeExample">extern cyg_mutex_t mutex;
extern cyg_cond_t cond;

cyg_mutex_lock( &amp;mutex );
...

while( condition_not_true )
{
 cyg_cond_wait( &amp;cond );
}

...

cyg_mutex_unlock( &amp;mutex );</PRE>
  <PRE CLASS="CodeExampleWide">cyg_bool_t <CODE CLASS="CodeOutput">cyg_cond_timed_wait</CODE>( 
    cyg_cond_t *<EM CLASS="Emphasis">cond,</EM>
    cyg_tick_count_t <EM CLASS="Emphasis">abstime )</EM>
</PRE>
  <P CLASS="Body"> <A NAME="pgfId=1026584"> </A> A time-out version of <CODE CLASS="CodeOutput"> 
    cyg_cond_wait()</CODE> which waits for a signal or broadcast. If a signal 
    or broadcast is received it returns <EM CLASS="parameter"> true,</EM> but 
    if one is not received by <EM CLASS="parameter"> abstime,</EM> it returns 
    <EM CLASS="parameter"> false.</EM> </P>
  <P CLASS="Body">The <i>cyg_tick_count_t</i> parameter is an absolute time. If 
    a relative time is required, you should use <code class="CodeOutput">cyg_current_time</code> 
    with an offset. For example, to time out 200 ticks from the present you would 
    use: <font face="Courier New, Courier, mono"><br>
    </font> </P>
  <pre class="Body"><font face="Courier New, Courier, mono">cyg_cond_timed_wait(&sem, cyg_current_time() + 200);</font></pre>
  <P CLASS="Body">
<A NAME="pgfId=1026621">
 </A>
<CODE CLASS="CodeOutput">
cyg_cond_timed_wait()</CODE>
 is only available if the configuration option <EM CLASS="parameter">
CYGMFN_KERNEL_SYNCH_CONDVAR_TIMED_WAIT</EM>
  is set. </P>
  <PRE CLASS="CodeExampleWide">void <CODE CLASS="CodeOutput">cyg_cond_signal</CODE>( 
    cyg_cond_t *<EM CLASS="Emphasis">cond )</EM>
</PRE>
<P CLASS="Body">
<A NAME="pgfId=1026660">
 </A>
Wakes up at least one thread which is waiting on the condition variable. When a thread is awakened it will become the owner of the mutex. <CODE CLASS="CodeOutput">
cyg_cond_signal()</CODE>
 may be called by the thread which currently owns the mutex to which the condition variable is attached. </P>
  <PRE CLASS="CodeExampleWide">void <CODE CLASS="CodeOutput">cyg_cond_broadcast</CODE>( 
    cyg_cond_t *<EM CLASS="Emphasis">cond )</EM>
</PRE>
<P CLASS="Body">
<A NAME="pgfId=1026716">
 </A>
Wakes <EM CLASS="Emphasis">
all</EM>
 the threads waiting on the condition variable. Each time a thread is awakened it will become the current owner of the mutex. </P>
</DIV>
<DIV>
<H3 CLASS="Heading1">
<A NAME="pgfId=1026735">
 </A>
<A NAME="36601">
 </A>
Memory pools</H3>
<P CLASS="Body">
<A NAME="pgfId=1026745">
 </A>
There are two sorts of <A NAME="marker=1084851">
 </A>
memory pools. A variable size memory pool is for allocating blocks of any size. A fixed size memory pool, has the block size specified when the pool is created and only provides blocks of that size.</P>
<P CLASS="Body">
<A NAME="pgfId=1026761">
 </A>
Blocking, non-blocking and &quot;blocking with time-out&quot; versions of these calls are provided. </P>
  <PRE CLASS="CodeExampleWide">void <CODE CLASS="CodeOutput">cyg_mempool_var_create</CODE>( 
    void *<EM CLASS="Emphasis">base,</EM>
    cyg_int32 <EM CLASS="Emphasis">size,</EM>
    cyg_handle_t *<EM CLASS="Emphasis">handle,</EM>
    cyg_mempool_var *<EM CLASS="Emphasis">var )</EM>
</PRE>
<P CLASS="Body">
<A NAME="pgfId=1026838">
 </A>
Creates a variable size memory pool. The parameters are:</P>
<P CLASS="BodyHang1">
<A NAME="pgfId=1026848">
 </A>
<EM CLASS="parameter">
base</EM>
 	</P>
<P CLASS="BodyListFollow">
<A NAME="pgfId=1026866">
 </A>
base of memory to use for pool</P>
<P CLASS="BodyHang1">
<A NAME="pgfId=1026876">
 </A>
<EM CLASS="parameter">
size</EM>
 	</P>
<P CLASS="BodyListFollow">
<A NAME="pgfId=1026890">
 </A>
size of memory pool in bytes</P>
<P CLASS="BodyHang1">
<A NAME="pgfId=1026900">
 </A>
<EM CLASS="parameter">
handle</EM>
 	</P>
<P CLASS="BodyListFollow">
<A NAME="pgfId=1026914">
 </A>
returned handle of memory pool</P>
<P CLASS="BodyHang1">
<A NAME="pgfId=1026924">
 </A>
<EM CLASS="parameter">
var</EM>
 	</P>
<P CLASS="BodyListFollow">
<A NAME="pgfId=1026938">
 </A>
space to put pool structure in</P>
  <PRE CLASS="CodeExampleWide"><A NAME="pgfId=1026948"> </A>
void <CODE CLASS="CodeOutput">cyg_mempool_var_delete</CODE>( 
    cyg_handle_t <EM CLASS="Emphasis">varpool )</EM>
</PRE>
<P CLASS="Body">
<A NAME="pgfId=1026977">
 </A>
Deletes the variable size memory pool <EM CLASS="parameter">
varpool.</EM>
</P>
  <PRE CLASS="CodeExampleWide">void *<CODE CLASS="CodeOutput">cyg_mempool_var_alloc</CODE>( 
    cyg_handle_t <EM CLASS="Emphasis">varpool,</EM>
    cyg_int32 <EM CLASS="Emphasis">size )</EM>
</PRE>
<P CLASS="Body">
<A NAME="pgfId=1027036">
 </A>
Allocates a block of length <EM CLASS="parameter">
size.</EM>
 This will block until the memory becomes available.</P>
  <PRE CLASS="CodeExampleWide">void *<CODE CLASS="CodeOutput">cyg_mempool_var_timed_alloc</CODE>( 
    cyg_handle_t <EM CLASS="Emphasis">varpool,</EM>
    cyg_int32 <EM CLASS="Emphasis">size,</EM>
    cyg_tick_count_t <EM CLASS="Emphasis">abstime )</EM>
</PRE>
<P CLASS="Body">
<A NAME="pgfId=1027131">
 </A>
Allocates a block of length size. If the requested amount of memory is not available, it will wait until <EM CLASS="parameter">
abstime</EM>
 before giving up and returning <EM CLASS="parameter">
NULL.</EM>
</P>
  <PRE CLASS="CodeExampleWide">void *<CODE CLASS="CodeOutput">cyg_mempool_var_try_alloc</CODE>( 
    cyg_handle_t <EM CLASS="Emphasis">varpool,</EM>
    cyg_int32 <EM CLASS="Emphasis">size )</EM>
</PRE>
<P CLASS="Body">
<A NAME="pgfId=1027182">
 </A>
Allocates a block of length size. <EM CLASS="parameter">
NULL</EM>
 is returned if not enough is available.</P>
  <PRE CLASS="CodeExampleWide">void <CODE CLASS="CodeOutput">cyg_mempool_var_free</CODE>( 
    cyg_handle_t <EM CLASS="Emphasis">varpool,</EM>
    void *<EM CLASS="Emphasis">p )</EM>
</PRE>
<P CLASS="Body">
<A NAME="pgfId=1027241">
 </A>
Frees memory back into variable size pool.</P>
  <PRE CLASS="CodeExampleWide">cyg_bool_t <CODE CLASS="CodeOutput">cyg_mempool_var_waiting</CODE>( 
    cyg_handle_t <EM CLASS="Emphasis">varpool )</EM>
</PRE>
<P CLASS="Body">
<A NAME="pgfId=1027276">
 </A>
Returns true if any threads are waiting for memory in <EM CLASS="parameter">
pool.</EM>
</P>
  <PRE CLASS="CodeExample">typedef struct {
 cyg_int32 totalmem;
 cyg_int32 freemem;
 void *base;
 cyg_int32 size;
 cyg_int32 blocksize;
 cyg_int32 maxfree; // The largest free block
} cyg_mempool_info;</PRE>
  <PRE CLASS="CodeExampleWide"><A NAME="pgfId=1027323"> </A>
void <CODE CLASS="CodeOutput">cyg_mempool_var_get_info</CODE>( 
    cyg_handle_t <EM CLASS="Emphasis">varpool,</EM>
    cyg_mempool_info *<EM CLASS="Emphasis">info )</EM>
</PRE>
<P CLASS="Body">
<A NAME="pgfId=1027367">
 </A>
Puts information about a variable memory pool into the structure provided.</P>
  <PRE CLASS="CodeExampleWide">void <CODE CLASS="CodeOutput">cyg_mempool_fix_create</CODE>( 
    void *<EM CLASS="Emphasis">base,</EM>
    cyg_int32 <EM CLASS="Emphasis">size,</EM>
    cyg_int32 <EM CLASS="Emphasis">blocksize,</EM>
    cyg_handle_t *<EM CLASS="Emphasis">handle,</EM>
    cyg_mempool_fix *<EM CLASS="Emphasis">fix )</EM>
</PRE>
<P CLASS="Body">
<A NAME="pgfId=1027452">
 </A>
Create a fixed size memory pool. This function takes the following parameters:</P>
  <P CLASS="BodyHang1"> <A NAME="pgfId=1027462"> </A> <EM CLASS="parameter"> base</EM> 
  </P>
  <P CLASS="BodyHang1">base of memory to use for pool</P>
<P CLASS="BodyHang1">
<A NAME="pgfId=1027490">
 </A>
<EM CLASS="parameter">
size</EM>
 	</P>
<P CLASS="BodyListFollow">
<A NAME="pgfId=1027504">
 </A>
size of total space requested</P>
<P CLASS="BodyHang1">
<A NAME="pgfId=1027514">
 </A>
<EM CLASS="parameter">
blocksize</EM>
 	</P>
<P CLASS="BodyListFollow">
<A NAME="pgfId=1027528">
 </A>
size of individual elements</P>
<P CLASS="BodyHang1">
<A NAME="pgfId=1027538">
 </A>
<EM CLASS="parameter">
handle</EM>
 	</P>
<P CLASS="BodyListFollow">
<A NAME="pgfId=1027552">
 </A>
returned handle of memory pool</P>
<P CLASS="BodyHang1">
<A NAME="pgfId=1027562">
 </A>
<EM CLASS="parameter">
fix</EM>
 	</P>
<P CLASS="BodyListFollow">
<A NAME="pgfId=1027576">
 </A>
space to put pool structure in</P>
  <PRE CLASS="CodeExampleWide">void <CODE CLASS="CodeOutput">cyg_mempool_fix_delete</CODE>( 
    cyg_handle_t <EM CLASS="Emphasis">fixpool )</EM>
</PRE>
<P CLASS="Body">
<A NAME="pgfId=1027615">
 </A>
Deletes the given fixed size memory pool.</P>
  <PRE CLASS="CodeExampleWide">void *<CODE CLASS="CodeOutput">cyg_mempool_fix_alloc</CODE>( 
cyg_handle_t <EM CLASS="Emphasis">fixpool )</EM>
</PRE>
<P CLASS="Body">
<A NAME="pgfId=1027652">
 </A>
Allocates a block. If the memory is not available immediately, this blocks until the memory becomes available.</P>
  <PRE CLASS="CodeExampleWide">void *<CODE CLASS="CodeOutput">cyg_mempool_fix_timed_alloc</CODE>( 
    cyg_handle_t <EM CLASS="Emphasis">fixpool,</EM>
    cyg_tick_count_t <EM CLASS="Emphasis">abstime )</EM>
</PRE>
<P CLASS="Body">
<A NAME="pgfId=1027728">
 </A>
Allocates a block. If the memory is not already available, it will try until <EM CLASS="parameter">
abstime</EM>
 before giving up and returning a <EM CLASS="parameter">
NULL.</EM>
</P>
  <PRE CLASS="CodeExampleWide">void *<CODE CLASS="CodeOutput">cyg_mempool_fix_try_alloc</CODE>( 
    cyg_handle_t <EM CLASS="Emphasis">fixpool )</EM>
</PRE>
<P CLASS="Body">
<A NAME="pgfId=1027768">
 </A>
Allocates a block. NULL is returned if no memory is available.</P>
  <PRE CLASS="CodeExampleWide">void <CODE CLASS="CodeOutput">cyg_mempool_fix_free</CODE>( 
    cyg_handle_t <EM CLASS="Emphasis">fixpool,</EM>
    void *<EM CLASS="Emphasis">p )</EM>
</PRE>
<P CLASS="Body">
<A NAME="pgfId=1027819">
 </A>
Frees memory back into fixed size pool.</P>
  <PRE CLASS="CodeExampleWide">cyg_bool_t <CODE CLASS="CodeOutput">cyg_mempool_fix_waiting</CODE>( 
    cyg_handle_t <EM CLASS="Emphasis">fixpool )</EM>
</PRE>
<P CLASS="Body">
<A NAME="pgfId=1027854">
 </A>
Returns true if there are any threads waiting for memory in the given memory pool.</P>
  <PRE CLASS="CodeExampleWide">void <CODE CLASS="CodeOutput">cyg_mempool_fix_get_info</CODE>( 
    cyg_handle_t <EM CLASS="Emphasis">fixpool,</EM>
    cyg_mempool_info *<EM CLASS="Emphasis">info )</EM>
</PRE>
<P CLASS="Body">
<A NAME="pgfId=1027904">
 </A>
Puts information about a variable memory pool into the structure provided.</P>
  <P CLASS="Body"> <A NAME="pgfId=1214299"> </A> The fixed size memory pool simply 
    returns blocks of memory of exactly the blocksize requested. If the pool is 
    being used to allocate memory for a type that has alignment constraints (such 
    as 4-byte alignment), then it is up to the user to align the memory appropriately 
    for the type in question. Alternatively, choose a blocksize that is an exact 
    multiple of the required alignment.</P>
  <P CLASS="Body">The memory available from the memory pools will not be the same 
    size as the memory supplied to it. Some of the memory is used for internal 
    data structures of the allocator. cyg_mempool_fix_get_info() and cyg_mempool_var_get_info() 
    may be used to determine the available memory. </P>
</DIV>
<DIV>
<A NAME="MESSAGE-BOXES"></a>
<H3 CLASS="Heading1">
<A NAME="pgfId=1027912">
 </A>
<A NAME="marker=1084855">
 </A>
Message boxes</H3>
<P CLASS="Body">
<A NAME="pgfId=1027966">
 </A>
Message boxes are a primitive mechanism for exchanging messages between threads, inspired by the <EM CLASS="FmSymbol">
&#181</EM>
ITRON specification. A message box can be created with <CODE CLASS="CodeOutput">
cyg_mbox_create()</CODE>
 before the scheduler is started, and two threads in a typical producer/consumer relationship can access it. One thread, the producer, will use <CODE CLASS="CodeOutput">
cyg_mbox_put()</CODE>
 to make data available to the consumer thread which uses <CODE CLASS="CodeOutput">
cyg_mbox_get()</CODE>
 to access the data. </P>
<P CLASS="Body">
<A NAME="pgfId=1027994">
 </A>
The size of the internal message queue is configured by the <EM CLASS="parameter">
CYGNUM_KERNEL_SYNCH_MBOX_QUEUE_SIZE</EM>
 parameter (see &quot;Message box queue size&quot;, in Section V). The default value is 10. </P>
<P CLASS="Body">
<A NAME="pgfId=1028005">
 </A>
Blocking, non-blocking and &quot;blocking with time-out&quot; versions of these calls are provided. </P>
  <PRE CLASS="CodeExampleWide">void <CODE CLASS="CodeOutput">cyg_mbox_create</CODE>( 
    cyg_handle_t *<EM CLASS="Emphasis">handle,</EM>
    cyg_mbox *<EM CLASS="Emphasis">mbox )</EM>
</PRE>
<P CLASS="Body">
<A NAME="pgfId=1028057">
 </A>
Creates a message box using the space provided in the <EM CLASS="parameter">
mbox</EM>
 parameter, and returns a handle for future access to that message box.</P>
  <PRE CLASS="CodeExampleWide">void <CODE CLASS="CodeOutput">cyg_mbox_delete</CODE>( 
    cyg_handle_t <EM CLASS="Emphasis">mbox )</EM>
</PRE>
<P CLASS="Body">
<A NAME="pgfId=1028103">
 </A>
Deletes the given message box. </P>
  <PRE CLASS="CodeExampleWide">void *<CODE CLASS="CodeOutput">cyg_mbox_get</CODE>( 
    cyg_handle_t <EM CLASS="Emphasis">mbox )</EM>
</PRE>
<P CLASS="Body">
<A NAME="pgfId=1028138">
 </A>
Waits for a message to be available, then retrieves it and returns the address of the data. </P>
  <PRE CLASS="CodeExampleWide">void *<CODE CLASS="CodeOutput">cyg_mbox_timed_get</CODE>( 
    cyg_handle_t <EM CLASS="Emphasis">mbox,</EM>
    cyg_tick_count_t <EM CLASS="Emphasis">timeout )</EM>
</PRE>
<P CLASS="Body">
<A NAME="pgfId=1028221">
 </A>
Waits for a message to be available, but times out if <EM CLASS="parameter">
timeout</EM>
 time passes. This version of the function is only available if the configuration option <EM CLASS="parameter">
CYGFUN_KERNEL_THREADS_TIMER</EM>
 is turned on. </P>
  <PRE CLASS="CodeExampleWide">void *<CODE CLASS="CodeOutput">cyg_mbox_tryget</CODE>(
    cyg_handle_t <EM CLASS="Emphasis">mbox )</EM>
</PRE>
<P CLASS="Body">
<A NAME="pgfId=1028258">
 </A>
Checks to see if a message is ready. If no message is available it returns immediately with a return value of <EM CLASS="parameter">
NULL.</EM>
 If a message is available it retrieves it and returns the address of the data. </P>
  <PRE CLASS="CodeExampleWide"><A NAME="pgfId=1028283"> </A>
void *<CODE CLASS="CodeOutput">cyg_mbox_peek_item</CODE>( 
    cyg_handle_t <EM CLASS="Emphasis">mbox )</EM>
</PRE>
<P CLASS="Body">
<A NAME="pgfId=1028336">
 </A>
Checks to see if a message is ready, and if one is available returns the address of the data <EM CLASS="Emphasis">
without</EM>
 removing the message from the queue. If no message is available it returns <EM CLASS="parameter">
NULL.</EM>
 </P>
  <PRE CLASS="CodeExampleWide">cyg_bool_t <CODE CLASS="CodeOutput">cyg_mbox_put</CODE>( 
    cyg_handle_t <EM CLASS="Emphasis">mbox,</EM>
    void *<EM CLASS="Emphasis">item )</EM>
</PRE>
<P CLASS="Body">
<A NAME="pgfId=1028387">
 </A>
Places a message in the given message box. If the queue is full it will block until the message can be sent. It returns true if the message was successfully sent, and false if the message was not sent and its sleep was awakened by the kernel before the message could be sent. </P>
<P CLASS="Body">
<A NAME="pgfId=1028437">
 </A>
The <CODE CLASS="CodeOutput">
cyg_mbox_put()</CODE>
 function is only available if the <EM CLASS="parameter">
CYGMTH_MBOXT_PUT_CAN_WAIT</EM>
 configuration has been selected. </P>
  <PRE CLASS="CodeExampleWide">cyg_bool_t <CODE CLASS="CodeOutput">cyg_mbox_timed_put</CODE>( 
    cyg_handle_t <EM CLASS="Emphasis">mbox,</EM>
    void *<EM CLASS="Emphasis">item,</EM>
    cyg_tick_count_t <EM CLASS="Emphasis">abstime )</EM>
</PRE>
<P CLASS="Body">
<A NAME="pgfId=1028533">
 </A>
A time-out version of <CODE CLASS="CodeOutput">
cyg_mbox_put()</CODE>
. This will try to place the message in the given message box. If the queue is full, it will wait until <EM CLASS="parameter">
abstime</EM>
 before giving up and returning <EM CLASS="parameter">
false.</EM>
 </P>
<P CLASS="Body">
<A NAME="pgfId=1028594">
 </A>
The <CODE CLASS="CodeOutput">
cyg_mbox_timed_put()</CODE>
 function is only available if the both the <EM CLASS="parameter">
CYGMFN_KERNEL_SYNCH_MBOXT_PUT_CAN_WAIT</EM>
 and <EM CLASS="parameter">
CYGFUN_KERNEL_THREADS_TIMER</EM>
 configuration have been selected. </P>
  <PRE CLASS="CodeExampleWide">cyg_bool_t <CODE CLASS="CodeOutput">cyg_mbox_tryput</CODE>( 
    cyg_handle_t <EM CLASS="Emphasis">mbox,</EM>
    void *<EM CLASS="Emphasis">item )</EM>
</PRE>
<P CLASS="Body">
<A NAME="pgfId=1028666">
 </A>
Tries to place a message in the given message box. It returns <EM CLASS="parameter">
true</EM>
 if the message was successfully sent, and <EM CLASS="parameter">
false</EM>
 if the message could not be sent immediately, usually because the queue was full. </P>
  <PRE CLASS="CodeExampleWide">cyg_count32 <CODE CLASS="CodeOutput">cyg_mbox_peek</CODE>( 
    cyg_handle_t <EM CLASS="Emphasis">mbox )</EM>
</PRE>
<P CLASS="Body">
<A NAME="pgfId=1028709">
 </A>
Takes a peek at the queue and returns the number of messages waiting in it. </P>
  <PRE CLASS="CodeExampleWide">cyg_bool_t <CODE CLASS="CodeOutput">cyg_mbox_waiting_to_get</CODE>( 
    cyg_handle_t <EM CLASS="Emphasis">mbox )</EM>
</PRE>
<P CLASS="Body">
<A NAME="pgfId=1028769">
 </A>
Queries the kernel to see if other processes are waiting to receive a message in the given message box. Returns <EM CLASS="parameter">
true</EM>
 if other processes are waiting, <EM CLASS="parameter">
false</EM>
 otherwise. </P>
  <PRE CLASS="CodeExampleWide">cyg_bool_t <CODE CLASS="CodeOutput">cyg_mbox_waiting_to_put</CODE>( 
    cyg_handle_t <EM CLASS="Emphasis">mbox )</EM>
</PRE>
<P CLASS="Body">
<A NAME="pgfId=1028841">
 </A>
Queries the kernel to see if <EM CLASS="Emphasis">
other</EM>
 processes are waiting to send a message in the given message box. Returns <EM CLASS="parameter">
true</EM>
 if other processes are waiting, <EM CLASS="parameter">
false</EM>
 otherwise. </P>
</DIV>
<DIV>
<H3 CLASS="Heading1">
<A NAME="pgfId=1028851">
 </A>
Flags</H3>
<P CLASS="Body">
<A NAME="pgfId=1028861">
 </A>
Flags are a <A NAME="marker=1084858">
 </A>
synchronization mechanism which allow a thread to wait for a single condition or a combination of conditions. The conditions are represented by bits in a 32 bit word. Flags are inspired by the <EM CLASS="FmSymbol">
&#181</EM>
<A NAME="marker=1084862">
 </A>
ITRON specification.</P>
<P CLASS="Body">
<A NAME="pgfId=1028876">
 </A>
Flags are of type cyg_flag_t, which are 32 bit words, and routines are provided to set or mask some bits in the flag value. </P>
<P CLASS="Body">
<A NAME="pgfId=1028896">
 </A>
A &quot;consumer side&quot; thread can wait for a &quot;producer side&quot; thread to set the entire collection of bits, or any subset of them.</P>
<P CLASS="Body">
<A NAME="pgfId=1028913">
 </A>
When a thread sets some bits in a flag, all threads whose requirements are now satisfied are woken up; thus flags have broadcast semantics. A variation on the wait call can specify that the flag value be cleared when the wait call is satisfied, in which case the setting of bits would not be a broadcast. </P>
<P CLASS="Body">
<A NAME="pgfId=1028932">
 </A>
Blocking, non-blocking, and &quot;blocking with time-out&quot; versions of the wait calls are provided. </P>
  <PRE CLASS="CodeExampleWide">void <CODE CLASS="CodeOutput">cyg_flag_init</CODE>( 
    cyg_flag_t *<EM CLASS="Emphasis">flag )</EM>
</PRE>
<P CLASS="Body">
<A NAME="pgfId=1028972">
 </A>
Initializes a flag variable.</P>
  <PRE CLASS="CodeExampleWide">void <CODE CLASS="CodeOutput">cyg_flag_destroy</CODE>( 
    cyg_flag_t *<EM CLASS="Emphasis">flag )</EM>
</PRE>
<P CLASS="Body">
<A NAME="pgfId=1029006">
 </A>
Destroys a flag variable.</P>
  <PRE CLASS="CodeExampleWide">void <CODE CLASS="CodeOutput">cyg_flag_setbits</CODE>( 
    cyg_flag_t *<EM CLASS="Emphasis">flag,</EM>
    cyg_flag_value_t <EM CLASS="Emphasis">value )</EM>
</PRE>
<P CLASS="Body">
<A NAME="pgfId=1029070">
 </A>
Sets the bits in <EM CLASS="parameter">
flag</EM>
 which are set in <EM CLASS="parameter">
value.</EM>
</P>
<P CLASS="Body">
<A NAME="pgfId=1029079">
 </A>
A side effect of <CODE CLASS="CodeOutput">
cyg_flag_setbits()</CODE>
 is that the kernel wakes up any waiting threads whose requirements are now satisfied. </P>
<P CLASS="BodyHang1">
<A NAME="pgfId=1029099">
 </A>
<EM CLASS="parameter">
flag</EM>
 	</P>
  <P CLASS="BodyListFollow"> <A NAME="pgfId=1029142"> </A> A pointer to the flag 
    whose bits are being set. The new setting of <EM CLASS="parameter"> flag</EM> 
    will be <CODE CLASS="Code"> *flag -&gt;(*flag | value)</CODE> .</P>
<P CLASS="BodyHang1">
<A NAME="pgfId=1029152">
 </A>
<EM CLASS="parameter">
value</EM>
 	</P>
<P CLASS="BodyListFollow">
<A NAME="pgfId=1029166">
 </A>
A word whose 1 bits will be also set in <EM CLASS="parameter">
*flag.</EM>
 </P>
  <PRE CLASS="CodeExampleWide"><A NAME="pgfId=1029187"> </A>
void <CODE CLASS="CodeOutput">cyg_flag_maskbits</CODE>( 
    cyg_flag_t *<EM CLASS="Emphasis">flag,</EM>
    cyg_flag_value_t <EM CLASS="Emphasis">value )</EM>
</PRE>
<P CLASS="Body">
<A NAME="pgfId=1029228">
 </A>
Clear the bits in the given flag which are zero in the <EM CLASS="parameter">
value.</EM>
 This cannot result in new threads being eligible for awakening.</P>
<P CLASS="BodyHang1">
<A NAME="pgfId=1029248">
 </A>
<EM CLASS="parameter">
flag</EM>
 	</P>
  <P CLASS="BodyListFollow"> <A NAME="pgfId=1029291"> </A> A pointer to the flag 
    whose bits are being cleared. The new setting of <EM CLASS="parameter"> flag</EM> 
    will be <CODE CLASS="Code"> *flag -&gt;(*flag &amp; value)</CODE> .</P>
<P CLASS="BodyHang1">
<A NAME="pgfId=1029303">
 </A>
<EM CLASS="parameter">
value</EM>
 	</P>
<P CLASS="BodyListFollow">
<A NAME="pgfId=1029317">
 </A>
A word whose 0 bits will be also cleared in <EM CLASS="parameter">
*flag.</EM>
 </P>
<P CLASS="Body">
<A NAME="pgfId=1029338">
 </A>
We now describe the <CODE CLASS="CodeOutput">
cyg_flag_wait()</CODE>
, which frequently uses the following macros: </P>
  <PRE CLASS="CodeExample"> #define CYG_FLAG_WAITMODE_AND ((cyg_flag_mode_t)0)
 #define CYG_FLAG_WAITMODE_OR ((cyg_flag_mode_t)2)
 #define CYG_FLAG_WAITMODE_CLR ((cyg_flag_mode_t)1)</PRE>
  <PRE CLASS="CodeExampleWide"><A NAME="pgfId=1029372"> </A>cyg_flag_value_t <CODE CLASS="CodeOutput">cyg_flag_wait</CODE>( 
    cyg_flag_t *<EM CLASS="Emphasis">flag,</EM>
    cyg_flag_value_t <EM CLASS="Emphasis">pattern,</EM>
    cyg_flag_mode_t <EM CLASS="Emphasis">mode )</EM>
</PRE>
<P CLASS="Body">
<A NAME="pgfId=1029491">
 </A>
Wait for all the bits which are one in <EM CLASS="parameter">
pattern</EM>
 to be set in the <EM CLASS="parameter">
flag</EM>
 value (if <EM CLASS="parameter">
mode</EM>
 is <EM CLASS="parameter">
CYG_FLAG_WAITMODE_AND</EM>
) or for any of the bits which are one in pattern to be set in the flag value (if <EM CLASS="parameter">
mode</EM>
 is <EM CLASS="parameter">
CYG_FLAG_WAITMODE_OR</EM>
).</P>
<P CLASS="Body">
<A NAME="pgfId=1029533">
 </A>
When <CODE CLASS="CodeOutput">
cyg_flag_wait()</CODE>
 returns, meaning that the condition is met, the flag value which succeeded is returned from the call; in other circumstances (such as a bad value for <EM CLASS="parameter">
mode</EM>
 or <EM CLASS="parameter">
pattern</EM>
), zero is returned to indicate the error.</P>
<P CLASS="Body">
<A NAME="pgfId=1029544">
 </A>
If the mode is one of those above plus <EM CLASS="parameter">
CYG_FLAG_WAITMODE_CLR,</EM>
 the whole of the flag value is cleared to zero when the condition is met. </P>
<P CLASS="Body">
<A NAME="pgfId=1029563">
 </A>
<CODE CLASS="CodeOutput">
cyg_flag_wait()</CODE>
 takes the following parameters: </P>
<P CLASS="BodyHang1">
<A NAME="pgfId=1029579">
 </A>
<EM CLASS="parameter">
flag</EM>
 	</P>
<P CLASS="BodyListFollow">
<A NAME="pgfId=1029619">
 </A>
The value of the flag (set by the thread that called <CODE CLASS="CodeOutput">
cyg_flag_setbits()</CODE>
 or <CODE CLASS="CodeOutput">
cyg_flag_maskbits()</CODE>
) is placed in here.</P>
<P CLASS="BodyHang1">
<A NAME="pgfId=1029630">
 </A>
<EM CLASS="parameter">
pattern</EM>
 	</P>
<P CLASS="BodyListFollow">
<A NAME="pgfId=1029644">
 </A>
The set of bits which, if set, will cause the calling thread to be woken up. </P>
<P CLASS="BodyHang1">
<A NAME="pgfId=1029657">
 </A>
<EM CLASS="parameter">
mode</EM>
 	</P>
<P CLASS="BodyListFollow">
<A NAME="pgfId=1029671">
 </A>
A parameter which modifies the conditions for wake-up. It can take the following values: </P>
<P CLASS="BodyHang1">
<A NAME="pgfId=1029684">
 </A>
<EM CLASS="parameter">
CYG_FLAG_WAITMODE_AND</EM>
 	</P>
<P CLASS="BodyListFollow">
<A NAME="pgfId=1029724">
 </A>
Only wake up if <EM CLASS="Emphasis">
all</EM>
 the bits in <EM CLASS="parameter">
mask</EM>
 is set in the flag.</P>
<P CLASS="BodyHang1">
<A NAME="pgfId=1029735">
 </A>
<EM CLASS="parameter">
CYG_FLAG_WAITMODE_OR</EM>
 	</P>
<P CLASS="BodyListFollow">
<A NAME="pgfId=1029771">
 </A>
Wake up if <EM CLASS="Emphasis">
any</EM>
 of the bits in <EM CLASS="parameter">
mask</EM>
 is set in the flag. </P>
<P CLASS="BodyHang1">
<A NAME="pgfId=1029802">
 </A>
<EM CLASS="parameter">
CYG_FLAG_WAITMODE_AND</EM>
 + <EM CLASS="parameter">
CYG_FLAG_WAITMODE_CLR,</EM>
 </P>
<P CLASS="BodyHang1">
<A NAME="pgfId=1029823">
 </A>
<EM CLASS="parameter">
CYG_FLAG_WAITMODE_OR</EM>
 + <EM CLASS="parameter">
CYG_FLAG_WAITMODE_CLR</EM>
 	</P>
<P CLASS="BodyListFollow">
<A NAME="pgfId=1029867">
 </A>
Like <EM CLASS="parameter">
CYG_FLAG_WAITMODE_AND</EM>
 and <EM CLASS="parameter">
CYG_FLAG_WAITMODE_OR,</EM>
 but the entire flag is cleared to zero when the condition is met, whereas normally only the bits that are set in <EM CLASS="parameter">
pattern</EM>
 would be cleared. </P>
<P CLASS="Body">
<A NAME="pgfId=1029925">
 </A>
Waiting threads are queued depending on the semantics of the underlying scheduler. In release 1.3.x, this means that, if the multi-level queue scheduler is selected, queueing is in FIFO ordering, while the bitmap scheduler supports thread priority ordered queueing. When some flag value bits become signalled by a call to <CODE CLASS="CodeOutput">
cyg_flag_setbits()</CODE>
, the queue is scanned in order, and each waiting thread in turn is awoken or re-queued depending on its request. When a thread is awoken, if it made the wait call with <EM CLASS="parameter">
CYG_FLAG_WAITMODE_CLR,</EM>
 the flag value is cleared to zero, and the scan of queued threads is terminated. </P>
  <PRE CLASS="CodeExampleWide">cyg_flag_value_t <CODE CLASS="CodeOutput">cyg_flag_timed_wait</CODE>( 
    cyg_flag_t *<EM CLASS="Emphasis">flag,</EM>
    cyg_flag_value_t <EM CLASS="Emphasis">pattern,</EM>
    cyg_flag_mode_t <EM CLASS="Emphasis">mode,</EM>
    cyg_tick_count_t <EM CLASS="Emphasis">abstime )</EM>
</PRE>
<P CLASS="Body">
<A NAME="pgfId=1030045">
 </A>
A time-out version of <CODE CLASS="CodeOutput">
cyg_flag_wait()</CODE>
. This waits for the condition required by pattern and mode to be met, or until the abstime time-out is reached, whichever is first. If the time-out is reached first, zero is returned. This call is only available if the configuration option <EM CLASS="parameter">
CYGFUN_KERNEL_THREADS_TIMER</EM>
  is enabled. </P>
  <PRE CLASS="CodeExampleWide">cyg_flag_value_t <CODE CLASS="CodeOutput">cyg_flag_poll</CODE>( 
    cyg_flag_t *<EM CLASS="Emphasis">flag,</EM>
    cyg_flag_value_t <EM CLASS="Emphasis">pattern,</EM>
    cyg_flag_mode_t <EM CLASS="Emphasis">mode )</EM>
</PRE>
<P CLASS="Body">
<A NAME="pgfId=1030138">
 </A>
A non-blocking version of <CODE CLASS="CodeOutput">
cyg_flag_wait()</CODE>
. If the condition required by pattern and mode is met, the flag value is returned, otherwise zero is returned. The flag value may be cleared in the event of success by specifying <EM CLASS="parameter">
CYG_FLAG_WAITMODE_CLR</EM>
 in the mode, as usual. </P>
  <PRE CLASS="CodeExampleWide">cyg_flag_value_t <CODE CLASS="CodeOutput">cyg_flag_peek</CODE>( 
    cyg_flag_t *<EM CLASS="Emphasis">flag )</EM>
</PRE>
<P CLASS="Body">
<A NAME="pgfId=1030179">
 </A>
Returns the current flag value.</P>
  <PRE CLASS="CodeExampleWide">cyg_bool_t <CODE CLASS="CodeOutput">cyg_flag_waiting</CODE>( 
    cyg_flag_t *<EM CLASS="Emphasis">flag )</EM>
</PRE>
<P CLASS="Body">
<A NAME="pgfId=1030214">
 </A>
Returns true if there are threads waiting on this flag.</P>
<TABLE>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
</TD>
</TR>
</TABLE>
</DIV>
<HR ALIGN="center"><TABLE STYLE="ECOS" WIDTH="98%" BORDER="0" ALIGN="LEFT" CELLPADDING="1"><TR><TH COLSPAN="3" ALIGN="center"><P CLASS="Gotos">Native kernel C language API</P></TH></TR><TR><TD  ALIGN="center"><P CLASS="Gotos"><A HREF="ecos-ref.2.html">To Contents</A></P></TD><TD  ALIGN="center"><P CLASS="Gotos"><A HREF="ecos-ref.8.html">To&nbsp;previous&nbsp;page</A></P></TD><TD  ALIGN="center"><P CLASS="Gotos"><A HREF="ecos-ref.a.html">To&nbsp;next&nbsp;page</A></P></TD></TR></TABLE></BODY>
</HTML>
