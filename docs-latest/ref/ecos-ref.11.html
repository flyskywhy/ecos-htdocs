<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML EXPERIMENTAL 970324//EN">
<HTML>
<HEAD><!--version 1.3.4/Thur May 4 2000-->
<META NAME="GENERATOR" CONTENT="Adobe FrameMaker 5.5/HTML Export Filter">
<LINK REL="STYLESHEET" HREF="cygnus.css">
<TITLE> Serial driver details</TITLE></HEAD>
<BODY BGCOLOR="#ffffff">
<DIV>
<TABLE STYLE="ECOS" WIDTH="98%" BORDER="0" ALIGN="LEFT" CELLPADDING="1"><TR><TH COLSPAN="3" ALIGN="center"><P CLASS="Gotos">Serial driver details</P></TH></TR><TR><TD  ALIGN="center"><P CLASS="Gotos"><A HREF="ecos-ref.2.html">To Contents</A></P></TD><TD  ALIGN="center"><P CLASS="Gotos"><A HREF="ecos-ref.10.html">To&nbsp;previous&nbsp;page</A></P></TD><TD ALIGN="center"><P CLASS="Gotos"><A HREF="ecos-ref.12.html">To&nbsp;next&nbsp;page</A></P></TD></TR></TABLE><P ALIGN="LEFT">&nbsp;</P><BR><BR><HR ALIGN="center"></DIV>
<H2 CLASS="ChapterTitle">
<A NAME="pgfId=1079279">
 </A>
Serial driver details<DIV>
<IMG SRC="botclear.gif">
</DIV>
</H2>
<P CLASS="Body">
<A NAME="pgfId=1079283">
 </A>
Two different classes of serial drivers are provided as a standard part of the eCos system. These are described as &quot;simple serial&quot; (serial) and &quot;tty-like&quot; (tty). </P>
<DIV>
<H3 CLASS="Heading1">
<A NAME="pgfId=1079292">
 </A>
&quot;simple serial&quot; driver</H3>
<P CLASS="Body">
<A NAME="pgfId=1079306">
 </A>
Use the include file <CODE CLASS="Code">
cyg/io/serialio.h</CODE>
 for this driver. </P>
<P CLASS="Body">
<A NAME="pgfId=1079312">
 </A>
The <A NAME="marker=1079310">
 </A>
simple serial driver is capable of sending and receiving blocks of raw data to a serial device. Controls are provided to configure the actual hardware, but there is no manipulation of the data by this driver. </P>
<P CLASS="Body">
<A NAME="pgfId=1079317">
 </A>
There may be many instances of this driver in a given system, one for each serial channel. Each channel corresponds to a physical device and there will typically be a device module created for this purpose. The device modules themselves are configurable, allowing specification of the actual hardware details, as well as such details as whether the channel should be buffered by the serial driver, etc. </P>
<H3 CLASS="Heading2">
<A NAME="pgfId=1079326">
 </A>
Runtime configuration</H3>
<PRE CLASS="CodeExample"><A NAME="pgfId=1079330"> </A>
typedef struct {
 cyg_serial_baud_rate_t baud;
 cyg_serial_stop_bits_t stop;
 cyg_serial_parity_t parity;
 cyg_serial_word_length_t word_length;
 cyg_uint32 flags;
} cyg_serial_info_t;
	</PRE>
<P CLASS="Body">
<A NAME="pgfId=1079337">
 </A>
The field '<A NAME="marker=1079335">
 </A>
word_length' contains the number of data bits per word (character). This must be one of the values:</P>
<PRE CLASS="CodeExample"><A NAME="pgfId=1079342"> </A>
 CYGNUM_SERIAL_WORD_LENGTH_5
 CYGNUM_SERIAL_WORD_LENGTH_6
 CYGNUM_SERIAL_WORD_LENGTH_7
 CYGNUM_SERIAL_WORD_LENGTH_8
	</PRE>
<P CLASS="Body">
<A NAME="pgfId=1079350">
 </A>
The field '<A NAME="marker=1079347">
 </A>
baud' contains a baud rate selection. This must be one of the values:</P>
<PRE CLASS="CodeExample"><A NAME="pgfId=1079354"> </A>
 CYGNUM_SERIAL_BAUD_50
 CYGNUM_SERIAL_BAUD_75
 CYGNUM_SERIAL_BAUD_110
 CYGNUM_SERIAL_BAUD_134_5
 CYGNUM_SERIAL_BAUD_150
 CYGNUM_SERIAL_BAUD_200
 CYGNUM_SERIAL_BAUD_300
 CYGNUM_SERIAL_BAUD_600
 CYGNUM_SERIAL_BAUD_1200
 CYGNUM_SERIAL_BAUD_1800
 CYGNUM_SERIAL_BAUD_2400
 CYGNUM_SERIAL_BAUD_3600
 CYGNUM_SERIAL_BAUD_4800
 CYGNUM_SERIAL_BAUD_7200
 CYGNUM_SERIAL_BAUD_9600
 CYGNUM_SERIAL_BAUD_14400
 CYGNUM_SERIAL_BAUD_19200
 CYGNUM_SERIAL_BAUD_38400
 CYGNUM_SERIAL_BAUD_57600
 CYGNUM_SERIAL_BAUD_115200
 CYGNUM_SERIAL_BAUD_234000
	</PRE>
<P CLASS="Body">
<A NAME="pgfId=1079362">
 </A>
The field '<A NAME="marker=1079359">
 </A>
stop' contains the number of stop bits. This must be one of the values:</P>
<PRE CLASS="CodeExample"><A NAME="pgfId=1079366"> </A>
 CYGNUM_SERIAL_STOP_1
 CYGNUM_SERIAL_STOP_1_5
 CYGNUM_SERIAL_STOP_2
	</PRE>
<H3 CLASS="Label">
<A NAME="pgfId=1079374">
 </A>
NOTE</H3>
<P CLASS="Note">
<A NAME="pgfId=1079378">
 </A>
On most hardware, a selection of 1.5 stop bits is only valid if the word (character) length is 5.</P>
<P CLASS="Body">
<A NAME="pgfId=1079387">
 </A>
The field '<A NAME="marker=1079384">
 </A>
parity' contains the parity mode. This must be one of the values: </P>
<PRE CLASS="CodeExample"><A NAME="pgfId=1079391"> </A>
 CYGNUM_SERIAL_PARITY_NONE
 CYGNUM_SERIAL_PARITY_EVEN
 CYGNUM_SERIAL_PARITY_ODD
 CYGNUM_SERIAL_PARITY_MARK
 CYGNUM_SERIAL_PARITY_SPACE
	</PRE>
<P CLASS="Body">
<A NAME="pgfId=1079398">
 </A>
The field '<A NAME="marker=1079396">
 </A>
flags' is a bitmask which controls the behavior of the serial device driver. It should be built from the values <CODE CLASS="CodeOutput">
CYG_SERIAL_FLAGS_xxx</CODE>
 defined below: </P>
<PRE CLASS="CodeExample"><A NAME="pgfId=1079407"> </A>
#define CYG_SERIAL_FLAGS_RTSCTS 0x0001
	</PRE>
  <P CLASS="Body"> <A NAME="pgfId=1079412"> </A> If this bit is set then the port 
    is placed in &quot;hardware handshake&quot; mode. In this mode, the CTS and 
    RTS pins control when data is allowed to be sent/received at the port. This 
    bit is ignored if the hardware does not support this level of handshake. </P>
  <pre CLASS="Body"><font size="3">typedef struct {
 cyg_int32 rx_bufsize;
 cyg_int32 rx_count;
 cyg_int32 tx_bufsize;
 cyg_int32 tx_count; <br>}
cyg_serial_buf_info_t;</font></pre>
  <P CLASS="Body"> The field 'rx_bufsize' contains the total size of the incoming 
    data buffer. This is set to 0 on devices that do not support buffering (i.e. 
    polled devices). </P>
  <P CLASS="Body">The field 'rx_count' contains the number of bytes currently 
    occupied in the incoming data buffer. This is set to 0 on devices that do 
    not support buffering (i.e. polled devices). </P>
  <P CLASS="Body">The field 'tx_bufsize' contains the total size of the transmit 
    data buffer. This is set to 0 on devices that do not support buffering (i.e. 
    polled devices). </P>
  <P CLASS="Body">The field 'tx_count' contains the number of bytes currently 
    occrupied in the transmit data buffer. This is set to 0 on devices that do 
    not support buffering (i.e. polled devices).</P>
<H3 CLASS="Heading2">
<A NAME="pgfId=1079424">
 </A>
<A NAME="marker=1079421">
 </A>
API details</H3>
  <PRE CLASS="CodeExample"><A NAME="pgfId=1079428"> </A>
 <CODE CLASS="CodeOutput">cyg_io_write</CODE>(handle, buf, len)
	</PRE>
  <P CLASS="Body"> <A NAME="pgfId=1079433"> </A> Send the data from 'buf' to the 
    device. The driver maintains a buffer to hold the data. The size of the intermediate 
    buffer is configurable within the interface module. The data is not modified 
    at all while it is being buffered. On return, *len contains the amount of 
    actually consumed characters. </P>
  <P CLASS="Body">It is possible to configure the write call to be blocking (default) 
    or non-blocking. Non-blocking mode requires both the configuration option 
    CYGOPT_IO_SERIAL_SUPPORT_NONBLOCKING to be enabled, and the specific device 
    to be set to non-blocking mode for writes (see cyg_io_set_config). </P>
  <P CLASS="Body">In blocking mode, the call will not return until there is space 
    in the driver's internal buffer and the entire contents of "buf" have been 
    consumed. </P>
  <P CLASS="Body">In non-blocking mode, as much as possible gets consumed from 
    "buf". If everything was consumed, the call returns ENOERR. If only part of 
    the "buf" contents was consumed, -EAGAIN is returned and the caller must try 
    again. </P>
  <P CLASS="Body">On return, *len contains the amount of characters actually consumed.</P>
  <P CLASS="Body">The call can also return -EINTR if interrupted via the cyg_io_get_config/ABORT 
    key. </P>
  <P CLASS="Body">On return, *len contains the amount of characters actually consumed.</P>
  <PRE CLASS="CodeExample"><A NAME="pgfId=1079438"> </A>
 <CODE CLASS="CodeOutput">cyg_io_read</CODE>(handle, buf, len)
	</PRE>
  <P CLASS="Body"> <A NAME="pgfId=1079443"> </A> Receive data into the specified 
    buffer from the device. No manipulation of the data is performed before being 
    transferred. An interrupt driven interface module will support data arriving 
    when no read is pending by buffering the data in the serial driver. Again, 
    this buffering is completely configurable. On return, *len contains the amount 
    of actually received characters. </P>
  <P CLASS="Body">It is possible to configure the read call to be blocking (default) 
    or non-blocking. Non-blocking mode requires both the configuration option 
    CYGOPT_IO_SERIAL_SUPPORT_NONBLOCKING to be enabled, and the specific device 
    to be set to non-blocking mode for reads (see cyg_io_set_config). </P>
  <P CLASS="Body">In blocking mode, the call will not return until the requested 
    amount of data has been read. </P>
  <P CLASS="Body">In non-blocking mode, data waiting in the device buffer is copied 
    to 'buf', and the call returns immediately. If there was enough data in the 
    buffer to fulfill the request, ENOERR is returned. If only part of the request 
    could be fulfilled, -EAGAIN is returned and the caller must try again. </P>
  <P CLASS="Body">On return, *len contains the amount of characters actually received.</P>
  <P CLASS="Body">The call can also return -EINTR if interrupted via the cyg_io_get_config/ABORT 
    key. </P>
  <P CLASS="Body">On return, *len contains the amount of characters actually received.</P>
  <PRE CLASS="CodeExample"><A NAME="pgfId=1079448"> </A>
 <CODE CLASS="CodeOutput">cyg_io_get_config</CODE>(handle, key, buf, len)
	</PRE>
<P CLASS="Body">
<A NAME="pgfId=1079454">
 </A>
This function returns current [runtime] information about the device and/or driver. </P>
<P CLASS="BodyHang1">
<A NAME="pgfId=1079468">
 </A>
Key: 	</P>
<P CLASS="BodyListFollow">
<A NAME="pgfId=1079478">
 </A>
CYG_IO_GET_CONFIG_SERIAL_INFO</P>
<P CLASS="BodyHang1">
<A NAME="pgfId=1079489">
 </A>
Buf type: 	</P>
<P CLASS="BodyListFollow">
<A NAME="pgfId=1079499">
 </A>
cyg_serial_info_t</P>
<P CLASS="BodyHang1">
<A NAME="pgfId=1079510">
 </A>
Function: 	</P>
  <P CLASS="BodyListFollow"> <A NAME="pgfId=1079517"> </A> This function retrieves 
    the current state of the driver and hardware. This information contains fields 
    for hardware baud rate, number of stop bits, and parity mode. It also includes 
    a set of flags that control the port, such as hardware flow control.</P>
  <p class="BodyHang1">Key: </p>
  <p class="BodyListFollow">CYG_IO_GET_CONFIG_SERIAL_BUFFER_INFO </p>
  <p class="BodyHang1">Buf type: </p>
  <p class="BodyListFollow">cyg_serial_buf_info_t </p>
  <p class="BodyHang1">Function: </p>
  <p class="BodyListFollow">This function retrieves the current state of the software 
    buffers in the serial drivers. For both receive and transmit buffers, it returns 
    the total buffer size and the current number of bytes occupied in the buffer. 
    It does not take into account any buffering such as FIFOs or holding registers 
    that the serial device itself may have.</p>
  <P CLASS="BodyHang1">
<A NAME="pgfId=1079554">
 </A>
Key: 	</P>
<P CLASS="BodyListFollow">
<A NAME="pgfId=1079564">
 </A>
CYG_IO_GET_CONFIG_SERIAL_OUTPUT_DRAIN</P>
<P CLASS="BodyHang1">
<A NAME="pgfId=1079575">
 </A>
Buf type: 	</P>
<P CLASS="BodyListFollow">
<A NAME="pgfId=1079585">
 </A>
void *</P>
<P CLASS="BodyHang1">
<A NAME="pgfId=1079596">
 </A>
Function: 	</P>
<P CLASS="BodyListFollow">
<A NAME="pgfId=1079603">
 </A>
This function waits for any buffered output to complete. This function only completes when there is no more data remaining to be sent to the device.</P>
<P CLASS="BodyHang1">
<A NAME="pgfId=1079621">
 </A>
Key: 	</P>
<P CLASS="BodyListFollow">
<A NAME="pgfId=1079631">
 </A>
CYG_IO_GET_CONFIG_SERIAL_OUTPUT_FLUSH</P>
<P CLASS="BodyHang1">
<A NAME="pgfId=1079642">
 </A>
Buf type: 	</P>
<P CLASS="BodyListFollow">
<A NAME="pgfId=1079652">
 </A>
void *</P>
<P CLASS="BodyHang1">
<A NAME="pgfId=1079663">
 </A>
Function: 	</P>
<P CLASS="BodyListFollow">
<A NAME="pgfId=1079674">
 </A>
This function discards any buffered output for the device.</P>
<P CLASS="BodyHang1">
<A NAME="pgfId=1079688">
 </A>
Key: 	</P>
<P CLASS="BodyListFollow">
<A NAME="pgfId=1079698">
 </A>
CYG_IO_GET_CONFIG_SERIAL_INPUT_DRAIN</P>
<P CLASS="BodyHang1">
<A NAME="pgfId=1079709">
 </A>
Buf type: 	</P>
<P CLASS="BodyListFollow">
<A NAME="pgfId=1079719">
 </A>
void *</P>
<P CLASS="BodyHang1">
<A NAME="pgfId=1079730">
 </A>
Function: 	</P>
<P CLASS="BodyListFollow">
<A NAME="pgfId=1079743">
 </A>
This function discards any buffered input for the device.</P>
  <p class="BodyHang1">Key: </p>
  <p class="BodyListFollow">CYG_IO_GET_CONFIG_SERIAL_ABORT </p>
  <p class="BodyHang1">Buf type: </p>
  <p class="BodyListFollow">void* </p>
  <p class="BodyHang1">Fu<span class="BodyHang1">n</span>ction: </p>
  <p class="BodyListFollow">This function will cause any pending read or write 
    calls on this device to return with -EABORT. </p>
  <p class="BodyHang1">Key: </p>
  <p class="BodyListFollow">CYG_IO_GET_CONFIG_SERIAL_READ_BLOCKING </p>
  <p class="BodyHang1">Buf type: </p>
  <p class="BodyListFollow">cyg_uint32 (values 0 or 1) </p>
  <p class="BodyHang1">Function: </p>
  <p class="BodyListFollow">This function will read back the blocking-mode setting 
    for read calls on this device. This call is only available if the configuration 
    option CYGOPT_IO_SERIAL_SUPPORT_NONBLOCKING is enabled. </p>
  <p class="BodyHang1">Key:</p>
  <p class="BodyListFollow"> CYG_IO_GET_CONFIG_SERIAL_WRITE_BLOCKING </p>
  <p class="BodyHang1">Buf type: </p>
  <p class="BodyListFollow">cyg_uint32 (values 0 or 1) </p>
  <p class="BodyHang1">Function: </p>
  <p class="BodyListFollow">This function will read back the blocking-mode setting 
    for write calls on this device. This call is only available if the configuration 
    option CYGOPT_IO_SERIAL_SUPPORT_NONBLOCKING is enabled. </p>
  <PRE CLASS="CodeExample"><A NAME="pgfId=1091104"> </A>
 <CODE CLASS="CodeOutput">cyg_io_set_config</CODE>(handle, key, buf, len)
	</PRE>
<P CLASS="Body">
<A NAME="pgfId=1091110">
 </A>
This function is used to update or change runtime configuration of a port.</P>
  <P CLASS="BodyHang1"> <A NAME="pgfId=1091114"> </A> <span class="BodyHang1">Key: 
    </span></P>
  <P CLASS="BodyListFollow">CYG_IO_SET_CONFIG_SERIAL_INFO </P>
  <P CLASS="BodyHang1">Buf type: </P>
  <P CLASS="BodyListFollow">cyg_serial_info_t </P>
  <P CLASS="BodyHang1">Function: </P>
  <P CLASS="BodyListFollow">This function updates the information for the driver 
    and hardware. The information contains fields for hardware baud rate, number 
    of stop bits, and parity mode. It also includes a set of flags that control 
    the port, such as hardware flow control. </P>
  <P CLASS="BodyHang1">Key: </P>
  <P CLASS="BodyListFollow">CYG_IO_SET_CONFIG_SERIAL_READ_BLOCKING </P>
  <P CLASS="Body">Buf type: </P>
  <P CLASS="BodyListFollow">cyg_uint32 (values 0 or 1) </P>
  <P CLASS="BodyHang1">Function: </P>
  <P CLASS="BodyListFollow">This function will set the blocking-mode for read 
    calls on this device. This call is only available if the configuration option 
    CYGOPT_IO_SERIAL_SUPPORT_NONBLOCKING is enabled. </P>
  <P CLASS="Body">Key: </P>
  <P CLASS="BodyListFollow">CYG_IO_SET_CONFIG_SERIAL_WRITE_BLOCKING </P>
  <P CLASS="BodyHang1">Buf type: </P>
  <P CLASS="BodyListFollow">cyg_uint32 (values 0 or 1) </P>
  <P CLASS="BodyHang1">Function: </P>
  <P CLASS="BodyListFollow">This function will set the blocking-mode for write 
    calls on this device. This call is only available if the configuration option 
    CYGOPT_IO_SERIAL_SUPPORT_NONBLOCKING is enabled. </P>
</DIV>
<DIV>
<H3 CLASS="Heading1">
<A NAME="pgfId=1079751">
 </A>
&quot;tty&quot; driver</H3>
<P CLASS="Body">
<A NAME="pgfId=1079760">
 </A>
Use the include file <CODE CLASS="Code">
cyg/io/ttyio.h</CODE>
 for this driver. </P>
<P CLASS="Body">
<A NAME="pgfId=1079766">
 </A>
This <A NAME="marker=1079764">
 </A>
driver is built on top of the simple serial driver and is typically used for a device that interfaces with humans such as a terminal. It provides some minimal formatting of data on output and allows for line-oriented editing on input. </P>
<H3 CLASS="Heading2">
<A NAME="pgfId=1079775">
 </A>
Runtime configuration</H3>
<PRE CLASS="CodeExample"><A NAME="pgfId=1079779"> </A>
typedef struct {
 cyg_uint32 tty_out_flags;
 cyg_uint32 tty_in_flags;
} cyg_tty_info_t;
	</PRE>
<P CLASS="Body">
<A NAME="pgfId=1079786">
 </A>
The field '<A NAME="marker=1079784">
 </A>
tty_out_flags' is used to control what happens to data as it is send to the serial port. It contains a bitmap comprised of the bits as defined by the <CODE CLASS="CodeOutput">
CYG_TTY_OUT_FLAGS_xxx</CODE>
 values below. </P>
<PRE CLASS="CodeExample"><A NAME="pgfId=1079795"> </A>
#define CYG_TTY_OUT_FLAGS_CRLF 0x0001 // Map '\n' =&gt; '\r\n' on output
 	</PRE>
<P CLASS="Body">
<A NAME="pgfId=1079802">
 </A>
If this bit is set in 'tty_out_flags', any occurrence of the character '\n' will be replaced by the sequence '\r\n' before sending to the device.</P>
<P CLASS="Body">
<A NAME="pgfId=1091476">
 </A>
The field '<A NAME="marker=1079800">
 </A>
tty_in_flags' is used to control how data is handles as it comes from the serial port. It contains a bitmap comprised of the bits as defined by the <CODE CLASS="CodeOutput">
CYG_TTY_IN_FLAGS_xxx</CODE>
 values below. </P>
<PRE CLASS="CodeExample"><A NAME="pgfId=1079811"> </A>
#define CYG_TTY_IN_FLAGS_CR 0x0001 // Map '\r' =&gt; '\n' on input
	</PRE>
<P CLASS="Body">
<A NAME="pgfId=1079816">
 </A>
If this bit is set in 'tty_in_flags', the character '\r' (&quot;return&quot; or &quot;enter&quot; on most keyboards) will be mapped to '\n'.</P>
<PRE CLASS="CodeExample"><A NAME="pgfId=1079821"> </A>
#define CYG_TTY_IN_FLAGS_CRLF 0x0002 // Map '\r\n' =&gt; '\n' on input
	</PRE>
<P CLASS="Body">
<A NAME="pgfId=1079826">
 </A>
If this bit is set in 'tty_in_flags', the character sequence '\r\n' (often sent by DOS/Windows based terminals) will be mapped to '\n'. </P>
<PRE CLASS="CodeExample"><A NAME="pgfId=1079831"> </A>
#define CYG_TTY_IN_FLAGS_BINARY 0x0004 // No input processing
	</PRE>
<P CLASS="Body">
<A NAME="pgfId=1079836">
 </A>
If this bit is set in 'tty_in_flags', the input will not be manipulated in any way before being placed in the user's buffer. </P>
<PRE CLASS="CodeExample"><A NAME="pgfId=1079841"> </A>
#define CYG_TTY_IN_FLAGS_ECHO 0x0008 // Echo characters as processed
	</PRE>
<P CLASS="Body">
<A NAME="pgfId=1079846">
 </A>
If this bit is set in 'tty_in_flags', characters will be echoed back to the serial port as they are processed. </P>
<H3 CLASS="Heading2">
<A NAME="pgfId=1079858">
 </A>
<A NAME="marker=1079855">
 </A>
API details</H3>
  <PRE CLASS="CodeExample"><A NAME="pgfId=1079862"> </A>
 <CODE CLASS="CodeOutput">cyg_io_read</CODE>(handle, buf, len)
	</PRE>
<P CLASS="Body">
<A NAME="pgfId=1079867">
 </A>
This function is used to read data from the device. In the default case, data is read until an end-of-line character ('\n' or '\r') is read. Additionally, the characters are echoed back to the [terminal] device. Minimal editing of the input is also supported. </P>
<H3 CLASS="Label">
<A NAME="pgfId=1214321">
 </A>
NOTE</H3>
<P CLASS="Note">
<A NAME="pgfId=1214336">
 </A>
When connecting to a remote target via GDB it is not possible to provide console input while GDB is connected. The GDB remote protocol does not support input. Users must disconnect from GDB if this functionality is required.</P>
  <PRE CLASS="CodeExample"><A NAME="pgfId=1079872"> </A>
	
 <CODE CLASS="CodeOutput">cyg_io_write</CODE>(handle, buf, len)
	</PRE>
<P CLASS="Body">
<A NAME="pgfId=1079877">
 </A>
This function is used to send data to the device. In the default case, the end-of-line character '\n' is replaced by the sequence '\r\n'. </P>
  <PRE CLASS="CodeExample"><A NAME="pgfId=1079882"> </A>
 <CODE CLASS="CodeOutput">cyg_io_get_config</CODE>(handle, key, buf, len)
	</PRE>
<P CLASS="Body">
<A NAME="pgfId=1079888">
 </A>
This function is used to get information about the channel's configuration at runtime. </P>
<P CLASS="BodyHang1">
<A NAME="pgfId=1079902">
 </A>
Key: 	</P>
<P CLASS="BodyListFollow">
<A NAME="pgfId=1079912">
 </A>
CYG_IO_GET_CONFIG_TTY_INFO</P>
<P CLASS="BodyHang1">
<A NAME="pgfId=1079923">
 </A>
Buf type: 	</P>
<P CLASS="BodyListFollow">
<A NAME="pgfId=1079933">
 </A>
cyg_tty_info_t</P>
<P CLASS="BodyHang1">
<A NAME="pgfId=1079944">
 </A>
Function: 	</P>
<P CLASS="BodyListFollow">
<A NAME="pgfId=1079955">
 </A>
This function retrieves the current state of the driver.</P>
<P CLASS="Body">
<A NAME="pgfId=1079959">
 </A>
The key must be &quot;CYG_IO_GET_CONFIG_TTY_INFO&quot; which returns the control flags for the channel. The buffer 'buf' must be of type 'cyg_tty_info_t' and the length should match. </P>
<P CLASS="Body">
<A NAME="pgfId=1079964">
 </A>
Serial driver keys (see above) may also be specified in which case the call is passed directly to the serial driver. </P>
  <PRE CLASS="CodeExample"><A NAME="pgfId=1079969"> </A>
 <CODE CLASS="CodeOutput">cyg_io_set_config</CODE>(handle, key, buf, len)
	</PRE>
<P CLASS="Body">
<A NAME="pgfId=1079975">
 </A>
This function is used to modify the channel's configuration at runtime. </P>
<P CLASS="BodyHang1">
<A NAME="pgfId=1079989">
 </A>
Key: 	</P>
<P CLASS="BodyListFollow">
<A NAME="pgfId=1079999">
 </A>
CYG_IO_SET_CONFIG_TTY_INFO</P>
<P CLASS="BodyHang1">
<A NAME="pgfId=1080010">
 </A>
Buf type: 	</P>
<P CLASS="BodyListFollow">
<A NAME="pgfId=1080020">
 </A>
cyg_tty_info_t</P>
<P CLASS="BodyHang1">
<A NAME="pgfId=1080031">
 </A>
Function: 	</P>
<P CLASS="BodyListFollow">
<A NAME="pgfId=1080042">
 </A>
This function changes the current state of the driver.</P>
<P CLASS="Body">
<A NAME="pgfId=1080050">
 </A>
The key must be <CODE CLASS="CodeOutput">
CYG_IO_SET_CONFIG_TTY_INFO</CODE>
 which returns the control flags for the channel. The buffer 'buf' must be of type <CODE CLASS="Code">
cyg_tty_info_t</CODE>
 and the length should match. </P>
<P CLASS="Body">
<A NAME="pgfId=1080059">
 </A>
Serial driver keys (see above) may also be specified in which case the call is passed directly to the serial driver. </P>
<TABLE>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
</TD>
</TR>
</TABLE>
</DIV>
<HR ALIGN="center"><TABLE STYLE="ECOS" WIDTH="98%" BORDER="0" ALIGN="LEFT" CELLPADDING="1"><TR><TH COLSPAN="3" ALIGN="center"><P CLASS="Gotos">Serial driver details</P></TH></TR><TR><TD  ALIGN="center"><P CLASS="Gotos"><A HREF="ecos-ref.2.html">To Contents</A></P></TD><TD  ALIGN="center"><P CLASS="Gotos"><A HREF="ecos-ref.10.html">To&nbsp;previous&nbsp;page</A></P></TD><TD  ALIGN="center"><P CLASS="Gotos"><A HREF="ecos-ref.12.html">To&nbsp;next&nbsp;page</A></P></TD></TR></TABLE></BODY>
</HTML>
