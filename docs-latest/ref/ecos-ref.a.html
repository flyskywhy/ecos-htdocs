<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML EXPERIMENTAL 970324//EN">
<HTML>
<HEAD><!--version 1.3.4/Thur May 4 2000-->
<META NAME="GENERATOR" CONTENT="Adobe FrameMaker 5.5/HTML Export Filter">
<LINK REL="STYLESHEET" HREF="cygnus.css">
<TITLE> uITRON API</TITLE></HEAD>
<BODY BGCOLOR="#ffffff">
<DIV>
<TABLE STYLE="ECOS" WIDTH="98%" BORDER="0" ALIGN="LEFT" CELLPADDING="1"><TR><TH COLSPAN="3" ALIGN="center"><P CLASS="Gotos"><EM CLASS="FmSymbol">
&#181</EM>ITRON API</P></TH></TR><TR><TD  ALIGN="center"><P CLASS="Gotos"><A HREF="ecos-ref.2.html">To Contents</A></P></TD><TD  ALIGN="center"><P CLASS="Gotos"><A HREF="ecos-ref.9.html">To&nbsp;previous&nbsp;page</A></P></TD><TD ALIGN="center"><P CLASS="Gotos"><A HREF="ecos-ref.b.html">To&nbsp;next&nbsp;page</A></P></TD></TR></TABLE><P ALIGN="LEFT">&nbsp;</P><BR><BR><HR ALIGN="center"></DIV>
<H2 CLASS="ChapterTitle">
<A NAME="pgfId=1076169">
 </A>
<EM CLASS="FmSymbol">
&#181</EM>
<A NAME="13029">
 </A>
ITRON API<DIV>
<IMG SRC="botclear.gif">
</DIV>
</H2>
<P CLASS="Body">
<A NAME="pgfId=1030234">
 </A>
The <EM CLASS="FmSymbol">
&#181</EM>
<A NAME="marker=1084866">
 </A>
ITRON specification defines a highly flexible operating system architecture designed specifically for application in embedded systems. The specification addresses features which are common to the majority of processor architectures and deliberately avoids virtualization which would adversely impact real-time performance. The <EM CLASS="FmSymbol">
&#181</EM>
ITRON specification may be implemented on many hardware platforms and provides significant advantages by reducing the effort involved in understanding and porting application software to new processor architectures. </P>
<P CLASS="Body">
<A NAME="pgfId=1030327">
 </A>
Several revisions of the <EM CLASS="FmSymbol">
&#181</EM>
ITRON specification exist. In this release, <SPAN CLASS="Bold">
eCos</SPAN>
 supports the <EM CLASS="FmSymbol">
&#181</EM>
ITRON version 3.02 specification, with complete &quot;Standard functionality&quot; (level S), plus many &quot;Extended&quot; (level E) functions. The definitive reference on <EM CLASS="FmSymbol">
&#181</EM>
ITRON is Dr. Sakamura's book <EM CLASS="FmSymbol">
&#181</EM>
<EM CLASS="Emphasis">
ITRON 3.0, An Open and Portable Real-Time Operating System for Embedded Systems.</EM>
 If you have purchased the <SPAN CLASS="Bold">
eCos</SPAN>
 <SPAN CLASS="BOLD">
Developer's Kit,</SPAN>
 you will have received a copy of this book. Otherwise, the book can be purchased from the IEEE Press, and an ASCII version of the standard can be found online at</P>
<P CLASS="Body">
<A NAME="pgfId=1084876">
 </A>
<CODE CLASS="Code">
http://www.itron.gr.jp/</CODE>
</P>
<P CLASS="Body">
<A NAME="pgfId=1084877">
 </A>
(The old address </P>
<P CLASS="Ulink">
<A NAME="pgfId=1084887">
 </A>
<CODE CLASS="Code">
http://tron.um.u-tokyo.ac.jp/TRON/ITRON/</CODE>
</P>
<P CLASS="Body">
<A NAME="pgfId=1084888">
 </A>
still exists as a mirror site.) </P>
<P CLASS="Body">
<A NAME="pgfId=1030356">
 </A>
The <SPAN CLASS="Bold">
eCos</SPAN>
 kernel implements the functionality used by the <EM CLASS="FmSymbol">
&#181</EM>
ITRON compatibility subsystem. The configuration of the kernel influences the behavior of <EM CLASS="FmSymbol">
&#181</EM>
ITRON programs.</P>
<P CLASS="Body">
<A NAME="pgfId=1030497">
 </A>
In particular, the default configuration has time slicing (also known as round-robin scheduling) switched on; this means that a task can be moved from <CODE CLASS="Code">
RUN</CODE>
 state to <CODE CLASS="Code">
READY</CODE>
 state at any time, in order that one of its peers may run. This is not strictly conformant to the <EM CLASS="FmSymbol">
&#181</EM>
ITRON specification, which states that timeslicing may be implemented by periodically issuing a <CODE CLASS="Code">
rot_rdq(0)</CODE>
 call from within a periodic task or cyclic handler; otherwise it is expected that a task runs until it is pre-empted in consequence of synchronization or communications calls it makes, or the effects of an interrupt or other external event on a higher priority task cause that task to become <CODE CLASS="Code">
READY</CODE>
. To disable timeslicing functionality in the kernel and <EM CLASS="FmSymbol">
&#181</EM>
ITRON compatibility environment, please disable the <EM CLASS="parameter">
CYGSEM_KERNEL_SCHED_TIMESLICE</EM>
 configuration option in the kernel package. A description of kernel scheduling is in <A HREF="ecos-ref.9.html#38132" CLASS="XRef">
 Thread operations</A>
. </P>
<P CLASS="Body">
<A NAME="pgfId=1030506">
 </A>
For another example, the semantics of task queueing when waiting on a synchronization object depend solely on the way the underlying kernel is configured. As discussed above, the multi-level queue scheduler is the only one which is <EM CLASS="FmSymbol">
&#181</EM>
ITRON compliant, and it queues waiting tasks in FIFO order. Future releases of that scheduler might be configurable to support priority ordering of task queues. Other schedulers might be different again: for example the bitmap scheduler can be used with the <EM CLASS="FmSymbol">
&#181</EM>
ITRON compatibility layer, even though it only allows one task at each priority and as such is not <EM CLASS="FmSymbol">
&#181</EM>
ITRON compliant, but it supports only priority ordering of task queues. So which queueing scheme is supported is not really a property of the <EM CLASS="FmSymbol">
&#181</EM>
ITRON compatibility layer; it depends on the kernel. </P>
<P CLASS="Body">
<A NAME="pgfId=1030634">
 </A>
In this version of the <EM CLASS="FmSymbol">
&#181</EM>
ITRON compatibility layer, the calls to disable and enable scheduling and interrupts (<CODE CLASS="CodeOutput">
dis_dsp()</CODE>
, <CODE CLASS="CodeOutput">
ena_dsp()</CODE>
, <CODE CLASS="CodeOutput">
loc_cpu()</CODE>
 and <CODE CLASS="CodeOutput">
unl_cpu()</CODE>
) call underlying kernel functions; in particular, the <CODE CLASS="CodeOutput">
xxx_dsp()</CODE>
 functions lock the scheduler entirely, which prevents dispatching of DSRs; functions implemented by DSRs include clock counters and alarm timers. Thus time &quot;stops&quot; while dispatching is disabled with <CODE CLASS="CodeOutput">
dis_dsp()</CODE>
. </P>
<P CLASS="Body">
<A NAME="pgfId=1030672">
 </A>
Like all parts of the <SPAN CLASS="Bold">
eCos</SPAN>
 system, the detailed semantics of the <EM CLASS="FmSymbol">
&#181</EM>
ITRON layer are dependent on its configuration and the configuration of other components that it uses. The <EM CLASS="FmSymbol">
&#181</EM>
ITRON configuration options are all defined in the file <CODE CLASS="Code">
pkgconf/uitron.h</CODE>
, and can be set using the configuration tool or editing this file by hand. </P>
<P CLASS="Body">
<A NAME="pgfId=1030737">
 </A>
An important configuration option for the <EM CLASS="FmSymbol">
&#181</EM>
ITRON compatibility layer is <EM CLASS="parameter">
CYGSEM_UITRON_BAD_PARAMS_RETURN_ERRORS</EM>
 (see &quot;Option: Return Error Codes for Bad Params&quot;, in Section V), which allows a lot of the error checking code in the <EM CLASS="FmSymbol">
&#181</EM>
ITRON compatibility layer to be removed; of course this leaves a program open to undetected errors, so it should only be used once an application is fully debugged and tested. Its benefits include reduced code size and faster execution. However, it affects the API significantly, in that with this option enabled, bad calls do not return errors, but either cause an assert failure (if that is itself enabled) or malfunction internally. There is discussion in more detail about this in each section below.</P>
<P CLASS="Body">
<A NAME="pgfId=1030753">
 </A>
We now give a brief description of the <EM CLASS="FmSymbol">
&#181</EM>
ITRON functions which are implemented in this release. Note that all C and C++ source files should have the following <CODE CLASS="Code">
#include</CODE>
 statement: </P>
<PRE CLASS="CodeExample"><A NAME="pgfId=1030779"> </A>

#include &lt;cyg/compat/uitron/uit_func.h&gt;</PRE>
<DIV>
<H3 CLASS="Heading1">
<A NAME="pgfId=1030788">
 </A>
<A NAME="marker=1084963">
 </A>
Task Management Functions</H3>
<P CLASS="Body">
<A NAME="pgfId=1030798">
 </A>
The following functions are fully supported in this release: </P>
  <PRE CLASS="CodeExampleWide"><A NAME="pgfId=1030805"> </A>
ER <CODE CLASS="CodeOutput">sta_tsk</CODE>( 
    ID <EM CLASS="Emphasis">tskid,</EM>
    INT <EM CLASS="Emphasis">stacd )</EM>
</PRE>
  <PRE CLASS="CodeExampleWide">void <CODE CLASS="CodeOutput">ext_tsk</CODE>( void )
<A NAME="pgfId=1030866"> </A>
void <CODE CLASS="CodeOutput">exd_tsk</CODE>( void )</PRE>
  <PRE CLASS="CodeExampleWide">ER <CODE CLASS="CodeOutput">dis_dsp</CODE>( void )</PRE>
  <PRE CLASS="CodeExampleWide">ER <CODE CLASS="CodeOutput">ena_dsp</CODE>( void )</PRE>
  <PRE CLASS="CodeExampleWide">ER <CODE CLASS="CodeOutput">chg_pri</CODE>( 
    ID <EM CLASS="Emphasis">tskid,</EM>
    PRI <EM CLASS="Emphasis">tskpri )</EM>
</PRE>
  <PRE CLASS="CodeExampleWide">ER <CODE CLASS="CodeOutput">rot_rdq</CODE>( 
    PRI <EM CLASS="Emphasis">tskpri )</EM>
</PRE>
  <PRE CLASS="CodeExampleWide">ER <CODE CLASS="CodeOutput">get_tid</CODE>( 
    ID *<EM CLASS="Emphasis">p_tskid )</EM>
</PRE>
  <PRE CLASS="CodeExampleWide">ER <CODE CLASS="CodeOutput">ref_tsk</CODE>( 
    T_RTSK *<EM CLASS="Emphasis">pk_rtsk,</EM>
    ID <EM CLASS="Emphasis">tskid )</EM>
</PRE>
  <PRE CLASS="CodeExampleWide">ER <CODE CLASS="CodeOutput">ter_tsk</CODE>( 
    ID <EM CLASS="Emphasis">tskid )</EM>

ER <CODE CLASS="CodeOutput">rel_wai</CODE>( 
    ID <EM CLASS="Emphasis">tskid )</EM>
</PRE>
<P CLASS="Body">
<A NAME="pgfId=1031121">
 </A>
The following two functions are supported in this release, when enabled with the configuration option CYGPKG_UITRON_TASKS_CREATE_DELETE with some restrictions:</P>
  <PRE CLASS="CodeExampleWide"><A NAME="pgfId=1031141"> </A>
ER <CODE CLASS="CodeOutput">cre_tsk</CODE>( 
    ID <EM CLASS="Emphasis">tskid,</EM>
    T_CTSK *<EM CLASS="Emphasis">pk_ctsk )</EM>
</PRE>
  <PRE CLASS="CodeExampleWide">ER <CODE CLASS="CodeOutput">del_tsk</CODE>( 
    ID <EM CLASS="Emphasis">tskid )</EM>
</PRE>
<P CLASS="Body">
<A NAME="pgfId=1031209">
 </A>
These functions are restricted as follows:</P>
<P CLASS="Body">
<A NAME="pgfId=1031263">
 </A>
Because of the static initialization facilities provided for system objects, a task is allocated stack space statically in the configuration. So while tasks can be created and deleted, the same stack space is used for that task (task ID number) each time. Thus the stack size (pk_ctsk<IMG SRC="pix/arrow.gif">stksz) requested in <CODE CLASS="CodeOutput">
cre_tsk()</CODE>
 is checked for being less than that which was statically allocated, and otherwise ignored. This ensures that the new task will have enough stack to run. For this reason <CODE CLASS="CodeOutput">
del_tsk()</CODE>
 does not in any sense free the memory that was in use for the task's stack. </P>
<P CLASS="Body">
<A NAME="pgfId=1031275">
 </A>
The task attributes (pk_ctsk<IMG SRC="pix/arrow.gif">tskatr) are ignored; current versions of <SPAN CLASS="Bold">
eCos</SPAN>
 do not need to know whether a task is written in assembler or C/C++ so long as the procedure call standard appropriate to the CPU is followed.</P>
<P CLASS="Body">
<A NAME="pgfId=1031297">
 </A>
Extended information (pk_ctsk<IMG SRC="pix/arrow.gif">exinf) is ignored.</P>
<H5 CLASS="Heading4">
<A NAME="pgfId=1031304">
 </A>
Error checking</H5>
<P CLASS="Body">
<A NAME="pgfId=1031310">
 </A>
For all these calls, an invalid task id (tskid) (less than 1 or greater than the number of configured tasks) only returns E_ID when bad params return errors (<EM CLASS="parameter">
CYGSEM_UITRON_BAD_PARAMS_RETURN_ERRORS</EM>
 is enabled, see above).</P>
<P CLASS="Body">
<A NAME="pgfId=1031333">
 </A>
Similarly, the following conditions are only checked for, and only return errors if <EM CLASS="parameter">
CYGSEM_UITRON_BAD_PARAMS_RETURN_ERRORS</EM>
 is enabled:</P>
<UL>
<P><LI>
<A NAME="pgfId=1031352">
 </A>
pk_crtk in <CODE CLASS="CodeOutput">
cre_tsk()</CODE>
 is a valid pointer, otherwise return E_PAR</LI>
<P><LI>
<A NAME="pgfId=1031396">
 </A>
<CODE CLASS="CodeOutput">
ter_tsk()</CODE>
 or <CODE CLASS="CodeOutput">
rel_wai()</CODE>
 on the calling task returns E_OBJ</LI>
<P><LI>
<A NAME="pgfId=1031429">
 </A>
the CPU is not locked already in <CODE CLASS="CodeOutput">
dis_dsp()</CODE>
 and <CODE CLASS="CodeOutput">
ena_dsp()</CODE>
; returns E_CTX</LI>
<P><LI>
<A NAME="pgfId=1031459">
 </A>
priority level in <CODE CLASS="CodeOutput">
chg_pri()</CODE>
 and <CODE CLASS="CodeOutput">
rot_rdq()</CODE>
 is checked for validity, E_PAR</LI>
<P><LI>
<A NAME="pgfId=1031491">
 </A>
return value pointer in <CODE CLASS="CodeOutput">
get_tid()</CODE>
 and <CODE CLASS="CodeOutput">
ref_tsk()</CODE>
 is a valid pointer, or E_PAR</LI>
</UL>
<P CLASS="Body">
<A NAME="pgfId=1031502">
 </A>
The following conditions are checked for, and return error codes if appropriate, regardless of the setting of <EM CLASS="parameter">
CYGSEM_UITRON_BAD_PARAMS_RETURN_ERRORS</EM>
:</P>
<UL>
<P><LI>
<A NAME="pgfId=1031546">
 </A>
When create and delete functions <CODE CLASS="CodeOutput">
cre_tsk()</CODE>
 and <CODE CLASS="CodeOutput">
del_tsk()</CODE>
 are supported, all calls which use a valid task ID number check that the task exists; if not, E_NOEXS is returned</LI>
<P><LI>
<A NAME="pgfId=1031559">
 </A>
When supported, <CODE CLASS="CodeOutput">
cre_tsk()</CODE>
: the task must not already exist; otherwise E_OBJ</LI>
<P><LI>
<A NAME="pgfId=1031615">
 </A>
When supported, <CODE CLASS="CodeOutput">
cre_tsk()</CODE>
: the requested stack size must not be larger than that statically configured for the task; see &quot;Option: Static initializerst&quot;, in Section V and &quot;Option: Default stack size&quot;, in Section V. Else E_NOMEM</LI>
<P><LI>
<A NAME="pgfId=1031647">
 </A>
When supported, <CODE CLASS="CodeOutput">
del_tsk()</CODE>
: the underlying <SPAN CLASS="Bold">
eCos</SPAN>
 thread must not be running - this would imply either a bug or some program bypassing the <EM CLASS="FmSymbol">
&#181</EM>
ITRON compatibility layer and manipulating the thread directly. E_OBJ</LI>
<P><LI>
<A NAME="pgfId=1031666">
 </A>
<CODE CLASS="CodeOutput">
sta_tsk()</CODE>
: the task must be dormant, else E_OBJ</LI>
<P><LI>
<A NAME="pgfId=1031685">
 </A>
<CODE CLASS="CodeOutput">
ter_tsk()</CODE>
: the task must not be dormant, else E_OBJ</LI>
<P><LI>
<A NAME="pgfId=1031704">
 </A>
<CODE CLASS="CodeOutput">
chg_pri()</CODE>
: the task must not be dormant, else E_OBJ</LI>
<P><LI>
<A NAME="pgfId=1031743">
 </A>
<CODE CLASS="CodeOutput">
rel_wai()</CODE>
: the task must be in <CODE CLASS="Code">
WAIT or WAIT-SUSPEND</CODE>
 state, else E_OBJ</LI>
</UL>
</DIV>
<DIV>
<H3 CLASS="Heading1">
<A NAME="pgfId=1031763">
 </A>
<A NAME="marker=1084975">
 </A>
Task-Dependent Synchronization Functions</H3>
<P CLASS="Body">
<A NAME="pgfId=1031774">
 </A>
These functions are fully supported in this release: </P>
  <PRE CLASS="CodeExampleWide"><A NAME="pgfId=1031781"> </A>
ER <CODE CLASS="CodeOutput">sus_tsk</CODE>( 
&nbsp;&nbsp;&nbsp;&nbsp;ID <EM CLASS="Emphasis">tskid )
</EM>
ER <CODE CLASS="CodeOutput">rsm_tsk</CODE>( 
&nbsp;&nbsp;&nbsp;&nbsp;ID <EM CLASS="Emphasis">tskid )
</EM>
ER <CODE CLASS="CodeOutput">frsm_tsk</CODE>( 
&nbsp;&nbsp;&nbsp;&nbsp;ID <EM CLASS="Emphasis">tskid )
</EM>
ER <CODE CLASS="CodeOutput">slp_tsk</CODE>( void )

ER <CODE CLASS="CodeOutput">tslp_tsk</CODE>( 
&nbsp;&nbsp;&nbsp;&nbsp;TMO <EM CLASS="Emphasis">tmout )
</EM>
ER <CODE CLASS="CodeOutput">wup_tsk</CODE>( 
&nbsp;&nbsp;&nbsp;&nbsp;ID <EM CLASS="Emphasis">tskid )</EM>
</PRE>
  <PRE CLASS="CodeExampleWide">ER <CODE CLASS="CodeOutput">can_wup</CODE>( 
&nbsp;&nbsp;&nbsp;&nbsp;INT *<EM CLASS="Emphasis">p_wupcnt,
</EM>&nbsp;&nbsp;&nbsp;&nbsp;ID <EM CLASS="Emphasis">tskid )</EM>
</PRE>
<H5 CLASS="Heading4">
<A NAME="pgfId=1031982">
 </A>
Error checking</H5>
<P CLASS="Body">
<A NAME="pgfId=1032008">
 </A>
The following conditions are only checked for, and only return errors if <EM CLASS="parameter">
CYGSEM_UITRON_BAD_PARAMS_RETURN_ERRORS</EM>
 is enabled (see &quot;Option: Return Error Codes for Bad Params&quot;, in Section V):</P>
<UL>
<P><LI>
<A NAME="pgfId=1032016">
 </A>
invalid tskid; less than 1 or greater than CYGNUM_UITRON_TASKS returns E_ID</LI>
<P><LI>
<A NAME="pgfId=1032085">
 </A>
<CODE CLASS="CodeOutput">
wup_tsk()</CODE>
, <CODE CLASS="CodeOutput">
sus_tsk()</CODE>
, <CODE CLASS="CodeOutput">
rsm_tsk()</CODE>
, <CODE CLASS="CodeOutput">
frsm_tsk()</CODE>
 on the calling task returns E_OBJ</LI>
<P><LI>
<A NAME="pgfId=1032118">
 </A>
dispatching is enabled in <CODE CLASS="CodeOutput">
tslp_tsk()</CODE>
 and <CODE CLASS="CodeOutput">
slp_tsk()</CODE>
, or E_CTX</LI>
<P><LI>
<A NAME="pgfId=1032127">
 </A>
tmout must be positive, otherwise E_PAR</LI>
<P><LI>
<A NAME="pgfId=1032137">
 </A>
return value pointer in <CODE CLASS="CodeOutput">
can_wup()</CODE>
 is a valid pointer, or E_PAR</LI>
</UL>
<P CLASS="Body">
<A NAME="pgfId=1032157">
 </A>
The following conditions are checked for, and can return error codes, regardless of the setting of <EM CLASS="parameter">
CYGSEM_UITRON_BAD_PARAMS_RETURN_ERRORS</EM>
:</P>
<UL>
<P><LI>
<A NAME="pgfId=1032201">
 </A>
When create and delete functions <CODE CLASS="CodeOutput">
cre_tsk()</CODE>
 and <CODE CLASS="CodeOutput">
del_tsk()</CODE>
 are supported, all calls which use a valid task ID number check that the task exists; if not, E_NOEXS is returned</LI>
<P><LI>
<A NAME="pgfId=1032214">
 </A>
<CODE CLASS="CodeOutput">
sus_tsk()</CODE>
: the task must not be dormant, else E_OBJ</LI>
<P><LI>
<A NAME="pgfId=1032233">
 </A>
<CODE CLASS="CodeOutput">
frsm/rsm_tsk()</CODE>
: the task must be suspended, else E_OBJ</LI>
<P><LI>
<A NAME="pgfId=1032252">
 </A>
<CODE CLASS="CodeOutput">
tslp/slp_tsk()</CODE>
: return codes E_TMOUT, E_RLWAI and E_DLT are returned depending on the reason for terminating the sleep</LI>
<P><LI>
<A NAME="pgfId=1032292">
 </A>
<CODE CLASS="CodeOutput">
wup_tsk()</CODE>
 and <CODE CLASS="CodeOutput">
can_wup()</CODE>
: the task must not be dormant, or E_OBJ is returned</LI>
</UL>
</DIV>
<DIV>
<H3 CLASS="Heading1">
<A NAME="pgfId=1032303">
 </A>
<A NAME="marker=1084978">
 </A>
Synchronization and Communication Functions</H3>
<P CLASS="Body">
<A NAME="pgfId=1032313">
 </A>
These functions are fully supported in this release: </P>
  <PRE CLASS="CodeExampleWide"><A NAME="pgfId=1032320"> </A>
ER <CODE CLASS="CodeOutput">sig_sem</CODE>( 
    ID <EM CLASS="Emphasis">semid )</EM>
</PRE>
  <PRE CLASS="CodeExampleWide"><A NAME="pgfId=1032348"> </A>
ER <CODE CLASS="CodeOutput">wai_sem</CODE>( 
    ID <EM CLASS="Emphasis">semid )</EM>
</PRE>
  <PRE CLASS="CodeExampleWide"><A NAME="pgfId=1032376"> </A>
ER <CODE CLASS="CodeOutput">preq_sem</CODE>( 
    ID <EM CLASS="Emphasis">semid )</EM>
</PRE>
  <PRE CLASS="CodeExampleWide"><A NAME="pgfId=1032404"> </A>
ER <CODE CLASS="CodeOutput">twai_sem</CODE>( 
    ID <EM CLASS="Emphasis">semid,
</EM>    TMO <EM CLASS="Emphasis">tmout )</EM>
</PRE>
  <PRE CLASS="CodeExampleWide">ER <CODE CLASS="CodeOutput">ref_sem</CODE>( 
    T_RSEM *<EM CLASS="Emphasis">pk_rsem ,
</EM>    ID <EM CLASS="Emphasis">semid )</EM>
</PRE>
  <PRE CLASS="CodeExampleWide"><A NAME="pgfId=1032484"> </A>ER <CODE CLASS="CodeOutput">set_flg</CODE>( 
    ID <EM CLASS="Emphasis">flgid,
</EM>    UINT <EM CLASS="Emphasis">setptn )</EM>
<A NAME="pgfId=1032524"> </A>
ER <CODE CLASS="CodeOutput">clr_flg</CODE>( 
    ID <EM CLASS="Emphasis">flgid,
</EM>    UINT <EM CLASS="Emphasis">clrptn )</EM>
</PRE>
  <PRE CLASS="CodeExampleWide">ER <CODE CLASS="CodeOutput">wai_flg</CODE>( 
    UINT *<EM CLASS="Emphasis">p_flgptn,
</EM>    ID <EM CLASS="Emphasis">flgid ,
</EM>    UINT <EM CLASS="Emphasis">waiptn ,
</EM>    UINT <EM CLASS="Emphasis">wfmode )</EM>
</PRE>
  <PRE CLASS="CodeExampleWide">ER <CODE CLASS="CodeOutput">pol_flg</CODE>( 
    UINT *<EM CLASS="Emphasis">p_flgptn,
</EM>    ID <EM CLASS="Emphasis">flgid ,
</EM>    UINT <EM CLASS="Emphasis">waiptn ,
</EM>    UINT <EM CLASS="Emphasis">wfmode )</EM><A NAME="pgfId=1032692"> </A>

ER <CODE CLASS="CodeOutput">twai_flg</CODE>( 
    UINT *<EM CLASS="Emphasis">p_flgptn
</EM>    ID <EM CLASS="Emphasis">flgid ,
</EM>    UINT <EM CLASS="Emphasis">waiptn ,
</EM>    UINT <EM CLASS="Emphasis">wfmode,
</EM>    TMO <EM CLASS="Emphasis">tmout )</EM><A NAME="pgfId=1032768"> </A>

ER <CODE CLASS="CodeOutput">ref_flg</CODE>( 
    T_RFLG *<EM CLASS="Emphasis">pk_rflg,
</EM>    ID <EM CLASS="Emphasis">flgid )</EM><A NAME="pgfId=1032808"> </A>

ER <CODE CLASS="CodeOutput">snd_msg</CODE>( 
    ID <EM CLASS="Emphasis">mbxid,
</EM>    T_MSG <EM CLASS="Emphasis">*pk_msg )</EM>
</PRE>
  <PRE CLASS="CodeExampleWide">ER <CODE CLASS="CodeOutput">rcv_msg</CODE>( 
    T_MSG **<EM CLASS="Emphasis">ppk_msg,
</EM>    ID <EM CLASS="Emphasis">mbxid )</EM><A NAME="pgfId=1032888"> </A>

ER <CODE CLASS="CodeOutput">prcv_msg</CODE>( 
    T_MSG **<EM CLASS="Emphasis">ppk_msg,
</EM>    ID <EM CLASS="Emphasis">mbxid )</EM>

ER <CODE CLASS="CodeOutput">trcv_msg</CODE>( 
    T_MSG **<EM CLASS="Emphasis">ppk_msg,
</EM>    ID <EM CLASS="Emphasis">mbxid ,
</EM>    TMO <EM CLASS="Emphasis">tmout )</EM>
<A NAME="pgfId=1032980"> </A>
ER <CODE CLASS="CodeOutput">ref_mbx</CODE>( 
    T_RMBX *<EM CLASS="Emphasis">pk_rmbx,
</EM>    ID <EM CLASS="Emphasis">mbxid )</EM>
</PRE>
<P CLASS="Body">
<A NAME="pgfId=1033043">
 </A>
The following functions are supported in this release (with some restrictions) if enabled with the appropriate configuration option for the object type (for example <EM CLASS="parameter">
CYGPKG_UITRON_SEMAS_CREATE_DELETE</EM>
) : </P>
  <PRE CLASS="CodeExampleWide"><A NAME="pgfId=1033054"> </A>
ER <CODE CLASS="CodeOutput">cre_sem</CODE>( 
    ID <EM CLASS="Emphasis">semid,
</EM>    T_CSEM *<EM CLASS="Emphasis">pk_csem )</EM>
<A NAME="pgfId=1033094"> </A>
ER <CODE CLASS="CodeOutput">del_sem</CODE>( 
    ID <EM CLASS="Emphasis">semid )</EM>
</PRE>
  <PRE CLASS="CodeExampleWide">ER <CODE CLASS="CodeOutput">cre_flg</CODE>( 
    ID <EM CLASS="Emphasis">flgid,
</EM>    T_CFLG *<EM CLASS="Emphasis">pk_cflg )</EM>
</PRE>
  <PRE CLASS="CodeExampleWide">ER <CODE CLASS="CodeOutput">del_flg</CODE>( 
    ID <EM CLASS="Emphasis">flgid )</EM>
</PRE>
  <PRE CLASS="CodeExampleWide">ER <CODE CLASS="CodeOutput">cre_mbx</CODE>( 
    ID <EM CLASS="Emphasis">mbxid,
</EM>    T_CMBX *<EM CLASS="Emphasis">pk_cmbx )</EM>
</PRE>
  <PRE CLASS="CodeExampleWide">ER <CODE CLASS="CodeOutput">del_mbx</CODE>( 
    ID <EM CLASS="Emphasis">mbxid )</EM>
</PRE>
<P CLASS="Body">
<A NAME="pgfId=1033258">
 </A>
In general the queueing order when waiting on a synchronization object depends on the underlying kernel configuration. The multi-level queue scheduler is required for strict <EM CLASS="FmSymbol">
&#181</EM>
ITRON conformance and it queues tasks in FIFO order, so requests to create an object with priority queueing of tasks (<CODE CLASS="Code">
pk_cxxx<IMG SRC="pix/arrow.gif">xxxatr = TA_TPRI</CODE>
) are rejected with E_RSATR. Additional undefined bits in the attributes fields must be zero. </P>
<P CLASS="Body">
<A NAME="pgfId=1033297">
 </A>
In general, extended information (pk_cxxx<IMG SRC="pix/arrow.gif">exinf) is ignored. </P>
<P CLASS="Body">
<A NAME="pgfId=1033305">
 </A>
For semaphores, the initial semaphore count (pk_csem<IMG SRC="pix/arrow.gif">isemcnt) is supported; the new semaphore's count is set. The maximum count is not supported, and is not in fact defined in type pk_csem. </P>
<P CLASS="Body">
<A NAME="pgfId=1033321">
 </A>
For flags, multiple tasks are allowed to wait. Because single task waiting is a subset of this, the W bit (TA_WMUL) of the flag attributes is ignored; all other bits must be zero. The initial flag value is supported. </P>
<P CLASS="Body">
<A NAME="pgfId=1033358">
 </A>
For mailboxes, the buffer count is defined statically by kernel configuration option <EM CLASS="parameter">
CYGNUM_KERNEL_SYNCH_MBOX_QUEUE_SIZE;</EM>
 therefore the buffer count field is not supported and is not in fact defined in type pk_cmbx. Queueing of messages is FIFO ordered only, so TA_MPRI (in pk_cmbx<IMG SRC="pix/arrow.gif">mbxatr) is not supported. </P>
<H5 CLASS="Heading4">
<A NAME="pgfId=1033378">
 </A>
Error checking</H5>
<P CLASS="Body">
<A NAME="pgfId=1033384">
 </A>
The following conditions are only checked for, and only return errors if <EM CLASS="parameter">
CYGSEM_UITRON_BAD_PARAMS_RETURN_ERRORS</EM>
 is enabled:</P>
<UL>
<P><LI>
<A NAME="pgfId=1033402">
 </A>
invalid object id; less than 1 or greater than CYGNUM_UITRON_TASKS/SEMAS/MBOXES as appropriate returns E_ID</LI>
<P><LI>
<A NAME="pgfId=1033420">
 </A>
dispatching is enabled in any call which can sleep, or E_CTX</LI>
<P><LI>
<A NAME="pgfId=1033432">
 </A>
tmout must be positive, otherwise E_PAR</LI>
<P><LI>
<A NAME="pgfId=1033442">
 </A>
pk_cxxx pointers in <CODE CLASS="CodeOutput">
cre_xxx()</CODE>
 must be valid pointer, or E_PAR</LI>
<P><LI>
<A NAME="pgfId=1033463">
 </A>
return value pointers in <CODE CLASS="CodeOutput">
ref_xxx()</CODE>
 is a valid pointer, or E_PAR</LI>
<P><LI>
<A NAME="pgfId=1033483">
 </A>
flag wait pattern must be non-zero, and mode must be valid, or E_PAR</LI>
<P><LI>
<A NAME="pgfId=1033496">
 </A>
return value pointer in flag wait calls is a valid pointer, or E_PAR</LI>
</UL>
<P CLASS="Body">
<A NAME="pgfId=1033508">
 </A>
The following conditions are checked for, and can return error codes, regardless of the setting of <EM CLASS="parameter">
CYGSEM_UITRON_BAD_PARAMS_RETURN_ERRORS</EM>
:</P>
<UL>
<P><LI>
<A NAME="pgfId=1033567">
 </A>
When create and delete functions <CODE CLASS="CodeOutput">
cre_xxx()</CODE>
 and <CODE CLASS="CodeOutput">
del_xxx()</CODE>
 are supported, all calls which use a valid object ID number check that the object exists. If not, E_NOEXS is returned.</LI>
<P><LI>
<A NAME="pgfId=1033577">
 </A>
In create functions <CODE CLASS="CodeOutput">
cre_xxx()</CODE>
, when supported, if the object already exists, then E_OBJ</LI>
<P><LI>
<A NAME="pgfId=1033599">
 </A>
In any call which can sleep, such as <CODE CLASS="CodeOutput">
twai_sem()</CODE>
: return codes E_TMOUT, E_RLWAI, E_DLT or of course E_OK are returned depending on the reason for terminating the sleep</LI>
<P><LI>
<A NAME="pgfId=1033623">
 </A>
In polling functions such as <CODE CLASS="CodeOutput">
preq_sem()</CODE>
return codes E_TMOUT or E_OK are returned depending on the state of the synchronization object</LI>
<P><LI>
<A NAME="pgfId=1033681">
 </A>
In creation functions, the attributes must be compatible with the selected underlying kernel configuration: in <CODE CLASS="CodeOutput">
cre_sem()</CODE>
 <CODE CLASS="Code">
pk_csem<IMG SRC="pix/arrow.gif">sematr</CODE>
 must be equal to <CODE CLASS="Code">
TA_TFIFO</CODE>
 else E_RSATR.</LI>
<P><LI>
<A NAME="pgfId=1033732">
 </A>
In <CODE CLASS="CodeOutput">
cre_flg()</CODE>
 <CODE CLASS="Code">
pk_cflg<IMG SRC="pix/arrow.gif">flgatr</CODE>
 must be either <CODE CLASS="Code">
TA_WMUL</CODE>
 or <CODE CLASS="Code">
TA_WSGL</CODE>
 else E_RSATR.</LI>
<P><LI>
<A NAME="pgfId=1033774">
 </A>
In <CODE CLASS="CodeOutput">
cre_mbx()</CODE>
 <CODE CLASS="Code">
pk_cmbx<IMG SRC="pix/arrow.gif">mbxatr</CODE>
 must be <CODE CLASS="Code">
TA_TFIFO + TA_MFIFO</CODE>
 else E_RSATR.</LI>
</UL>
</DIV>
<DIV>
<H3 CLASS="Heading1">
<A NAME="pgfId=1033784">
 </A>
<A NAME="marker=1084987">
 </A>
Extended Synchronization and Communication Functions</H3>
<P CLASS="Body">
<A NAME="pgfId=1033796">
 </A>
None of these functions are supported in this release. </P>
</DIV>
<DIV>
<H3 CLASS="Heading1">
<A NAME="pgfId=1033803">
 </A>
<A NAME="marker=1084990">
 </A>
Interrupt management functions</H3>
<P CLASS="Body">
<A NAME="pgfId=1033813">
 </A>
These functions are fully supported in this release:</P>
  <PRE CLASS="CodeExampleWide">void <CODE CLASS="CodeOutput">ret_int</CODE>( void )<br>ER <CODE CLASS="CodeOutput">loc_cpu</CODE>( void )<br>ER <CODE CLASS="CodeOutput">unl_cpu</CODE>( void )

ER <code class="CodeOutput">dis_int</code>( 
    UINT <em class="Emphasis">eintno</em> )

ER <code class="CodeOutput">ena_int</code>( 
    UINT <em class="Emphasis">eintno</em> )

void <code class="CodeOutput">ret_wup</code>( 
    ID <em class="Emphasis">tskid</em> )

ER <code class="CodeOutput">iwup_tsk</code>( 
    ID <em class="Emphasis">tskid</em> )

ER <code class="CodeOutput">isig_sem</code>( 
    ID <em class="Emphasis">semid</em> )

ER <code class="CodeOutput">iset_flag</code>( 
    ID <em class="Emphasis">flgid,</em><br>    UINT <em class="Emphasis">setptn</em> )

ER <code class="CodeOutput">isnd_msg</code>( 
    ID <em class="Emphasis">mbxid,</em><br>    T_MSG <em class="Emphasis">*pkmsg</em> )</PRE>

  <br><P CLASS="Body"> <A NAME="pgfId=1033885"> </A> Note that <CODE CLASS="CodeOutput"> 
    ret_int()</CODE> and<code class="CodeOutput"> ret_wup()</code> are implemented 
    as macros, containing a &quot;return&quot; statement.</P>
  <P CLASS="Body">Also note that <code class="CodeOutput">ret_wup()</code> and 
    the <code class="CodeOutput">ixxx_yyy()</code> style functions will only work 
    when called from an ISR whose associated DSR is <code class="CodeOutput">cyg_uitron_dsr()</code>, 
    as specified in the include file <font face="Courier New, Courier, mono">&lt;cyg/compat/uitron/uit_ifnc.h&gt;</font>, 
    which defines the <code class="CodeOutput">ixxx_yyy()</code> 
    style functions also. Do not use them from a DSR: use plain <code class="CodeOutput">xxx_yyy()</code> 
    style functions instead. </P>
<P CLASS="Body">
<A NAME="pgfId=1033904">
 </A>
The following functions are not supported in this release: </P>
  <PRE CLASS="CodeExampleWide"><A NAME="pgfId=1033910"> </A>
ER <CODE CLASS="CodeOutput">def_int</CODE>( 
    UINT <EM CLASS="Emphasis">dintno,</EM>
    T_DINT *<EM CLASS="Emphasis">pk_dint )</EM>

</PRE>

<PRE CLASS="CodeExampleWide">ER <CODE CLASS="CodeOutput">chg_iXX</CODE>( 
    UINT <EM CLASS="Emphasis">iXXXX )</EM>

</PRE>

<PRE CLASS="CodeExampleWide">ER <CODE CLASS="CodeOutput">ref_iXX</CODE>( 
    UINT * <EM CLASS="Emphasis">p_iXXXX )</EM>

</PRE>
  <P CLASS="Body"> <A NAME="pgfId=1034131"> </A> These unsupported functions are 
    all Level C (CPU dependent). Equivalent functionality is available via other 
    <SPAN CLASS="Bold"> eCos</SPAN> -specific APIs. </P>
<H5 CLASS="Heading4">
<A NAME="pgfId=1034143">
 </A>
Error checking</H5>
  <P CLASS="Body"> <A NAME="pgfId=1034149"> </A> The following conditions are only 
    checked for, and only return errors, if <EM CLASS="parameter"> CYGSEM_UITRON_BAD_PARAMS_RETURN_ERRORS</EM> 
    is enabled:</P>
  <UL>
    <P>
    <LI> <A NAME="pgfId=1034167"> </A> <CODE CLASS="CodeOutput"> loc/unl_cpu()</CODE> 
      : these must only be called in a <EM CLASS="FmSymbol"> &#181</EM> ITRON 
      task context, else E_CTX</LI>
    <LI><code class="CodeOutput">dis/ena_int()</code> : the interrupt number must 
      be in range as specified by the platform HAL in question, else E_PAR.</LI>
  </UL>
</DIV>
<DIV>
<H3 CLASS="Heading1">
<A NAME="pgfId=1034193">
 </A>
<A NAME="marker=1084993">
 </A>
Memory pool Management Functions</H3>
<P CLASS="Body">
<A NAME="pgfId=1034203">
 </A>
These functions are fully supported in this release: </P>
  <PRE CLASS="CodeExampleWide">ER <CODE CLASS="CodeOutput">get_blf</CODE>( 
    VP *<EM CLASS="Emphasis">p_blf,
</EM>    ID <EM CLASS="Emphasis">mpfid )</EM>
</PRE>
  <PRE CLASS="CodeExampleWide">ER <CODE CLASS="CodeOutput">pget_blf</CODE>( 
    VP *<EM CLASS="Emphasis">p_blf,
</EM>    ID <EM CLASS="Emphasis">mpfid )</EM>
</PRE>
  <PRE CLASS="CodeExampleWide">ER <CODE CLASS="CodeOutput">tget_blf</CODE>( 
    VP *<EM CLASS="Emphasis">p_blf,
</EM>    ID <EM CLASS="Emphasis">mpfid,
</EM>    TMO <EM CLASS="Emphasis">tmout )</EM>
<A NAME="pgfId=1034342"> </A>
ER <CODE CLASS="CodeOutput">rel_blf</CODE>( 
    ID <EM CLASS="Emphasis">mpfid,
</EM>    VP <EM CLASS="Emphasis">blf )</EM>
</PRE>
  <PRE CLASS="CodeExampleWide">ER <CODE CLASS="CodeOutput">ref_mpf</CODE>( 
    T_RMPF *<EM CLASS="Emphasis">pk_rmpf,
</EM>    ID <EM CLASS="Emphasis">mpfid )</EM>
</PRE>
  <PRE CLASS="CodeExampleWide">ER <CODE CLASS="CodeOutput">get_blk</CODE>( 
    VP *<EM CLASS="Emphasis">p_blk,
</EM>    ID <EM CLASS="Emphasis">mplid,
</EM>    INT <EM CLASS="Emphasis">blksz )</EM>
</PRE>
  <PRE CLASS="CodeExampleWide">ER <CODE CLASS="CodeOutput">pget_blk</CODE>( 
    VP *<EM CLASS="Emphasis">p_blk,
</EM>    ID <EM CLASS="Emphasis">mplid,
</EM>    INT <EM CLASS="Emphasis">blksz )</EM>
</PRE>
  <PRE CLASS="CodeExampleWide">ER <CODE CLASS="CodeOutput">tget_blk</CODE>( 
    VP *<EM CLASS="Emphasis">p_blk,
</EM>    ID <EM CLASS="Emphasis">mplid,
</EM>    INT <EM CLASS="Emphasis">blksz,
</EM>    TMO <EM CLASS="Emphasis">tmout )</EM>
<A NAME="pgfId=1452553"> </A>
ER <CODE CLASS="CodeOutput">rel_blk</CODE>( 
    ID <EM CLASS="Emphasis">mplid,
</EM>    VP <EM CLASS="Emphasis">blk )</EM>
</PRE>
  <PRE CLASS="CodeExampleWide">ER <CODE CLASS="CodeOutput">ref_mpl</CODE>( 
    T_RMPL *<EM CLASS="Emphasis">pk_rmpl,
</EM>    ID <EM CLASS="Emphasis">mplid )</EM>
</PRE>
<P CLASS="Body">
<A NAME="pgfId=1034670">
 </A>
Note that of the memory provided for a particular pool to manage in the static initialization of the memory pool objects, some memory will be used to manage the pool itself. Therefore the number of blocks * the blocksize will be less than the total memory size. </P>
<P CLASS="Body">
<A NAME="pgfId=1034685">
 </A>
The following functions are supported in this release, when enabled with CYGPKG_UITRON_MEMPOOLVAR_CREATE_DELETE or CYGPKG_UITRON_MEMPOOLFIXED_CREATE_DELETE as appropriate, with some restrictions: </P>
  <PRE CLASS="CodeExampleWide"><A NAME="pgfId=1034698"> </A>
ER <CODE CLASS="CodeOutput">cre_mpl</CODE>( 
    ID <EM CLASS="Emphasis">mplid,
</EM>    T_CMPL *<EM CLASS="Emphasis">pk_cmpl )</EM>
</PRE>
  <PRE CLASS="CodeExampleWide">ER <CODE CLASS="CodeOutput">del_mpl</CODE>( 
    ID <EM CLASS="Emphasis">mplid )</EM>
</PRE>
  <PRE CLASS="CodeExampleWide">ER <CODE CLASS="CodeOutput">cre_mpf</CODE>( 
    ID <EM CLASS="Emphasis">mpfid,
</EM>    T_CMPF *<EM CLASS="Emphasis">pk_cmpf )</EM>
</PRE>
  <PRE CLASS="CodeExampleWide">ER <CODE CLASS="CodeOutput">del_mpf</CODE>( 
    ID <EM CLASS="Emphasis">mpfid )</EM>
</PRE>
<P CLASS="Body">
<A NAME="pgfId=1034897">
 </A>
Because of the static initialization facilities provided for system objects, a memory pool is allocated a region of memory to manage statically in the configuration. So while memory pools can be created and deleted, the same area of memory is used for that memory pool (memory pool ID number) each time. The requested variable pool size (pk_cmpl<IMG SRC="pix/arrow.gif">mplsz) or the number of fixed-size blocks (pk_cmpf<IMG SRC="pix/arrow.gif">mpfcnt) times the block size (pk_cmpf<IMG SRC="pix/arrow.gif">blfsz) are checked for fitting within the statically allocated memory area, so if a create call succeeds, the resulting pool will be at least as large as that requested. For this reason <CODE CLASS="CodeOutput">
del_mpl()</CODE>
 and <CODE CLASS="CodeOutput">
del_mpf()</CODE>
 do not in any sense free the memory that was managed by the deleted pool for use by other pools; it may only be managed by a pool of the same object id. </P>
<P CLASS="Body">
<A NAME="pgfId=1034913">
 </A>
For both fixed and variable memory pools, the queueing order when waiting on a synchronization object depends on the underlying kernel configuration. The multi-level queue scheduler is required for strict <EM CLASS="FmSymbol">
&#181</EM>
ITRON conformance and it queues tasks in FIFO order, so requests to create an object with priority queueing of tasks (pk_cxxx<IMG SRC="pix/arrow.gif">xxxatr = TA_TPRI) are rejected with E_RSATR. Additional undefined bits in the attributes fields must be zero. </P>
<P CLASS="Body">
<A NAME="pgfId=1034941">
 </A>
In general, extended information (pk_cxxx<IMG SRC="pix/arrow.gif">exinf) is ignored. </P>
<H5 CLASS="Heading4">
<A NAME="pgfId=1034949">
 </A>
Error checking</H5>
<P CLASS="Body">
<A NAME="pgfId=1034955">
 </A>
The following conditions are only checked for, and only return errors if <EM CLASS="parameter">
CYGSEM_UITRON_BAD_PARAMS_RETURN_ERRORS</EM>
 is enabled:</P>
<UL>
<P><LI>
<A NAME="pgfId=1034973">
 </A>
invalid object id; less than 1 or greater than <EM CLASS="parameter">
CYGNUM_UITRON_MEMPOOLVAR/MEMPOOLFIXED</EM>
 as appropriate returns E_ID</LI>
<P><LI>
<A NAME="pgfId=1035000">
 </A>
dispatching is enabled in any call which can sleep, or E_CTX</LI>
<P><LI>
<A NAME="pgfId=1035012">
 </A>
tmout must be positive, otherwise E_PAR</LI>
<P><LI>
<A NAME="pgfId=1035022">
 </A>
pk_cxxx pointers in <CODE CLASS="CodeOutput">
cre_xxx()</CODE>
 must be valid pointer, or E_PAR</LI>
<P><LI>
<A NAME="pgfId=1035043">
 </A>
return value pointers in <CODE CLASS="CodeOutput">
ref_xxx()</CODE>
 is a valid pointer, or E_PAR</LI>
<P><LI>
<A NAME="pgfId=1035063">
 </A>
return value pointers in get block routines is a valid pointer, or E_PAR</LI>
<P><LI>
<A NAME="pgfId=1085912">
 </A>
blocksize request in get variable block routines is greater than zero, or E_PAR</LI>
</UL>
<P CLASS="Body">
<A NAME="pgfId=1085916">
 </A>
The following conditions are checked for, and can return error codes, regardless of the setting of <EM CLASS="parameter">
CYGSEM_UITRON_BAD_PARAMS_RETURN_ERRORS</EM>
:</P>
<UL>
<P><LI>
<A NAME="pgfId=1085939">
 </A>
When create and delete functions <CODE CLASS="CodeOutput">
cre_xxx()</CODE>
 and <CODE CLASS="CodeOutput">
del_xxx()</CODE>
 are supported, all calls which use a valid object ID number check that the object exists. If not, E_NOEXS is returned.</LI>
<P><LI>
<A NAME="pgfId=1085956">
 </A>
When create functions <CODE CLASS="CodeOutput">
cre_xxx()</CODE>
 are supported, if the object already exists, then E_OBJ</LI>
<P><LI>
<A NAME="pgfId=1085969">
 </A>
In any call which can sleep, such as <CODE CLASS="CodeOutput">
get_blk()</CODE>
: return codes E_TMOUT, E_RLWAI, E_DLT or of course E_OK are returned depending on the reason for terminating the sleep</LI>
<P><LI>
<A NAME="pgfId=1085982">
 </A>
In polling functions such as <CODE CLASS="CodeOutput">
pget_blk()</CODE>
return codes E_TMOUT or E_OK are returned depending on the state of the synchronization object</LI>
<P><LI>
<A NAME="pgfId=1085991">
 </A>
In creation functions, the attributes must be compatible with the selected underlying kernel configuration: in <CODE CLASS="CodeOutput">
cre_mpl()</CODE>
 <CODE CLASS="Code">
pk_cmpl<IMG SRC="pix/arrow.gif">mplatr</CODE>
 must be equal to <CODE CLASS="Code">
TA_TFIFO</CODE>
 else E_RSATR.</LI>
<P><LI>
<A NAME="pgfId=1086026">
 </A>
In <CODE CLASS="CodeOutput">
cre_mpf()</CODE>
 <CODE CLASS="Code">
pk_cmpf<IMG SRC="pix/arrow.gif">mpfatr</CODE>
 must be equal to <CODE CLASS="Code">
TA_TFIFO</CODE>
 else E_RSATR.</LI>
<P><LI>
<A NAME="pgfId=1086033">
 </A>
In creation functions, the requested size of the memory pool must not be larger than that statically configured for the pool else E_RSATR; see &quot;Option: Static initializers&quot;, in Section V. In <CODE CLASS="CodeOutput">
cre_mpl()</CODE>
 <CODE CLASS="Code">
pk_cmpl<IMG SRC="pix/arrow.gif">mplsz</CODE>
 is the field of interest</LI>
<P><LI>
<A NAME="pgfId=1086066">
 </A>
In <CODE CLASS="CodeOutput">
cre_mpf()</CODE>
 the product of <CODE CLASS="Code">
pk_cmpf<IMG SRC="pix/arrow.gif">blfsz</CODE>
 and <CODE CLASS="Code">
pk_cmpf<IMG SRC="pix/arrow.gif">mpfcnt</CODE>
 must be smaller than the memory statically configured for the pool else E_RSATR</LI>
<P><LI>
<A NAME="pgfId=1086083">
 </A>
In functions which return memory to the pool <CODE CLASS="CodeOutput">
rel_blk()</CODE>
 and <CODE CLASS="CodeOutput">
rel_blf()</CODE>
, if the free fails, for example because the memory did not come from that pool originally, then E_PAR is returned</LI>
</UL>
</DIV>
<DIV>
<H3 CLASS="Heading1">
<A NAME="pgfId=1086095">
 </A>
<A NAME="marker=1086092">
 </A>
Time Management Functions</H3>
<P CLASS="Body">
<A NAME="pgfId=1035446">
 </A>
These functions are fully supported in this release: </P>
  <PRE CLASS="CodeExampleWide"><A NAME="pgfId=1035453"> </A>
ER <CODE CLASS="CodeOutput">set_tim</CODE>( 
    SYSTIME *<EM CLASS="Emphasis">pk_tim )</EM>
</PRE>
<H3 CLASS="Label">
<A NAME="pgfId=1035481">
 </A>
CAUTION</H3>
<P CLASS="Note">
<A NAME="pgfId=1076170">
 </A>
Setting the time may cause erroneous operation of the kernel, for example a task performing a wait with a time-out may never awaken. </P>
  <PRE CLASS="CodeExampleWide">ER <CODE CLASS="CodeOutput">get_tim</CODE>( 
    SYSTIME *<EM CLASS="Emphasis">pk_tim )</EM>
</PRE>
  <PRE CLASS="CodeExampleWide">ER <CODE CLASS="CodeOutput">dly_tsk</CODE>( 
    DLYTIME <EM CLASS="Emphasis">dlytim )</EM>
</PRE>
  <PRE CLASS="CodeExampleWide">ER <CODE CLASS="CodeOutput">def_cyc</CODE>( 
    HNO <EM CLASS="Emphasis">cycno,
</EM>    T_DCYC *<EM CLASS="Emphasis">pk_dcyc )</EM>
</PRE>
  <PRE CLASS="CodeExampleWide">ER <CODE CLASS="CodeOutput">act_cyc</CODE>( 
    HNO <EM CLASS="Emphasis">cycno,
</EM>    UINT <EM CLASS="Emphasis">cycact )</EM>
</PRE>
  <PRE CLASS="CodeExampleWide">ER <CODE CLASS="CodeOutput">ref_cyc</CODE>( 
    T_RCYC *<EM CLASS="Emphasis">pk_rcyc,
</EM>    HNO <EM CLASS="Emphasis">cycno )</EM>
<A NAME="pgfId=1035672"> </A>
ER <CODE CLASS="CodeOutput">def_alm</CODE>( 
    HNO <EM CLASS="Emphasis">almno,
</EM>    T_DALM *<EM CLASS="Emphasis">pk_dalm )</EM>
<A NAME="pgfId=1035712"> </A>
ER <CODE CLASS="CodeOutput">ref_alm</CODE>( 
    T_RALM *<EM CLASS="Emphasis">pk_ralm,
</EM>&nbsp;&nbsp;&nbsp;&nbsp;HNO <EM CLASS="Emphasis">almno )</EM>
</PRE>
  <PRE CLASS="CodeExampleWide">void <CODE CLASS="CodeOutput">ret_tmr</CODE>( void )

    Error checking</PRE>
<P CLASS="Body">
<A NAME="pgfId=1035779">
 </A>
The following conditions are only checked for, and only return errors if <EM CLASS="parameter">
CYGSEM_UITRON_BAD_PARAMS_RETURN_ERRORS</EM>
 is enabled:</P>
<UL>
<P><LI>
<A NAME="pgfId=1035797">
 </A>
invalid handler number; less than 1 or greater than <EM CLASS="parameter">
CYGNUM_UITRON_CYCLICS/ALARMS</EM>
 as appropriate, or E_PAR</LI>
<P><LI>
<A NAME="pgfId=1035825">
 </A>
dispatching is enabled in <CODE CLASS="CodeOutput">
dly_tsk()</CODE>
, or E_CTX</LI>
<P><LI>
<A NAME="pgfId=1035845">
 </A>
dlytim must be positive or zero, otherwise E_PAR</LI>
<P><LI>
<A NAME="pgfId=1035855">
 </A>
return value pointers in <CODE CLASS="CodeOutput">
ref_xxx()</CODE>
 is a valid pointer, or E_PAR</LI>
<P><LI>
<A NAME="pgfId=1035875">
 </A>
params within pk_dalm and pk_dcyc must be valid, or E_PAR</LI>
<P><LI>
<A NAME="pgfId=1035887">
 </A>
cycact in <CODE CLASS="CodeOutput">
act_cyc()</CODE>
 must be valid, or E_PAR</LI>
<P><LI>
<A NAME="pgfId=1035929">
 </A>
handler must be defined in <CODE CLASS="CodeOutput">
ref_xxx()</CODE>
 and <CODE CLASS="CodeOutput">
act_cyc()</CODE>
, or E_NOEXS</LI>
<P><LI>
<A NAME="pgfId=1035960">
 </A>
parameter pointer must be a good pointer in <CODE CLASS="CodeOutput">
get_tim()</CODE>
 and <CODE CLASS="CodeOutput">
set_tim()</CODE>
, otherwise E_PAR is returned</LI>
</UL>
<P CLASS="Body">
<A NAME="pgfId=1035971">
 </A>
The following conditions are checked for, and can return error codes, regardless of the setting of <EM CLASS="parameter">
CYGSEM_UITRON_BAD_PARAMS_RETURN_ERRORS</EM>
:</P>
<UL>
<P><LI>
<A NAME="pgfId=1035989">
 </A>
<CODE CLASS="CodeOutput">
dly_tsk()</CODE>
: return code E_RLWAI is returned depending on the reason for terminating the sleep</LI>
</UL>
</DIV>
<DIV>
<H3 CLASS="Heading1">
<A NAME="pgfId=1036014">
 </A>
<A NAME="marker=1085011">
 </A>
System Management Functions</H3>
<P CLASS="Body">
<A NAME="pgfId=1036024">
 </A>
These functions are fully supported in this release: </P>
  <PRE CLASS="CodeExampleWide">ER <CODE CLASS="CodeOutput">get_ver</CODE>( 
    T_VER *<EM CLASS="Emphasis">pk_ver )</EM>
</PRE>
  <PRE CLASS="CodeExampleWide">ER <CODE CLASS="CodeOutput">ref_sys</CODE>( 
    T_RSYS *<EM CLASS="Emphasis">pk_rsys )</EM>
</PRE>
  <PRE CLASS="CodeExampleWide">ER <CODE CLASS="CodeOutput">ref_cfg</CODE>( 
    T_RCFG *<EM CLASS="Emphasis">pk_rcfg )</EM>
</PRE>
<P CLASS="Body">
<A NAME="pgfId=1036115">
 </A>
Note that the information returned by each of these calls may be configured to match the user's own versioning system, and the values supplied by the default configuration may be inappropriate. </P>
<P CLASS="Body">
<A NAME="pgfId=1036128">
 </A>
These functions are not supported in this release: </P>
  <PRE CLASS="CodeExampleWide">ER <CODE CLASS="CodeOutput">def_svc</CODE>( 
    FN <EM CLASS="Emphasis">s_fncd,
</EM>    T_DSVC *<EM CLASS="Emphasis">pk_dsvc )</EM>
</PRE>
  <PRE CLASS="CodeExampleWide">ER <CODE CLASS="CodeOutput">def_exc</CODE>( 
    UINT <EM CLASS="Emphasis">exckind,
</EM>    T_DEXC *<EM CLASS="Emphasis">pk_dexc )</EM>
</PRE>
<H5 CLASS="Heading4">
<A NAME="pgfId=1036215">
 </A>
Error checking</H5>
<P CLASS="Body">
<A NAME="pgfId=1036221">
 </A>
The following conditions are only checked for, and only return errors if <EM CLASS="parameter">
CYGSEM_UITRON_BAD_PARAMS_RETURN_ERRORS</EM>
 is enabled: </P>
<UL>
<P><LI>
<A NAME="pgfId=1036240">
 </A>
return value pointer in all calls is a valid pointer, or E_PAR</LI>
</UL>
</DIV>
<DIV>
<H3 CLASS="Heading1">
<A NAME="pgfId=1036256">
 </A>
<A NAME="marker=1085014">
 </A>
Network Support Functions</H3>
<P CLASS="Body">
<A NAME="pgfId=1036266">
 </A>
None of these functions are supported in this release. </P>
<TABLE>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
</TD>
</TR>
</TABLE>
</DIV>
<HR ALIGN="center"><TABLE STYLE="ECOS" WIDTH="98%" BORDER="0" ALIGN="LEFT" CELLPADDING="1"><TR><TH COLSPAN="3" ALIGN="center"><P CLASS="Gotos"><EM CLASS="FmSymbol">
&#181</EM>ITRON API</P></TH></TR><TR><TD  ALIGN="center"><P CLASS="Gotos"><A HREF="ecos-ref.2.html">To Contents</A></P></TD><TD  ALIGN="center"><P CLASS="Gotos"><A HREF="ecos-ref.9.html">To&nbsp;previous&nbsp;page</A></P></TD><TD  ALIGN="center"><P CLASS="Gotos"><A HREF="ecos-ref.b.html">To&nbsp;next&nbsp;page</A></P></TD></TR></TABLE></BODY>
</HTML>
