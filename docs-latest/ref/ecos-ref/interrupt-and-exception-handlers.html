<HTML
><HEAD
><TITLE
>Interrupt
and exception handlers</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.33"><LINK
REL="HOME"
TITLE="eCos Reference
Manual"
HREF="ecos-ref.html"><LINK
REL="UP"
TITLE="Requirements for programs"
HREF="requirements-for-programs.html"><LINK
REL="PREVIOUS"
TITLE="Necessary link
instructions"
HREF="necessary-link-instructions.html"><LINK
REL="NEXT"
TITLE="Memory allocation"
HREF="memory-allocation.html"></HEAD
><BODY
><DIV
CLASS="NAVHEADER"
><TABLE
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="3"
ALIGN="center"
><SPAN
CLASS="TRADEMARK"
>eCos</SPAN
><SUP
><FONT
SIZE="-4"
>TM</FONT
></SUP
> Reference
Manual</TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="bottom"
><A
HREF="necessary-link-instructions.html"
>Prev</A
></TD
><TD
WIDTH="80%"
ALIGN="center"
VALIGN="bottom"
>Chapter 3. Requirements for programs</TD
><TD
WIDTH="10%"
ALIGN="right"
VALIGN="bottom"
><A
HREF="memory-allocation.html"
>Next</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><DIV
CLASS="SECT1"
><H1
CLASS="SECT1"
><A
NAME="INTERRUPT-AND-EXCEPTION-HANDLERS"
>Interrupt
and exception handlers</A
></H1
><P
>In <SPAN
CLASS="PRODUCTNAME"
>eCos</SPAN
> a distinction is made between <I
CLASS="FIRSTTERM"
>exceptions</I
> and <I
CLASS="FIRSTTERM"
>interrupts</I
>.</P
><P
></P
><DL
><DT
><TT
CLASS="PARAMETER"
><I
>exceptions</I
></TT
></DT
><DD
><P
>are the result of some action by the currently executing
code. Examples of exceptions are divide by zero, illegal instruction,
bad memory access, etc.</P
></DD
><DT
><TT
CLASS="PARAMETER"
><I
>interrupts</I
></TT
></DT
><DD
><P
>are the result of a signal source which is conceptually
asynchronous with the currently executing code. Examples of interrupts
sources are the real-time clock, external and on chip peripherals
and so forth. </P
></DD
></DL
><P
>This distinction is made in the <SPAN
CLASS="PRODUCTNAME"
>eCos</SPAN
> hardware
abstraction layer (HAL) to provide a cleaner and more portable mechanism
for installing interrupt handlers and exception handlers. Individual
hardware platforms can have different ways of naming and handling
interrupts, which is why this abstraction layer was chosen. </P
><P
>Interrupts and exceptions are both associated with <I
CLASS="FIRSTTERM"
>vectors</I
>,
which are labeled by <I
CLASS="FIRSTTERM"
>vector numbers</I
> (see <A
HREF="exception-handling.html"
>the section called <I
>Exception handling</I
> in Chapter 5</A
> and <A
HREF="interrupt-handling.html"
>the section called <I
>Interrupt
handling</I
> in Chapter 5</A
>).</P
><P
>There are distinct spaces for exception and interrupt vectors.
These are called &#8220;exception vector numbers&#8221; and &#8220;interrupt
vector numbers&#8221;. System calls which install exception handlers
use the exception vector number, and the system calls which install
interrupt handlers use the interrupt vector number to specify which
interrupt or exception should be handled by the handler.</P
><P
>The details of the vector layout depend on the microprocessor
and interrupt controller, and are documented in the relevant API
sections.</P
><P
>Interrupt handlers are actually a <I
CLASS="EMPHASIS"
>pair</I
> of
functions, one of which (the <I
CLASS="FIRSTTERM"
>interrupt service routine</I
>,
or <SPAN
CLASS="ACRONYM"
>ISR</SPAN
>) is executed immediately and runs with
that interrupt disabled. Since interrupts are disabled for the duration
of the ISR, the ISR should be very brief and should not use any
system services.</P
><P
>After the ISR exits, but before the kernel scheduler is invoked
again, a <I
CLASS="FIRSTTERM"
>delayed service routine</I
> (<SPAN
CLASS="ACRONYM"
>DSR</SPAN
>)
will be invoked. It executes with scheduling disabled, but with
interrupts enabled, so that further invocations of the same DSR
can be queued. The DSR can use some producer-side system calls,
but it should be carefully crafted to avoid using any call that
might put its thread to sleep. One of the few examples of safe calls
is 
<TT
CLASS="FUNCTION"
><B
>cyg_semaphore_post()</B
></TT
>; the non-blocking versions
of some system calls are also safe. A call that is unsafe is <TT
CLASS="FUNCTION"
><B
>cyg_mutex_lock()</B
></TT
>,
since it will block if the mutex is already locked by another thread.</P
><P
>Finally, <SPAN
CLASS="PRODUCTNAME"
>eCos</SPAN
> has a formalism for
installing <I
CLASS="EMPHASIS"
>low level handlers</I
> which bypass
the kernel mechanisms described above. A program can install a <I
CLASS="FIRSTTERM"
>vector service
routine</I
> (<SPAN
CLASS="ACRONYM"
>VSR</SPAN
>) which will be invoked
instead of the kernel's usual exception or interrupt handling.
The VSR will typically be written in assembly language. </P
><P
>VSRs are associated with vector numbers in the exception space,
just like exception handlers (although there are some variations &#8212; architectures
in which there are no exceptions in the <SPAN
CLASS="PRODUCTNAME"
>eCos</SPAN
> sense).
The main difference between VSRs and exception handlers is that
VSRs bypass the kernel's usual mechanisms. </P
></DIV
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="necessary-link-instructions.html"
>Prev</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="ecos-ref.html"
>Home</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="memory-allocation.html"
>Next</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>Necessary link
instructions</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="requirements-for-programs.html"
>Up</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>Memory allocation</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>