<HTML
><HEAD
><TITLE
>The eCos PCI Library</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.33"><LINK
REL="HOME"
TITLE="eCos Reference
Manual"
HREF="ecos-ref.html"><LINK
REL="UP"
TITLE="PCI Library"
HREF="pci-library.html"><LINK
REL="PREVIOUS"
TITLE="PCI Library"
HREF="pci-library.html"><LINK
REL="NEXT"
TITLE="PCI Library reference"
HREF="x4507.html"></HEAD
><BODY
><DIV
CLASS="NAVHEADER"
><TABLE
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="3"
ALIGN="center"
><SPAN
CLASS="TRADEMARK"
>eCos</SPAN
><SUP
><FONT
SIZE="-4"
>TM</FONT
></SUP
> Reference
Manual</TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="bottom"
><A
HREF="pci-library.html"
>Prev</A
></TD
><TD
WIDTH="80%"
ALIGN="center"
VALIGN="bottom"
></TD
><TD
WIDTH="10%"
ALIGN="right"
VALIGN="bottom"
><A
HREF="x4507.html"
>Next</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><DIV
CLASS="CHAPTER"
><H1
><A
NAME="AEN4439"
>Chapter 9. The eCos PCI Library</A
></H1
><DIV
CLASS="TOC"
><DL
><DT
><B
>Table of Contents</B
></DT
><DT
><A
HREF="c4439.html#AEN4442"
>PCI Library</A
></DT
><DT
><A
HREF="x4507.html"
>PCI Library reference</A
></DT
></DL
></DIV
><P
>The PCI library is an optional part of eCos, and is only applicable
to some packages.</P
><DIV
CLASS="SECT1"
><H1
CLASS="SECT1"
><A
NAME="AEN4442"
>PCI Library</A
></H1
><P
>The eCos PCI library provides the following functionality:</P
><P
>1) Scan the PCI bus for specific devices or devices of a certain
class.
2) Read and change generic PCI information.
3) Read and change device-specific PCI information.
4) Allocate PCI memory and IO space to devices.
5) Translate a device's PCI interrupts to equivalent HAL
vectors.</P
><P
>Example code fragments are from the pci1 test (seeio/pci/&#60;release&#62;/tests/pci1.c).</P
><P
>All of the functions described below are declared in the header
file &#60;cyg/io/pci.h&#62; which all
clients of the PCI library should include.</P
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN4448"
>Initialising the bus</A
></H2
><P
>The PCI bus needs to be initialized before it can be used.
This only needs to be done once - some HALs may do it as part of
the platform initialization procedure, other HALs may leave it to
the application to do it. The following function will do the initialization
only once, so it's safe to call from multiple drivers:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>void cyg_pci_init( void );</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN4452"
>Scanning for devices</A
></H2
><P
>After the bus has been initialized, it is possible to scan
it for devices. This is done using the function:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>cyg_bool cyg_pci_find_next( cyg_pci_device_id cur_devid, 
	                     cyg_pci_device_id *next_devid );</PRE
></TD
></TR
></TABLE
><P
>It will scan the bus for devices starting at cur_devid.
If a device is found, its devid is stored in next_devid
and the function returns true.</P
><P
>The pci1 test's outer loop looks like:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>cyg_pci_init();
    if (cyg_pci_find_next(CYG_PCI_NULL_DEVID, &#38;devid)) {
        do {
             &#60;use devid&#62;
        } while (cyg_pci_find_next(devid, &#38;devid));
    }</PRE
></TD
></TR
></TABLE
><P
>What happens is that the bus gets initialized and a scan is
started. CYG_PCI_NULL_DEVID causes cyg_pci_find_next()
to restart its scan. If the bus does not contain any devices, the
first call to cyg_pci_find_next() will
return false.</P
><P
>If the call returns true, a loop is entered where the found
devid is used. After devid processing has completed, the next device
on the bus is searched for; cyg_pci_find_next()
continues its scan from the current devid. The loop terminates when
no more devices are found on the bus.</P
><P
>This is the generic way of scanning the bus, enumerating all
the devices on the bus. But if the application is looking for a
device of a given device class (e.g., a SCSI controller), or a specific
vendor device, these functions simplify the task a bit:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>cyg_bool cyg_pci_find_class( cyg_uint32 dev_class,
                              cyg_pci_device_id *devid );
cyg_bool cyg_pci_find_device( cyg_uint16 vendor, cyg_uint16 device,
                               cyg_pci_device_id *devid );</PRE
></TD
></TR
></TABLE
><P
>They work just like cyg_pci_find_next(),
but only return true when the, dev_class or vendor/device
qualifiers match those of a device on the bus. The devid serves
as both an input and an output operand: the scan starts at the given
device, and if a device is found devid is updated with the value
for the found device.</P
><P
>The &#60;cyg/io/pci_cfg.h&#62; header
file (included by pci.h) contains definitions for PCI class, vendor
and device codes which can be used as arguments to the find functions. The
list of vendor and device codes is not complete: add new codes as
necessary. If possible also register the codes at the PCI Code List
(http://www.yourvote.com/pci) which is
where the eCos definitions are generated from.</P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN4465"
>Generic config information</A
></H2
><P
>When a valid device ID (devid) is found using one of the above
functions, the associated device can be queried and controlled using
the functions:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>void cyg_pci_get_device_info ( cyg_pci_device_id devid, 
                                cyg_pci_device *dev_info );
void cyg_pci_set_device_info ( cyg_pci_device_id devid, 
                                cyg_pci_device *dev_info );</PRE
></TD
></TR
></TABLE
><P
>The cyg_pci_device structure (defined in
pci.h) primarily holds information as described by the PCI specification [1].
The pci1 test prints out some of this information:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>           // Get device info
            cyg_pci_get_device_info(devid, &#38;dev_info);
            diag_printf("\n Command   0x%04x, Status 0x%04x\n",
                        dev_info.command, dev_info.status);</PRE
></TD
></TR
></TABLE
><P
>The command register can also be written to, controlling (among
other things) whether the device responds to IO and memory access
from the bus. </P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN4472"
>Specific config information</A
></H2
><P
>The above functions only allow access to generic PCI config
registers. A device can have extra config registers not specified
by the PCI specification. These can be accessed with these functions:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>void cyg_pci_read_config_uint8( cyg_pci_device_id devid,
                                 cyg_uint8 offset, cyg_uint8 *val);
void cyg_pci_read_config_uint16( cyg_pci_device_id devid,
                                  cyg_uint8 offset, cyg_uint16 *val);
void cyg_pci_read_config_uint32( cyg_pci_device_id devid,
                                  cyg_uint8 offset, cyg_uint32 *val);
void cyg_pci_write_config_uint8( cyg_pci_device_id devid,
                                  cyg_uint8 offset, cyg_uint8 val);
void cyg_pci_write_config_uint16( cyg_pci_device_id devid,
                                   cyg_uint8 offset, cyg_uint16 val);
void cyg_pci_write_config_uint32( cyg_pci_device_id devid,
                                   cyg_uint8 offset, cyg_uint32 val);</PRE
></TD
></TR
></TABLE
><P
>The write functions should only be used for device-specific
config registers since using them on generic registers may invalidate
the contents of a previously fetched cyg_pci_device
structure.</P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN4477"
>Allocating memory</A
></H2
><P
>A PCI device ignores all IO and memory access from the PCI
bus until it has been activated. Activation cannot happen until
after device configuration. Configuration means telling the device
where it should map its IO and memory resources. This is done with
this function:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>cyg_bool cyg_pci_configure_device( cyg_pci_device *dev_info );</PRE
></TD
></TR
></TABLE
><P
>This function handles all IO and memory regions that need
configuration on the device. Each region is represented in the PCI
device's config space by one of six BARs (Base Address
Registers) and is handled individually according to type using these
functions:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>cyg_bool cyg_pci_allocate_memory( cyg_pci_device *dev_info,
                                   cyg_uint32 bar, 
                                   CYG_PCI_ADDRESS64 *base );
 cyg_bool cyg_pci_allocate_io( cyg_pci_device *dev_info,
                               cyg_uint32 bar, 
                               CYG_PCI_ADDRESS32 *base );</PRE
></TD
></TR
></TABLE
><P
>The memory bases (in two distinct address spaces) are increased
as memory regions are allocated to devices. Allocation will fail
(the function returns false) if the base exceeds the limits of the
address space (IO is 1MB, memory is 2^32 or 2^64 bytes).</P
><P
>These functions can also be called directly be the application/driver
if necessary, but this should not be necessary.</P
><P
>The bases are initialized with default values provided by
the HAL. It is possible for an application to override these using
the following functions: </P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>void cyg_pci_set_memory_base( CYG_PCI_ADDRESS64 base );
void cyg_pci_set_io_base( CYG_PCI_ADDRESS32 base );</PRE
></TD
></TR
></TABLE
><P
>When a device has been configured, the cyg_pci_device
structure will contain the physical address in the CPU's
address space where the device's memory regions can be
accessed. </P
><P
>This information is provided in base_map[] -
there is a 32 bit word for each of the device's BARs. For
32 bit PCI memory regions, each 32 bit word will be an actual pointer
that can be used immediately by the driver: the memory space will
normally be linearly addressable by the CPU.</P
><P
>However, for 64 bit PCI memory regions, some (or all) of the
region may be outside of the CPUs address space. In this case the
driver will need to know how to access the region in segments. This
functionality may be adopted by the eCos HAL if deemed useful in
the future. The 2GB available on many systems should suffice though.</P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN4490"
>Interrupts</A
></H2
><P
>A device may generate interrupts. The HAL vector associated
with a given device on the bus is platform specific. This function
allows a driver to find the actual interrupt vector for a given
device:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>cyg_bool cyg_pci_translate_interrupt( cyg_pci_device *dev_info,
                                       CYG_ADDRWORD *vec );</PRE
></TD
></TR
></TABLE
><P
>If the function returns false, no interrupts will be generated
by the device. If it returns true, the CYG_ADDRWORD pointed
to by vec is updated with the HAL interrupt vector the device will
be using. This is how the function is used in the pci1 test:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>            if (cyg_pci_translate_interrupt(&#38;dev_info, &#38;irq))
                diag_printf(" Wired to HAL vector %d\n", irq);
            else                diag_printf(" Does not generate interrupts.\n");</PRE
></TD
></TR
></TABLE
><P
>The application/drive should attach an interrupt
handler to a device's interrupt before activating the device.</P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN4497"
>Activating a device</A
></H2
><P
>When the device has been allocated memory space it can be
activated. This is not done by the library since a driver may have
to initialize more state on the device before it can be safely activated.</P
><P
>Activating the device is done by enabling flags in its command
word. As an example, see the pci1 test which can be configured to
enable the devices it finds. This allows these to be accessed from
GDB (if a breakpoint is set on cyg_test_exit):</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>#ifdef ENABLE_PCI_DEVICES
                {
                    cyg_uint16 cmd;
                    // Don't use cyg_pci_set_device_info since it clears
                    // some of the fields we want to print out below.
                    cyg_pci_read_config_uint16(dev_info.devid,
                                               CYG_PCI_CFG_COMMAND, &#38;cmd);
                    cmd |=
CYG_PCI_CFG_COMMAND_IO|CYG_PCI_CFG_COMMAND_MEMORY;
                    cyg_pci_write_config_uint16(dev_info.devid,
                                                CYG_PCI_CFG_COMMAND, cmd);
                }
                diag_printf(" **** Device IO and MEM access enabled\n");
#endif</PRE
></TD
></TR
></TABLE
><P
> Note: that the best way to activate a device is actually
through cyg_pci_set_device_info(),
but in this particular case the cyg_pci_device
structure contents from before the activation is required for printout
further down in the code.</P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN4503"
>Links</A
></H2
><P
>See these links for more information about PCI.</P
><P
>1) See http://www.pcisig.com  (information
on the PCI specifications)
2) See http://www.yourvote.com/pci  (list
of vendor and device IDs)
3) See http://www.picmg.org  (PCI Industrial Computer
Manufacturers Group)</P
></DIV
></DIV
></DIV
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="pci-library.html"
>Prev</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="ecos-ref.html"
>Home</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="x4507.html"
>Next</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>PCI Library</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="pci-library.html"
>Up</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>PCI Library reference</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>