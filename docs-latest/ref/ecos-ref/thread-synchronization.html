<HTML
><HEAD
><TITLE
>Thread 
synchronization</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.33"><LINK
REL="HOME"
TITLE="eCos Reference
Manual"
HREF="ecos-ref.html"><LINK
REL="UP"
TITLE="eCos kernel overview"
HREF="ecos-kernel-overview.html"><LINK
REL="PREVIOUS"
TITLE="eCos kernel overview"
HREF="ecos-kernel-overview.html"><LINK
REL="NEXT"
TITLE="Exceptions"
HREF="exceptions.html"></HEAD
><BODY
><DIV
CLASS="NAVHEADER"
><TABLE
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="3"
ALIGN="center"
><SPAN
CLASS="TRADEMARK"
>eCos</SPAN
><SUP
><FONT
SIZE="-4"
>TM</FONT
></SUP
> Reference
Manual</TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="bottom"
><A
HREF="ecos-kernel-overview.html"
>Prev</A
></TD
><TD
WIDTH="80%"
ALIGN="center"
VALIGN="bottom"
>Chapter 1. <SPAN
CLASS="PRODUCTNAME"
>eCos</SPAN
> kernel overview</TD
><TD
WIDTH="10%"
ALIGN="right"
VALIGN="bottom"
><A
HREF="exceptions.html"
>Next</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><DIV
CLASS="SECT1"
><H1
CLASS="SECT1"
><A
NAME="THREAD-SYNCHRONIZATION"
>Thread 
synchronization</A
></H1
><P
>To allow threads to cooperate and compete for resources, it
is necessary to provide mechanisms for synchronization and communication.
The classic synchronization mechanisms are mutexes/condition
variables and semaphores. These are provided in the <SPAN
CLASS="PRODUCTNAME"
>eCos</SPAN
> kernel,
together with other synchronization/communication mechanisms that
are common in real-time systems, such as event flags and message
queues. </P
><P
>One of the problems that must be dealt with in any real-time
systems is priority inversion. This is where
a high priority thread is (wrongly) prevented from continuing by
one at lower priority. The normal example is of a high priority
thread waiting at a mutex already held by a low priority thread.
If the low priority thread is preempted by a medium priority thread
then priority inversion has occurred since the high priority thread
is prevented from continuing by an unrelated thread of lower priority.</P
><P
>This problem got much attention recently when the Mars Pathfinder
mission had to reset the computers on the ground exploration robot
repeatedly because a priority inversion problem would cause it to
hang. </P
><P
>There are several solutions to this problem. The simplest
is to employ a priority ceiling protocol
where all threads that acquire the mutex have their priority boosted
to some predetermined value. This has a number of disadvantages:
it requires the maximum priority of the threads using the mutex
to be known in advance; if the ceiling priority is too high it acts
as a global lock disabling all scheduling and it is pessimistic,
taking action to prevent the problem even when it does not arise. </P
><P
>A better solution is to use priority inheritance
protocol. Here, the priority of the thread that owns the mutex is
boosted to equal that of the highest priority thread that is waiting
for it. This technique does not require prior knowledge of the priorities
of the threads that are going to use the mutex, and the priority
of the owning thread is only boosted when a higher priority thread
is waiting. This reduces the effect on the scheduling of other threads,
and is more optimistic than the priority ceiling protocol. A disadvantage
of this mechanism is that the cost of each synchronization call
is increased since the inheritance protocol must be obeyed each
time. </P
><P
>A third approach to priority inversion is to recognize that
relative thread priorities have been poorly chosen and thus the
system in which it occurs is faulty. In this case the kernel needs
the ability to detect when priority inversion has taken place, and
to raise an exception when it occurs to aid debugging. Then this
code is removed from the shipping version. </P
><P
>The current <SPAN
CLASS="PRODUCTNAME"
>eCos</SPAN
> release provides
a relatively simple implementation of mutex priority inheritance.
This implementation will only work in the multi-level queue scheduler,
and it does not handle the rare case of nested mutexes completely
correctly. However it is both fast and deterministic. Mutex priority
inheritance can be disabled if the application does not require
it. This will reduce both code size and data space. </P
><P
>Future releases will provide alternative implementations of
mutex priority inheritance, and application developers will be able
to choose the implementation appropriate to their application. </P
></DIV
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="ecos-kernel-overview.html"
>Prev</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="ecos-ref.html"
>Home</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="exceptions.html"
>Next</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><SPAN
CLASS="PRODUCTNAME"
>eCos</SPAN
> kernel overview</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="ecos-kernel-overview.html"
>Up</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>Exceptions</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>