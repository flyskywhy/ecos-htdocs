<HTML
><HEAD
><TITLE
>Measured items</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.33"><LINK
REL="HOME"
TITLE="eCos Users
Guide"
HREF="user-guides.html"><LINK
REL="UP"
TITLE="Real-time
characterization"
HREF="real-time-characterization.html"><LINK
REL="PREVIOUS"
TITLE="Influences on 
performance"
HREF="whats-missing.html"><LINK
REL="NEXT"
TITLE="Sample numbers"
HREF="sample-numbers.html"></HEAD
><BODY
><DIV
CLASS="NAVHEADER"
><TABLE
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="3"
ALIGN="center"
><SPAN
CLASS="TRADEMARK"
>eCos</SPAN
><SUP
><FONT
SIZE="-4"
>TM</FONT
></SUP
> User&#8217;s
Guide</TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="bottom"
><A
HREF="whats-missing.html"
>Prev</A
></TD
><TD
WIDTH="80%"
ALIGN="center"
VALIGN="bottom"
>Chapter 9. Real-time
characterization</TD
><TD
WIDTH="10%"
ALIGN="right"
VALIGN="bottom"
><A
HREF="sample-numbers.html"
>Next</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><DIV
CLASS="SECT1"
><H1
CLASS="SECT1"
><A
NAME="MEASURED-ITEMS"
>Measured items</A
></H1
><P
>This section will describe the various tests and the numbers presented.
All tests use the C kernel API (available by way of <TT
CLASS="FILENAME"
>cyg/kernel/kapi.h</TT
>).
There is a single main thread in the system which performs the various
tests. Additional threads may be created as part of the testing,
but these are short lived and are destroyed between tests unless
otherwise noted. In this discussion, the terminology &#8220;lower
priority&#8221; means a priority which is less important, not
necessarily lower in numerical value. A higher priority thread will
run in preference to a lower priority thread even though the priority
value of the higher priority thread may be numerically less than
that of the lower priority thread. </P
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN2560"
>Thread primitives</A
></H2
><P
></P
><DL
><DT
>Create thread</DT
><DD
><P
>This test measures the <TT
CLASS="FUNCTION"
><B
>cyg_thread_create()</B
></TT
> call.
Each call creates a totally new thread. The set of threads created
by this test will be reused in the subsequent thread primitive tests. </P
></DD
><DT
>Yield thread</DT
><DD
><P
>This test measures the <TT
CLASS="FUNCTION"
><B
>cyg_thread_yield()</B
></TT
> call.
For this test, there are no other runnable threads, thus the test
should just measure the overhead of trying to give up the CPU. </P
></DD
><DT
>Suspend [suspended] thread</DT
><DD
><P
>This test measures the <TT
CLASS="FUNCTION"
><B
>cyg_thread_suspend()</B
></TT
> call.
A thread may be suspended multiple times; each thread is already
suspended from its initial creation, and is suspended again. </P
></DD
><DT
>Resume thread</DT
><DD
><P
>This test measures the <TT
CLASS="FUNCTION"
><B
>cyg_thread_resume()</B
></TT
> call.
All of the threads have a suspend count of 2, thus this call does
not make them runnable. This test just measures the overhead of
resuming a thread. </P
></DD
><DT
>Set priority</DT
><DD
><P
>This test measures the <TT
CLASS="FUNCTION"
><B
>cyg_thread_set_priority()</B
></TT
> call.
Each thread, currently suspended, has its priority set to a new
value. </P
></DD
><DT
>Get priority</DT
><DD
><P
>This test measures the <TT
CLASS="FUNCTION"
><B
>cyg_thread_get_priority()</B
></TT
> call. </P
></DD
><DT
>Kill [suspended] thread</DT
><DD
><P
>This test measures the <TT
CLASS="FUNCTION"
><B
>cyg_thread_kill()</B
></TT
> call.
Each thread in the set is killed. All threads are known to be suspended
before being killed. </P
></DD
><DT
>Yield [no other] thread</DT
><DD
><P
>This test measures the <TT
CLASS="FUNCTION"
><B
>cyg_thread_yield()</B
></TT
> call
again. This is to demonstrate that the <TT
CLASS="FUNCTION"
><B
>cyg_thread_yield()</B
></TT
> call
has a fixed overhead, regardless of whether there are other threads
in the system. </P
></DD
><DT
>Resume [suspended low priority] thread</DT
><DD
><P
>This test measures the <TT
CLASS="FUNCTION"
><B
>cyg_thread_resume()</B
></TT
> call
again. In this case, the thread being resumed is lower priority
than the main thread, thus it will simply become ready to run but
not be granted the CPU. This test measures the cost of making a
thread ready to run. </P
></DD
><DT
>Resume [runnable low priority] thread</DT
><DD
><P
>This test measures the <TT
CLASS="FUNCTION"
><B
>cyg_thread_resume()</B
></TT
> call
again. In this case, the thread being resumed is lower priority
than the main thread and has already been made runnable, so in fact
the resume call has no effect. </P
></DD
><DT
>Suspend [runnable] thread</DT
><DD
><P
>This test measures the <TT
CLASS="FUNCTION"
><B
>cyg_thread_suspend()</B
></TT
> call
again. In this case, each thread has already been made runnable
(by previous tests). </P
></DD
><DT
>Yield [only low priority] thread</DT
><DD
><P
>This test measures the <TT
CLASS="FUNCTION"
><B
>cyg_thread_yield()</B
></TT
> call.
In this case, there are many other runnable threads, but they are
all lower priority than the main thread, thus no thread switches
will take place. </P
></DD
><DT
>Suspend [runnable-&#62;not runnable] thread</DT
><DD
><P
>This test measures the <TT
CLASS="FUNCTION"
><B
>cyg_thread_suspend()</B
></TT
> call
again. The thread being suspended will become non-runnable by this
action. </P
></DD
><DT
>Kill [runnable] thread</DT
><DD
><P
>This test measures the <TT
CLASS="FUNCTION"
><B
>cyg_thread_kill()</B
></TT
> call
again. In this case, the thread being killed is currently runnable,
but lower priority than the main thread. </P
></DD
><DT
>Resume [high priority] thread</DT
><DD
><P
>This test measures the <TT
CLASS="FUNCTION"
><B
>cyg_thread_resume()</B
></TT
> call.
The thread being resumed is higher priority than the main thread,
thus a thread switch will take place on each call. In fact there
will be two thread switches; one to the new higher priority thread
and a second back to the test thread. The test thread exits immediately. </P
></DD
><DT
>Thread switch</DT
><DD
><P
>This test attempts to measure the cost of switching
from one thread to another. Two equal priority threads are started
and they will each yield to the other for a number of iterations.
A time stamp is gathered in one thread before the <TT
CLASS="FUNCTION"
><B
>cyg_thread_yield()</B
></TT
> call
and after the call in the other thread. </P
></DD
></DL
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN2647"
>Scheduler primitives</A
></H2
><P
></P
><DL
><DT
>Scheduler lock</DT
><DD
><P
>This test measures the <TT
CLASS="FUNCTION"
><B
>cyg_scheduler_lock()</B
></TT
> call. </P
></DD
><DT
>Scheduler unlock [0 threads]</DT
><DD
><P
>This test measures the <TT
CLASS="FUNCTION"
><B
>cyg_scheduler_unlock()</B
></TT
> call.
There are no other threads in the system and the unlock happens
immediately after a lock so there will be no pending DSR&#8217;s
to run. </P
></DD
><DT
>Scheduler unlock [1 suspended thread]</DT
><DD
><P
>This test measures the <TT
CLASS="FUNCTION"
><B
>cyg_scheduler_unlock()</B
></TT
> call.
There is one other thread in the system which is currently suspended. </P
></DD
><DT
>Scheduler unlock [many suspended threads]</DT
><DD
><P
>This test measures the <TT
CLASS="FUNCTION"
><B
>cyg_scheduler_unlock()</B
></TT
> call.
There are many other threads in the system which are currently suspended.
The purpose of this test is to determine the cost of having additional
threads in the system when the scheduler is activated by way of <TT
CLASS="FUNCTION"
><B
>cyg_scheduler_unlock()</B
></TT
>. </P
></DD
><DT
>Scheduler unlock [many low priority
threads]</DT
><DD
><P
>This test measures the <TT
CLASS="FUNCTION"
><B
><TT
CLASS="FUNCTION"
><B
>cyg_scheduler_unlock()</B
></TT
></B
></TT
> call.
There are many other threads in the system which are runnable but
are lower priority than the main thread. The purpose of this test
is to determine the cost of having additional threads in the system
when the scheduler is activated by way of <TT
CLASS="FUNCTION"
><B
><TT
CLASS="FUNCTION"
><B
>cyg_scheduler_unlock()</B
></TT
></B
></TT
>.</P
></DD
></DL
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN2682"
>Mutex primitives</A
></H2
><P
></P
><DL
><DT
>Init mutex</DT
><DD
><P
>This test measures the <TT
CLASS="FUNCTION"
><B
>cyg_mutex_init()</B
></TT
> call.
A number of separate mutex variables are created. The purpose of
this test is to measure the cost of creating a new mutex and introducing
it to the system. </P
></DD
><DT
>Lock [unlocked] mutex</DT
><DD
><P
>This test measures the <TT
CLASS="FUNCTION"
><B
>cyg_mutex_lock()</B
></TT
> call.
The purpose of this test is to measure the cost of locking a mutex
which is currently unlocked. There are no other threads executing
in the system while this test runs. </P
></DD
><DT
>Unlock [locked] mutex</DT
><DD
><P
>This test measures the <TT
CLASS="FUNCTION"
><B
>cyg_mutex_unlock()</B
></TT
> call.
The purpose of this test is to measure the cost of unlocking a mutex
which is currently locked. There are no other threads executing
in the system while this test runs. </P
></DD
><DT
>Trylock [unlocked] mutex</DT
><DD
><P
>This test measures the <TT
CLASS="FUNCTION"
><B
>cyg_mutex_trylock()</B
></TT
> call.
The purpose of this test is to measure the cost of locking a mutex
which is currently unlocked. There are no other threads executing
in the system while this test runs. </P
></DD
><DT
>Trylock [locked] mutex</DT
><DD
><P
>This test measures the <TT
CLASS="FUNCTION"
><B
>cyg_mutex_trylock()</B
></TT
> call.
The purpose of this test is to measure the cost of locking a mutex
which is currently locked. There are no other threads executing
in the system while this test runs. </P
></DD
><DT
>Destroy mutex</DT
><DD
><P
>This test measures the <TT
CLASS="FUNCTION"
><B
>cyg_mutex_destroy()</B
></TT
> call.
The purpose of this test is to measure the cost of deleting a mutex
from the system. There are no other threads executing in the system
while this test runs. </P
></DD
><DT
>Unlock/Lock mutex</DT
><DD
><P
>This test attempts to measure the cost of unlocking
a mutex for which there is another higher priority thread waiting.
When the mutex is unlocked, the higher priority waiting thread will
immediately take the lock. The time from when the unlock is issued
until after the lock succeeds in the second thread is measured, thus
giving the round-trip or circuit time for this type of synchronizer. </P
></DD
></DL
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN2722"
>Mailbox primitives</A
></H2
><P
></P
><DL
><DT
>Create mbox</DT
><DD
><P
>This test measures the <TT
CLASS="FUNCTION"
><B
>cyg_mbox_create()</B
></TT
> call.
A number of separate mailboxes is created. The purpose of this test
is to measure the cost of creating a new mailbox and introducing
it to the system. </P
></DD
><DT
>Peek [empty] mbox</DT
><DD
><P
>This test measures the <TT
CLASS="FUNCTION"
><B
>cyg_mbox_peek()</B
></TT
> call.
An attempt is made to peek the value in each mailbox, which is currently
empty. The purpose of this test is to measure the cost of checking
a mailbox for a value without blocking. </P
></DD
><DT
>Put [first] mbox</DT
><DD
><P
>This test measures the <TT
CLASS="FUNCTION"
><B
>cyg_mbox_put()</B
></TT
> call.
One item is added to a currently empty mailbox. The purpose of this
test is to measure the cost of adding an item to a mailbox. There
are no other threads currently waiting for mailbox items to arrive. </P
></DD
><DT
>Peek [1 msg] mbox</DT
><DD
><P
>This test measures the <TT
CLASS="FUNCTION"
><B
>cyg_mbox_peek()</B
></TT
> call.
An attempt is made to peek the value in each mailbox, which contains
a single item. The purpose of this test is to measure the cost of
checking a mailbox which has data to deliver. </P
></DD
><DT
>Put [second] mbox</DT
><DD
><P
>This test measures the <TT
CLASS="FUNCTION"
><B
>cyg_mbox_put()</B
></TT
> call.
A second item is added to a mailbox. The purpose of this test is
to measure the cost of adding an additional item to a mailbox. There
are no other threads currently waiting for mailbox items to arrive. </P
></DD
><DT
>Peek [2 msgs] mbox</DT
><DD
><P
>This test measures the <TT
CLASS="FUNCTION"
><B
>cyg_mbox_peek()</B
></TT
> call.
An attempt is made to peek the value in each mailbox, which contains
two items. The purpose of this test is to measure the cost of checking
a mailbox which has data to deliver. </P
></DD
><DT
>Get [first] mbox</DT
><DD
><P
>This test measures the <TT
CLASS="FUNCTION"
><B
>cyg_mbox_get()</B
></TT
> call.
The first item is removed from a mailbox that currently contains
two items. The purpose of this test is to measure the cost of obtaining
an item from a mailbox without blocking. </P
></DD
><DT
>Get [second] mbox</DT
><DD
><P
>This test measures the <TT
CLASS="FUNCTION"
><B
>cyg_mbox_get()</B
></TT
> call.
The last item is removed from a mailbox that currently contains
one item. The purpose of this test is to measure the cost of obtaining
an item from a mailbox without blocking. </P
></DD
><DT
>Tryput [first] mbox</DT
><DD
><P
>This test measures the <TT
CLASS="FUNCTION"
><B
>cyg_mbox_tryput()</B
></TT
> call.
A single item is added to a currently empty mailbox. The purpose
of this test is to measure the cost of adding an item to a mailbox. </P
></DD
><DT
>Peek item [non-empty] mbox</DT
><DD
><P
>This test measures the <TT
CLASS="FUNCTION"
><B
>cyg_mbox_peek_item()</B
></TT
> call.
A single item is fetched from a mailbox that contains a single item.
The purpose of this test is to measure the cost of obtaining an
item without disturbing the mailbox. </P
></DD
><DT
>Tryget [non-empty] mbox</DT
><DD
><P
>This test measures the <TT
CLASS="FUNCTION"
><B
>cyg_mbox_tryget()</B
></TT
> call.
A single item is removed from a mailbox that contains exactly one
item. The purpose of this test is to measure the cost of obtaining
one item from a non-empty mailbox. </P
></DD
><DT
>Peek item [empty] mbox</DT
><DD
><P
>This test measures the <TT
CLASS="FUNCTION"
><B
>cyg_mbox_peek_item()</B
></TT
> call.
An attempt is made to fetch an item from a mailbox that is empty.
The purpose of this test is to measure the cost of trying to obtain
an item when the mailbox is empty. </P
></DD
><DT
>Tryget [empty] mbox</DT
><DD
><P
>This test measures the <TT
CLASS="FUNCTION"
><B
>cyg_mbox_tryget()</B
></TT
> call.
An attempt is made to fetch an item from a mailbox that is empty.
The purpose of this test is to measure the cost of trying to obtain
an item when the mailbox is empty. </P
></DD
><DT
>Waiting to get mbox</DT
><DD
><P
>This test measures the <TT
CLASS="FUNCTION"
><B
>cyg_mbox_waiting_to_get()</B
></TT
> call.
The purpose of this test is to measure the cost of determining how
many threads are waiting to obtain a message from this mailbox. </P
></DD
><DT
>Waiting to put mbox</DT
><DD
><P
>This test measures the <TT
CLASS="FUNCTION"
><B
>cyg_mbox_waiting_to_put()</B
></TT
> call.
The purpose of this test is to measure the cost of determining how
many threads are waiting to put a message into this mailbox. </P
></DD
><DT
>Delete mbox</DT
><DD
><P
>This test measures the <TT
CLASS="FUNCTION"
><B
>cyg_mbox_delete()</B
></TT
> call.
The purpose of this test is to measure the cost of destroying a
mailbox and removing it from the system. </P
></DD
><DT
>Put/Get mbox</DT
><DD
><P
>In this round-trip test, one thread is sending data
to a mailbox that is being consumed by another thread. The time
from when the data is put into the mailbox until it has been delivered
to the waiting thread is measured. Note that this time will contain
a thread switch. </P
></DD
></DL
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN2812"
>Semaphore primitives</A
></H2
><P
></P
><DL
><DT
>Init semaphore</DT
><DD
><P
>This test measures the <TT
CLASS="FUNCTION"
><B
>cyg_semaphore_init()</B
></TT
> call.
A number of separate semaphore objects are created and introduced
to the system. The purpose of this test is to measure the cost of
creating a new semaphore. </P
></DD
><DT
>Post [0] semaphore</DT
><DD
><P
>This test measures the <TT
CLASS="FUNCTION"
><B
>cyg_semaphore_post()</B
></TT
> call.
Each semaphore currently has a value of 0 and there are no other
threads in the system. The purpose of this test is to measure the
overhead cost of posting to a semaphore. This cost will differ if
there is a thread waiting for the semaphore. </P
></DD
><DT
>Wait [1] semaphore</DT
><DD
><P
>This test measures the <TT
CLASS="FUNCTION"
><B
>cyg_semaphore_wait()</B
></TT
> call.
The semaphore has a current value of 1 so the call is non-blocking.
The purpose of the test is to measure the overhead of &#8220;taking&#8221; a
semaphore. </P
></DD
><DT
>Trywait [0] semaphore</DT
><DD
><P
>This test measures the <TT
CLASS="FUNCTION"
><B
>cyg_semaphore_trywait()</B
></TT
> call.
The semaphore has a value of 0 when the call is made. The purpose
of this test is to measure the cost of seeing if a semaphore can
be &#8220;taken&#8221; without blocking. In this case, the
answer would be no. </P
></DD
><DT
>Trywait [1] semaphore</DT
><DD
><P
>This test measures the <TT
CLASS="FUNCTION"
><B
>cyg_semaphore_trywait()</B
></TT
> call.
The semaphore has a value of 1 when the call is made. The purpose
of this test is to measure the cost of seeing if a semaphore can
be &#8220;taken&#8221; without blocking. In this case, the
answer would be yes. </P
></DD
><DT
>Peek semaphore</DT
><DD
><P
>This test measures the <TT
CLASS="FUNCTION"
><B
>cyg_semaphore_peek()</B
></TT
> call.
The purpose of this test is to measure the cost of obtaining the
current semaphore count value. </P
></DD
><DT
>Destroy semaphore</DT
><DD
><P
>This test measures the <TT
CLASS="FUNCTION"
><B
>cyg_semaphore_destroy()</B
></TT
> call.
The purpose of this test is to measure the cost of deleting a semaphore
from the system. </P
></DD
><DT
>Post/Wait semaphore</DT
><DD
><P
>In this round-trip test, two threads are passing
control back and forth by using a semaphore. The time from when
one thread calls <TT
CLASS="FUNCTION"
><B
>cyg_semaphore_post()</B
></TT
> until
the other thread completes its <TT
CLASS="FUNCTION"
><B
>cyg_semaphore_wait()</B
></TT
> is
measured. Note that each iteration of this test will involve a thread
switch. </P
></DD
></DL
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN2859"
>Counters</A
></H2
><P
></P
><DL
><DT
>Create counter</DT
><DD
><P
>This test measures the <TT
CLASS="FUNCTION"
><B
>cyg_counter_create()</B
></TT
> call.
A number of separate counters are created. The purpose of this test
is to measure the cost of creating a new counter and introducing
it to the system. </P
></DD
><DT
>Get counter value</DT
><DD
><P
>This test measures the <TT
CLASS="FUNCTION"
><B
>cyg_counter_current_value()</B
></TT
> call.
The current value of each counter is obtained. </P
></DD
><DT
>Set counter value</DT
><DD
><P
>This test measures the <TT
CLASS="FUNCTION"
><B
>cyg_counter_set_value()</B
></TT
> call.
Each counter is set to a new value. </P
></DD
><DT
>Tick counter</DT
><DD
><P
>This test measures the <TT
CLASS="FUNCTION"
><B
>cyg_counter_tick()</B
></TT
> call.
Each counter is &#8220;ticked&#8221; once. </P
></DD
><DT
>Delete counter</DT
><DD
><P
>This test measures the <TT
CLASS="FUNCTION"
><B
>cyg_counter_delete()</B
></TT
> call.
Each counter is deleted from the system. The purpose of this test
is to measure the cost of deleting a counter object.</P
></DD
></DL
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN2890"
>Alarms</A
></H2
><P
></P
><DL
><DT
>Create alarm</DT
><DD
><P
>This test measures the <TT
CLASS="FUNCTION"
><B
>cyg_alarm_create()</B
></TT
> call.
A number of separate alarms are created, all attached to the same
counter object. The purpose of this test is to measure the cost
of creating a new counter and introducing it to the system. </P
></DD
><DT
>Initialize alarm</DT
><DD
><P
>This test measures the <TT
CLASS="FUNCTION"
><B
>cyg_alarm_initialize()</B
></TT
> call.
Each alarm is initialized to a small value. </P
></DD
><DT
>Disable alarm</DT
><DD
><P
>This test measures the <TT
CLASS="FUNCTION"
><B
>cyg_alarm_disable()</B
></TT
> call.
Each alarm is explicitly disabled. </P
></DD
><DT
>Enable alarm</DT
><DD
><P
>This test measures the <TT
CLASS="FUNCTION"
><B
>cyg_alarm_enable()</B
></TT
> call.
Each alarm is explicitly enabled. </P
></DD
><DT
>Delete alarm</DT
><DD
><P
>This test measures the <TT
CLASS="FUNCTION"
><B
>cyg_alarm_delete()</B
></TT
> call.
Each alarm is destroyed. The purpose of this test is to measure
the cost of deleting an alarm and removing it from the system. </P
></DD
><DT
>Tick counter [1 alarm]</DT
><DD
><P
>This test measures the <TT
CLASS="FUNCTION"
><B
>cyg_counter_tick()</B
></TT
> call.
A counter is created that has a single alarm attached to it. The
purpose of this test is to measure the cost of &#8220;ticking&#8221; a
counter when it has a single attached alarm. In this test, the alarm
is not activated (fired). </P
></DD
><DT
>Tick counter [many alarms]</DT
><DD
><P
>This test measures the <TT
CLASS="FUNCTION"
><B
>cyg_counter_tick()</B
></TT
> call.
A counter is created that has multiple alarms attached to it. The
purpose of this test is to measure the cost of &#8220;ticking&#8221; a
counter when it has many attached alarms. In this test, the alarms
are not activated (fired). </P
></DD
><DT
>Tick &#38; fire counter [1 alarm]</DT
><DD
><P
>This test measures the <TT
CLASS="FUNCTION"
><B
>cyg_counter_tick()</B
></TT
> call.
A counter is created that has a single alarm attached to it. The
purpose of this test is to measure the cost of &#8220;ticking&#8221; a
counter when it has a single attached alarm. In this test, the alarm
is activated (fired). Thus the measured time will include the overhead
of calling the alarm callback function. </P
></DD
><DT
>Tick &#38; fire counter [many
alarms]</DT
><DD
><P
>This test measures the <TT
CLASS="FUNCTION"
><B
>cyg_counter_tick()</B
></TT
> call.
A counter is created that has multiple alarms attached to it. The
purpose of this test is to measure the cost of &#8220;ticking&#8221; a
counter when it has many attached alarms. In this test, the alarms
are activated (fired). Thus the measured time will include the overhead
of calling the alarm callback function. </P
></DD
><DT
>Alarm latency [0 threads]</DT
><DD
><P
>This test attempts to measure the latency in calling
an alarm callback function. The time from the clock interrupt until
the alarm function is called is measured. In this test, there are
no threads that can be run, other than the system idle thread, when
the clock interrupt occurs (all threads are suspended). </P
></DD
><DT
>Alarm latency [2 threads]</DT
><DD
><P
>This test attempts to measure the latency in calling
an alarm callback function. The time from the clock interrupt until
the alarm function is called is measured. In this test, there are
exactly two threads which are running when the clock interrupt occurs.
They are simply passing back and forth by way of the <TT
CLASS="FUNCTION"
><B
>cyg_thread_yield()</B
></TT
> call.
The purpose of this test is to measure the variations in the latency
when there are executing threads. </P
></DD
><DT
>Alarm latency [many threads]</DT
><DD
><P
>This test attempts to measure the latency in calling
an alarm callback function. The time from the clock interrupt until
the alarm function is called is measured. In this test, there are
a number of threads which are running when the clock interrupt occurs.
They are simply passing back and forth by way of the <TT
CLASS="FUNCTION"
><B
>cyg_thread_yield()</B
></TT
> call.
The purpose of this test is to measure the variations in the latency
when there are many executing threads. </P
></DD
></DL
></DIV
></DIV
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="whats-missing.html"
>Prev</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="user-guides.html"
>Home</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="sample-numbers.html"
>Next</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>Influences on 
performance</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="real-time-characterization.html"
>Up</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>Sample numbers</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>