<HTML>
<HEAD>
<TITLE>Flash Driver</TITLE>
</HEAD>

<!--#include virtual="../../include/header.html"-->

<H2>Flash Driver</H2>
<HR SIZE=3>

<p>A flash device driver consists of two elements: a generic device
driver which knows how to handle a particular part or series of flash
devices, and a platform specific driver which contains information
about how the devices are laid out on the particular platform. This
allows the core device driver to be shared by multiple platforms which
have different device configurations.</p>

<p>The below descriptions are based on the <a
href="http://sources.redhat.com/cgi-bin/cvsweb.cgi/ecos/packages/devs/flash/amd/am29xxxxx/current/?cvsroot=ecos">AMD
AM29xxxxx</a> generic driver and the <a
href="http://sources.redhat.com/cgi-bin/cvsweb.cgi/ecos/packages/devs/flash/powerpc/mbx/current/?cvsroot=ecos">PowerPC
MBX</a> platform driver.</p>

<p>Other device drivers rely on the platform driver to provide a
header file with details which is included when the generic driver
object is built. But in the flash device drivers, the generic driver
is provided as an <tt>.inl</tt> header file which is included when the
driver object is built in the platform driver.</p>

<p>The reason for this is that the driver code needs macros to handle
different configuration instances of interleaved devices. Letting the
platform driver build the object allows the same generic driver to be
built for different interleaved configurations.</p>


<h3>General Issues</h3>

<dl>
<dt><p>Error values</p>

 <dd><p>Error values are defined in the IO flash driver. For the
        current list of errors, see the file <a
        href="http://sources.redhat.com/cgi-bin/cvsweb.cgi/~checkout~/ecos/packages/io/flash/current/include/flash.h?content-type=text/x-cvsweb-markup&cvsroot=ecos">flash.h</a>. Here's
        the list at the time of writing:</p>

 <pre>
#define FLASH_ERR_OK              0x00  // No error - operation complete
#define FLASH_ERR_INVALID         0x01  // Invalid FLASH address
#define FLASH_ERR_ERASE           0x02  // Error trying to erase
#define FLASH_ERR_LOCK            0x03  // Error trying to lock/unlock
#define FLASH_ERR_PROGRAM         0x04  // Error trying to program
#define FLASH_ERR_PROTOCOL        0x05  // Generic error
#define FLASH_ERR_PROTECT         0x06  // Device/region is write-protected
#define FLASH_ERR_NOT_INIT        0x07  // FLASH info not yet initialized
#define FLASH_ERR_HWR             0x08  // Hardware (configuration?) problem
#define FLASH_ERR_ERASE_SUSPEND   0x09  // Device is in erase suspend mode
#define FLASH_ERR_PROGRAM_SUSPEND 0x0a  // Device is in in program suspend mode
#define FLASH_ERR_DRV_VERIFY      0x0b  // Driver failed to verify data
#define FLASH_ERR_DRV_TIMEOUT     0x0c  // Driver timed out waiting for device
#define FLASH_ERR_DRV_WRONG_PART  0x0d  // Driver does not support device
#define FLASH_ERR_LOW_VOLTAGE     0x0e  // Not enough juice to complete job
 </pre>

  </dd>

<dt><p>Void pointers</p></dt>

 <dd><p>Different drivers will have different word widths, depending
 on device types and number of interleaved devices. Since the IO
 driver must be able to use them all, device addresses and data is
 passed as void pointersm, and counts denote bytes.</p></dd>

<dt><p>Flash interleaving</p></dt>

 <dd><p>Different platforms may use the same flash parts in different
 interleaved configurations, e.g., platform A has one 16-bit device,
 while platform B has two interleaved (parallel) devices to create one
 virtual 32-bit wide device. For this reason, all access to the device
 is done using the <tt>flash_data_t</tt> type which takes on the
 correct width, and all device commands are defined to the correct
 width using the macro <tt>FLASHWORD</tt>.</p><dd>

<dt><p>Flash mapping</p></dt>

 <dd><p>On some platforms the flash devices may not be linearly
 accessible. In order to let the driver work on such platforms, all
 addressing of the device should use the <tt>FLASH_P2V</tt> macro
 which does a physical address translation to a virtual address which
 works with the device on the particular platform.</p></dd>

<dt><p>Flash access</p></dt>

 <dd><p>All access operations which takes the flash device out of its
 normal random access data mode must be done from RAM. Therefore all
 such functions must be put in the special <tt>.2ram</tt> section
 which will get copied to RAM during system initialization.</p>

 <p>The first generation of drivers would instead rely on the IO
 driver to copy the functions to memory and execute them from
 there. But that method has various problems with caching and
 portability.</p></dd>

<dt><p>Caching during access</p></dt>

 <dd><p>Some architectures/platforms will access the flash area in
 burst mode, which spoils the flash interaction protocols. To counter
 this, the IO driver disables caches before calling the driver
 functions. This is done using the macro <tt>HAL_FLASH_CACHES_OFF</tt>
 and the matching <tt>HAL_FLASH_CACHES_ON</tt> for which there are
 shared definitions in the IO driver. Some architectures/platforms may
 have to override these macros though</p></tt>

</dl>

<H3>Generic Flash Driver</H3>

<p>The generic driver package must contain CDL in the following
style:</p>

<pre>
cdl_package CYGPKG_DEVS_FLASH_AMD_AM29XXXXX {
    display       "AMD AM29XXXXX FLASH memory support"
    description   "FLASH memory device support for AMD AM29XXXXX"
    parent        CYGPKG_IO_FLASH
    active_if	  CYGPKG_IO_FLASH

    active_if     CYGINT_DEVS_FLASH_AMD_AM29XXXXX_REQUIRED

    implements    CYGHWR_IO_FLASH_DEVICE

    include_dir   cyg/io
}
</pre>

<p>The package is only enabled if the IO flash driver is present and
<tt>CYGINT_DEVS_FLASH_AMD_AM29XXXXX_REQUIRED</tt> is defined in the
platform flash driver.  There are no files to build, since the driver
is provided in the form of an <tt>.inl</tt> header file.</p>


<p>The flash driver must provide the API described below. Note that this
API is likely to change some time in the future to allow multiple
flash drivers in the same system.</p>



<dl>
<dt><tt>int flash_hwr_init(void)</tt></dt>

 <dd><p>Ensures that the device is indeed a supported device by
 querying the manufacturer and/or type codes. Also initializes flash
 driver data with flash size, location, number of regions and region
 sizes.</p></dd>

<dt><tt>void flash_query(void* data)</tt></dt>

 <dd><p>Reads whatever codes from the flash device necessary to
 identify it. This is usually the manufacturer and part numbers which
 are written to <tt>data</tt>. This function is called via the IO
 driver, hence the need for a void pointer instead of type specific
 pointer.</p></dd>

<dt><tt>int flash_hwr_map_error(int err)</tt></dt>

 <dd><p>Translates a flash error code to an eCos flash error
 code. This is a null operation since th driver should always return
 eCos flash error codes anyway.</p></dd>

<dt><tt>bool flash_code_overlaps(void *start, void *end)</tt></dt>

 <dd><p>Determines if the specified flash range overlaps with any
 running code, thus allowing an abort of the operation. FIXME: This
 function should be removed from the device driver.</p></dd>

<dt><tt>int flash_erase_block(volatile void* block)</tt></dt>

 <dd><p>Erase the specified block. Returns an error code if the
 operation failed.</p></dd>

<dt><tt>int flash_program_buf(volatile void* addr, void* data, 
                              int len)</tt></dt>

 <dd><p> Program the flash starting at <tt>addr</tt> with the data
 pointed to by <tt>data</tt>. <tt>len</tt> specifies number of bytes
 to program. Returns an error code if the operation failed.</p></dd>

</dl>

<p>Some drivers may also include functionality to lock and unlock
areas of the flash device. In that case, the CDL must include a
<pre>implements CYGHWR_IO_FLASH_BLOCK_LOCKING</pre> statement. [FIXME:
These functions do not have a consistent interface yet -- or is there
a reason for one taking a single block and the other a range?]</p>

<dl>
<dt><tt>int flash_lock_block(volatile void* block)</tt></dt>

 <dd><p>Locks the block specified. Returns an error code if the
 operation failed.</p></d>

<dt><tt>int flash_unlock_block(volatile void* block,
                       int block_size, int blocks)</tt></dt>

 <dd><p>Unlocks specified range of blocks. Returns flash error code if
 operation failed.</p></dd>

</dl>


<H3>Platform Specific Driver</H3>

<p>The platform driver package must contain CDL in the following
style:</p>

<pre>
cdl_package CYGPKG_DEVS_FLASH_MBX {
    display       "Motorola PowerPC/860 FLASH memory support"

    parent        CYGPKG_IO_FLASH
    active_if	  CYGPKG_IO_FLASH
    requires	  CYGPKG_HAL_POWERPC_MBX

    implements    CYGHWR_IO_FLASH_DEVICE

    compile       powerpc_mbx_flash.c

    # Arguably this should do in the generic package
    # but then there is a logic loop so you can never enable it.
    cdl_interface CYGINT_DEVS_FLASH_AMD_AM29XXXXX_REQUIRED {
        display   "Generic AMD AM29F040 driver required"
    }

    implements    CYGINT_DEVS_FLASH_AMD_AM29XXXXX_REQUIRED
}
</pre>

<p>It enables the generic driver by providing the interface
option. The <tt>compile</tt> statement identifies the file which, when
built, includes the generic driver code.</p>

<p>The driver file itself is quite simple, as all it has to do is
specify device parameters and include the generic driver:</p>

<pre>
//--------------------------------------------------------------------------
// Device properties

// We use the single AM29F040B on the MBX board.
#define CYGPKG_DEVS_FLASH_AMD_AM29F040B
#define CYGNUM_FLASH_INTERLEAVE	(1)
#define CYGNUM_FLASH_SERIES	(1)
#define CYGNUM_FLASH_BASE 	(0xfe000000u)

//--------------------------------------------------------------------------
// Platform specific extras

//--------------------------------------------------------------------------
// Now include the driver code.
#include "cyg/io/flash_am29xxxxx.inl"
</pre>

<p>The definitions have the following meaning:</p>

<dl>

<dt><tt>CYGPKG_DEVS_FLASH_AMD_AM29F040B</tt></dt>

 <dd><p>The generic driver may contain support for multiple variants
 in the device family. This definition selects parameters specific for
 the AMD AM29F040B part.</p></dd>

<dt><tt>CYGNUM_FLASH_INTERLEAVE</tt></dt>

 <dd><p>Defines how many devices are interleaved (sits in parallel)
 for this region of flash. The <tt>flash_data_t</tt> supports various
 configurations up to a max width of 64 bits.</p></dd>

<dt><tt>CYGNUM_FLASH_SERIES</tt></dt>

 <dd><p>Defines how many number of devices are in series. The total
 number of devices is then defined as
 (<tt>CYGNUM_FLASH_INTERLEAVE</tt> x
 <tt>CYGNUM_FLASH_SERIES</tt>).</p></dd>

<dt><tt>CYGNUM_FLASH_BASE</tt></dt>

 <dd><p>Defines the address base of the flash region.</p></dd>

</dl>

<!--#include virtual="../../include/footer.html"-->
