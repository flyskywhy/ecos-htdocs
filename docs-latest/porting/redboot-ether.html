<HTML>
<HEAD>
<TITLE>RedBoot Ethernet Support</TITLE>
</HEAD>

<!--#include virtual="../../include/header.html"-->

<H2>RedBoot Ethernet Support</H2>
<HR SIZE=3>

<p>The ethernet drivers are standard eCos ethernet drivers - except
that they are only used in polled mode from RedBoot. This is done with
the help of a poll() driver call which will simulate interrupts, and
thus drive the state machine of the driver.</p>

<p>See [xref] for more details on writing an ethernet driver for
eCos.</p>


<pre>

_send & _recieve semantics - the sg list used to separate ethernet
frame header from IP frame.

Getting started: use NET package server_test and ping target to see
output. The other way can be tricky if there's no output, or if the
output gets ignored by the host. (enable CYGPKG_NET_BUILD_TESTS)

Disable CYGHWR_NET_DRIVER_ETH0_BOOTP and CYGPKG_NET_DHCP, set
CYGHWR_NET_DRIVER_ETH0_ADDRS and suitable values in
CYGHWR_NET_DRIVER_ETH0_ADDRS_IP,
CYGHWR_NET_DRIVER_ETH0_ADDRS_BROADCAST and
CYGHWR_NET_DRIVER_ETH0_ADDRS_GATEWAY. 


gotcha: frame padding, may need to be enabled specifically, and hosts
will (silently!) ignore small packets.

_poll function

generic & platform implementation

SNMP
~~~~

ecosconfig add CYGPKG_SNMPLIB CYGPKG_SNMPAGENT


Build and run snmp/agent/current/tests/snmpping

Whilst it's running, use snmpwalk to do SNMP to it.  There's a trivial hack
inside snmpping.c to have ut run forever.

   setenv TARGET3  10.16.19.76
   setenv MIBS all
   while ( { snmpstatus $TARGET3 public } )
     snmpwalk -OS $TARGET3  public
     date
   end


</pre>



<!--#include virtual="../../include/footer.html"-->
