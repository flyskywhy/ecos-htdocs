<HTML>
<HEAD>
<TITLE>HAL Coding Conventions</TITLE>
</HEAD>

<!--#include virtual="../../include/header.html"-->

<H2>HAL Coding Conventions</H2>
<HR SIZE=3>

<p>To get changes and larger submissions included into the eCos source
repository, we ask that you adhere to a set of coding conventions.
The conventions are defined as an attempt to make a consistent
tree. Consistency makes it easier for people to read, understand and
maintain the code, which is important when many people work on the
same project.</p>

<p>The below is only a brief, and probably incomplete, summary of the
rules. Please look through files in the area where you are making
changes to get a feel for any additional conventions. Also feel free
to ask on the list if you have specific questions.</p>

<h3>Implementation issues</h3>

There are a few implementation issues that should be kept in mind:

<dl>
<dt>HALs</dt>
	<dd>HALs must be written in C and assembly only. C++ must not
	be used. This is in part to keep the HALs simple since this is
	usually the first part of eCos a newcomer will see, and in
	part to maintain the existing de facto standard.</dd>

<dt>IO access</dt>
	<dd>Use HAL IO access macros for code that might be reused on
	different platforms than the one you are writing it for.</dd>

<dt>MMU</dt>
	<dd>If it is necessary to use the MMU (e.g., to prevent
	caching of IO areas), use a simple 1-1 mapping of memory if
	possible. On most platforms where using the MMU is necessary,
	it will be possible to achieve the 1-1 mapping using the MMU's
	provision for mapping large continous areas (hardwired TLBs or
	BATs). This reduces the footprint (no MMU table) and avoids
	execution overhead (no MMU-related exceptions).</dd>

<dt>Assertions</dt> 
        <dd>The code should contain assertions to validate argument
	values, state information and any assumptions the code may be
	making. Assertions are not enabled in production builds, so
	liberally sprinkling assertions throughout the code is
	good.</dd>

<dt>Testing</dt>
	<dd>The ability to test your code is very important. In
	general, do not add new code to the eCos runtime unless you
	also add a new test to excercise that code. The test also
	serves as an example of how to use the new code.</dd>

</dl>

<h3>Source code details</h3>

<dl>
<dt>Line length</dt> 
	<dd>Keep line length below 78 columns whenever possible.</dd>

<dt>Comments</dt>
	<dd>Whenever possible, use // comments instead of /**/.</dd>

<dt>Indention</dt>
	<dd>Use spaces instead of TABs. Indention level is 4. Braces
	start on the same line as the expression. See below for emacs
	mode details.</dd>

<pre>
;;=================================================================
;; eCos C/C++ mode Setup.
;;
;; bsd mode: indent = 4, &c &c
;; tail comments are at col 40.
;; uses spaces not tabs in C

(defun ecos-c-mode ()
  "C mode with adjusted defaults for use with the eCos sources."
  (interactive)
  (c++-mode)
  (c-set-style "bsd")
  (setq comment-column 40)
  (setq indent-tabs-mode nil)
  (show-paren-mode 1)
  (setq c-basic-offset 4)

  (set-variable 'add-log-full-name "Your Name")
  (set-variable 'add-log-mailing-address "Your email address"))

(defun ecos-asm-mode ()
  "ASM mode with adjusted defaults for use with the eCos sources."
  (interactive)
  (setq comment-column 40)
  (setq indent-tabs-mode nil)
  (asm-mode)
  (setq c-basic-offset 4)

  (set-variable 'add-log-full-name "Your Name")
  (set-variable 'add-log-mailing-address "Your email address"))

(setq auto-mode-alist
      (append '(("/local/ecc/.*\\.C$"   . ecos-c-mode)
                ("/local/ecc/.*\\.cc$"  . ecos-c-mode)
                ("/local/ecc/.*\\.cpp$" . ecos-c-mode)
                ("/local/ecc/.*\\.inl$" . ecos-c-mode)
                ("/local/ecc/.*\\.c$"   . ecos-c-mode)
                ("/local/ecc/.*\\.h$"   . ecos-c-mode)
		("/local/ecc/.*\\.S$"   . ecos-asm-mode) 
		("/local/ecc/.*\\.inc$" . ecos-asm-mode)
		("/local/ecc/.*\\.cdl$" . tcl-mode)
                ) auto-mode-alist))
</pre>
</dl>


<h3>Nested Headers</h3>

<p>In order to allow platforms to define all necessary details, while
still maintaining the ability to share code between common platforms,
all HAL headers are included in a nested fashion.</p>

<p>The architecture header (usually <tt>hal_XXX.h</tt>) includes the
variant equivalent of the header (<tt>var_XXX.h</tt>) which in turn
includes the platform equivalent of the header
(<tt>plf_XXX.h</tt>).</p>

<p>All definitions that may need to be overridden by a platform are
then only conditionally defined, depending on whether a lower layer
has already made the definition:</p>

<pre>
hal_intr.h:     #include &lt;var_intr.h&gt;

                #ifdef <b>MACRO</b>_DEFINED
                # define <b>MACRO</b> ...
                # define <b>MACRO</b>_DEFINED
                #endif



var_intr.h:     #include &lt;plf_intr.h&gt;

                #ifdef <b>MACRO</b>_DEFINED
                # define <b>MACRO</b> ...
                # define <b>MACRO</b>_DEFINED
                #endif


plf_intr.h:

                # define <b>MACRO</b> ...
                # define <b>MACRO</b>_DEFINED
</pre>

<p>This means a platform can opt to rely on the variant or
architecture implementation of a feature, or implement it itself.</p>

<!--#include virtual="../../include/footer.html"-->
