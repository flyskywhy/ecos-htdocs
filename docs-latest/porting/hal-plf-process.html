<HTML>
<HEAD>
<TITLE>HAL Platform Porting Process</TITLE>
</HEAD>

<!--#include virtual="../../include/header.html"-->

<H2>HAL Platform Porting Process</H2>
<HR SIZE=3>

<h4>Brief overview</h4>

<p>The easiest way to make a new platform HAL is simply to copy an
existing platform HAL of the same architecture and change all the
files to match the new platform. In case this is the first platform
for the architecture, a platform HAL from another architecture should
be used as a template.

<p>The first goal of a HAL port is the creation of a minimal GDB eCos
stub which can be put in flash or ROM on the board to provide simple
"load and go" functionality. This allows further HAL development to
happen using RAM startup configurations, which is desirable for the
simple reason that downloading an image which you need to test is
often many times faster than either updating a flash part, or indeed,
erasing and reprogramming an EPROM.

<p>There are two approaches to getting to this first goal:

<ol>
<li>The board is equipped with a ROM monitor which allows "load and
go" of ELF, binary or some other image type which can be created using
objcopy. This allows you to develop the "load and go" GDB stub by
downloading and running the code (saving time).  

<p>When the stub is running it is a good idea to examine the various
hardware registers to help you write the platform initialization code.

<p>Then you may have to fiddle a bit going through step two (getting
it to run from ROM startup). If at all possible, preserve the original
ROM monitor so you can revert to it if necessary.

<p><li>The board has no ROM monitor (or you have the stub working for
RAM startup). You need to get the platform initialization and stub
working by repeatedly making changes, updating flash or EPROM and
testing the changes. If you are lucky, you have a JTAG or similar CPU
debugger to help you. If not, you will probably learn to appreciate
LEDs.

</ol>

<h4>Step-by-step</h4>

<p>Given that no two platforms are exactly the same, you may have to
deviate from the below. Also, you should expect a fair amount of
fiddling - things almost never go right the first time. See the hints
section below for some suggestions that might help debugging.

<p>The below descriptions are based on the HAL layout used in the MIPS
and MN10300 HALs. Eventually all HALs should be converted to look like
these - but in a transition period there will be other HALs which look
substantially different. Please try to adhere to the below as much is
possible without causing yourself too much grief integrating with a
HAL which does not follow this layout. [FIXME: ref layout]

<h5>Minimal requirements</h5>

These are the changes you must make before you attempt to build the
eCos GDB stub. You are advised to read all the sources though.

<ol>
<li><p>Copy an existing platform HAL from the same or another
    architecture. Rename the files as necessary to follow the
    standard: CDL and MLT related files should contain the
    &lt;arch&gt;_&lt;variant&gt;_&lt;platform&gt; tripplet.</p>

<li><p>Adjust CDL options. Primarily option naming, real-time
    clock/counter, and CYGHWR_MEMORY_LAYOUT variables, but also other
    options may need editing. Look through the architecture/variant
    CDL files to see if there are any requirements/features which
    where not used on the platform you copied. If so, add appropriate
    ones.</p>

<li><p>Add the necessary packages and target descriptions to the
    top-level ecos.db file.</p>

<li><p>Adjust the MLT files in include/pkgconf to match the memory layout
    on the platform. For initial testing it should be enough to just
    hand edit .h and .ldi files, but eventually you should generate
    all files using the memory layout editor in the configuration
    tool.</p>

<li><p>If the default IO macros are not correct, override them in
    plf_io.h. This may be necessary if the platform uses a different
    endianess from what is default for the CPU.</p>

<li><p>Leave out/comment out code that enables caches and/or MMU if
    possible. Execution speed will not be a concern until the port is
    feature complete.</p>

<li><p>Implement a simple serial driver (polled mode only). Make sure the
    initialization function properly hooks the procedures up in the
    virtual vector IO channel tables. The stub will call the serial
    driver via these tables.</p>

<li><p>Adjust/implement necessary platform initialization. This can be
    found in platform.inc and platform.S files (ARM:
    hal_platform_setup.h and &lt;platform&gt;_misc.c, PowerPC:
    &lt;platform&gt;.S, FIXME). This step can be postponed if you are
    doing RAM startup stubs first and the existing ROM monitor handles
    board initialization.</p>

<li><p>Define HAL_STUB_PLATFORM_RESET (optionally empty) and
    HAL_STUB_PLATFORM_RESET_ENTRY so the minimal stub can
    reset-on-detach - this is very handy, often removing the need for
    physically resetting the board between downloads.</p>

</ol>

<p>You should now be able to build some simple stubs. For ROM startup:

<pre>
% ecosconfig new &lt;target_name&gt; stubs
% ecosconfig remove CYGPKG_IO
% ecosconfig remove CYGPKG_IO_SERIAL
% ecosconfig remove CYGPKG_ERROR
[possibly remove other driver packages which are not needed by the stub]
</pre>

<p>Now edit ecos.ecc, disabling CYGDBG_HAL_DEBUG_GDB_CTRLC_SUPPORT,
CYGDBG_HAL_DEBUG_GDB_BREAK_SUPPORT, and
CYGDBG_HAL_DEBUG_GDB_THREAD_SUPPORT.

<p>For RAM startup, also change the CYG_HAL_STARTUP option to RAM.

<pre>
% ecosconfig tree
% make
</pre>

<p>You may have to make further changes than suggested above to get
the make command to succeed. But when it does, you should find a stub
image in install/bin. To program this image into flash or EPROM, you
may need to convert to some other file type, and possibly adjust the
start address. When you have the correct objcopy command to do this,
add it to the CYGBLD_BUILD_GDB_STUBS custom build rule in the platform
CDL file.

<p>Having updated the flash/EPROM on the board, you should see output
on the serial port looking like the below when powering on the board:

<pre>
$T0540:fff05cd8;01:00004664;#92
</pre>

<p>If you do not see this output, you need to go through all your
changes and figure out what's wrong. If there's a user programmable
LED on the board it may help you figure out how far the stub gets
before it hangs. Unfortunately there's no good way to describe what to
do in this situation - other than that you have to play with the code
and the board.


<h5>Adding features</h5>

<p>Now you should have a simple "load and go" eCos GDB stub running on
the board. This means you have a the correct board initialization and
a working serial driver. It's time to flesh out the remaining stub and
HAL features.

<ol>
<li>Stub reset. As mentioned above it is desirable to get the board to
reset when GDB disconnects. When GDB disconnects it sends the stub a
kill-packet, and the stub first calls HAL_STUB_PLATFORM_RESET,
attempting to perform a software-invoked reset. Most embedded
CPUs/boards have a watchdog which is capable of triggering a reset.
If your target does not have a watchdog, leave
HAL_STUB_PLATFORM_RESET empty and rely on the fallback approach.

<p>If HAL_STUB_PLATFORM_RESET did not cause a reset, the stub will
jump to HAL_STUB_PLATFORM_RESET_ENTRY - this should be the address
where the CPU will start execution after a reset. Re-initializing the
board and drivers will <em>usually</em> be good enough to make a
hardware reset unnecessary.

<p>After the reset caused by the kill-packet, the target will be ready
for GDB to connect again. During a days work, this will save you from
pressing the reset button many times.

<p>Note that it is possible to disconnect from the board without
causing it to reset by using the GDB command 'detach'.</p>


<li>Single-stepping is necessary for both instruction-level debugging
and for breakpoint support. Single-stepping support should already be
in place as part of the architecture/variant HAL, but you want to give
it a quick test since you will come to rely on it.</p>

<li>Real-time clock interrupts drive the eCos scheduler clock. Many
embedded CPUs have an on-core timer (e.g. SH) or decrementer
(e.g. MIPS, PPC) that can be used, and in this case it will already be
supported by the architecture/variant HAL. You only have to calculate
and enter the proper CYGNUM_HAL_RTC_CONSTANTS definitions in the
platform CDL file.

<p>On some targets it may be necessary to use a platform-specific
timer source for driving the real-time clock. In this case you also
have to enter the proper CDL definitions, but must also define
suitable versions of the HAL_CLOCK_xx macros.</p>

<li>Interrupt decoding usually differs between platforms because the
amount and type of devices on the board differ. In plf_intr.h you must
either extend or replace the vector definitions otherwise provided by
the architecture or variant interrupt headers. You may also have to
define HAL_INTERRUPT_xxx control macros.</p>

<li>Caching may also differ from architecture/variant definitions.
Maybe just the sizes, but it can also be bigger differences for
example if the platform supports 2nd level caches.

<p>When cache definitions are in place, enable the caches on
startup. First verify that the system is stable for RAM startups, then
build a new stub and install it. This will test if caching, and in
particular the cache sync/flush operations, also work for ROM startup.</p>

<li>Asynchronous breakpoints [FIXME:TBD]</p>

</ol>

<p>You should now have a completed platform HAL port. Verify its
stability and completeness by running all the eCos tests and fix any
problems that show up (you have a working stub now, remember?! That
means you can debug the code to see why it fails).

<p>Given the many configuration options in eCos, there may be hidden
bugs or missing features which do not show up even if you run all the
tests succesfully with a default configuration. A comprehensive test
of the entire system will take many configuration permutations and
many many thousands of tests executed. [FIXME: ref something about
testing?!?]



<h4>Hints</h4>
<ul>

<li>JTAG or similar CPU debugging hardware can greatly reduce the time
    it takes to write a HAL port since you always have full visibility
    of what the CPU is doing.</p>

<li>LEDs can be your friends if you don't have a JTAG
    device. Especially in the start of the porting effort if you don't
    already have a working ROM monitor on the target. Then you have to
    get a basic stub working while basically being blindfolded. The
    LED can make it little easier, as you'll be able to do limited
    tracking of program flow and behavior by switching the LED on and
    off. If the board has multiple LEDs you can show a number (using
    binary notation with the LEDs) ans sprinkle code which sets
    different numbers throughout the code.</p>

<li>Debugging the interrupt processing is possible if you are careful
    with the way you program the very early interrupt entry
    handling. Write it so that as soon as possible in the interrupt
    path, taking a trap (exception) does no harm execution. See the SH
    vectors.S code for an example. Look for
    cyg_hal_default_interrupt_vsr and the label
    cyg_hal_default_interrupt_vsr_bp_safe, which marks the point after
    which traps/single-stepping is safe.

    <p>Being able to display memory content, CPU registers,
    interrupt controller details at the time of an interrupt can save
    a lot of time.</p>

<li>Using assertions is a good idea. They can sometimes reveal subtle
    bugs or missing features long before you would otherwise have
    found them, let alone notice them.

    <p>The default eCos configuration does not use assertions, so you
    have to enable them by switching on the option CYGDBG_USE_ASSERTS
    in the infra package.</p>

<li>The idle loop can be used to help debug the system.

    <p>Triggering clock from the idle loop is a neat trick for
    examining system behavior either before interrupts are fully
    working, or to speed up "the clock".

    <p>Use the idle loop to monitor and/or print out variables or
    hardware registers.</p>

<li>hal_mk_defs is used in some of the HALs (ARM, SH) as a way to
generate assembler symbol definitions from C header files without
imposing an assembler/C syntax separation in the C header files.</p>

<li>Tracing using buffers [FIXME:TBD]
</ul>

<!--#include virtual="../../include/footer.html"-->
