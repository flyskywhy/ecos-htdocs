<HTML>
<HEAD>
<TITLE>eCos Exceptions</TITLE>
</HEAD>

<!--#include virtual="../../include/header.html"-->

<H2>eCos Exceptions</H2>
<HR SIZE=3>

<p>In eCos, exceptions are the class of <em>synchronous</em> CPU
events - that is, any event that is caused by the instruction
currently being executed.<p>

<p>On exception, the CPU will normally jump to a predefined exception
handler entry point. At this place, the HAL will have a small piece of
code which does minimal decoding of the event causing the exception -
just enough to find a pointer to the exception vector service routine
(VSR) in the hal_vsr_table and jump to it without messing up any of
the user state registers.</p>

<p>The exception VSR (written in assembly) stores the user state
registers on the stack and makes it safe to call C - then calls the C
function cyg_hal_exception_handler. Depending on the configuration,
cyg_hal_exception_handler feeds the exception to the GDB stub or to
the eCos kernel.</p>

<p>Eventually cyg_hal_exception_handler returns, registers are
restored and user level execution is resumed. Any policy decisions and
actions necessary to ensure that the execption will not trigger again
are left to the GDB stub / eCos kernel (ultimately the application).</p>

<p>[TBD: add figure of sorts showing flow]</p>


<!--#include virtual="../../include/footer.html"-->
