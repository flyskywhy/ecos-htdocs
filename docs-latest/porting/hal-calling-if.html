<HTML>
<HEAD>
<TITLE>eCos/ROM Monitor Calling Interface</TITLE>
</HEAD>

<!--#include virtual="../../include/header.html"-->

<H2>eCos/ROM Monitor Calling Interface</H2>
<HR SIZE=3>

<p>Some eCos platforms have supported full debugging capabilities via
CygMon since day one. Platforms of the architectures PowerPC, ARM, and
SH do not provide those features unless a GDB stub is included in the
application.

<p>This is going to change. All platforms will (eventually) support
all the debugging features by relying on a ROM/RAM calling interface
(also referred to as virtual vector table) provided by the ROM
monitor. This calling interface is based on the tables used by libbsp
and is thus backwards compatible with the existing CygMon supported
platforms.

<h3>The calling interface API</h3>

<p>The calling interface API is defined by hal_if.h and hal_if.c in
hal/common.

<p>The API provides a set of services. Different platforms, or
different versions of the ROM monitor for a single platform, may
implement fewer or extra service. The table has room for growth, and
any entries which are not supported map to a NOP-service (when called
it returns 0 (false)).

<p>A client of a service should either be selected by configuration,
or have suitable fall back alternatives in case the feature is not
implemented by the ROM monitor.

<p><b>Note:</b>
Checking for unimplemented service when this may be a data
field/pointer instead of a function: suggest reserving the last entry
in the table as the NOP-service pointer. Then clients can compare a
service entry with this pointer to determine whether it's initialized
or not.

<p>hal_if.h: defines the table layout and accessor macros (allowing
 primitive type checking and alternative implementations should it
 become necessary).

<p>hal_if.c: defines the table initialization function (which all HALs
 should call during platform initialization - the table will get
 initialized according to configuration).
 Here is also defined wrapper functions which map between the calling
 interface API and the API of the used eCos functions.


<h4>Implemented Services</h4>

<p>This is a brief description of the services, some of which are
described in further detail below.</p>

<dl>
<dt><tt>VERSION</tt>
        <dd>Version of table. Serves as a way to check for how many
        features are available in the table. This is the index of the
        last service in the table.</dd>
<dt><tt>ICTRL_TABLE</tt>
        <dd>[Unused, possibly delete]</dd>
<dt><tt>EXC_TABLE</tt>
        <dd>[Unused, possibly delete]</dd>
<dt><tt>DBG_VECTOR</tt>
        <dd>ROM monitor entry point. Not supported at the moment.</dd>
<dt><tt>KILL_VECTOR</tt>
        <dd>[Presently unused by the stub code, but initialized] This
        vector defines a function to execute when the system receives
        a kill signal from the debugger. It is initialized with the
        reset function (see below), but the application (or eCos) can
        override it if necessary.</dd>
<dt><tt>CONSOLE_PROCS</tt>
        <dd>The communication procedure table used for console IO
        (see <a href="#io_channels">IO channels</a>).</dd>
<dt><tt>DEBUG_PROCS</tt>
        <dd>The communication procedure table used for debugger IO
        (see <a href="#io_channels">IO channels</a>).</dd>
<dt><tt>FLUSH_DCACHE</tt>
        <dd>Flushes the data cache for the specified
        region. Some implementations may flush the entire data cache.</dd>
<dt><tt>FLUSH_ICACHE</tt>
        <dd>Flushes (invalidates) the instruction cache
        for the specified region. Some implementations may flush the
        entire instruction cache.</dd>
<dt><tt>CPU_DATA</tt>
        <dd>[Presently unused] Architecture HAL may use this as a
        pointer to architecture specific data.</dd>
<dt><tt>BOARD_DATA</tt>
        <dd>[Presently unused] Platform HAL may use this as a
        pointer to platform specific data.</dd>
<dt><tt>SYSINFO</tt>
        <dd>[Presently unused] Could be used to return information
        about available memory, caches sizes, etc.</dd>
<dt><tt>SET_DEBUG_COMM</tt>
        <dd>Change debugging communication channel.</dd>
<dt><tt>SET_CONSOLE_COMM</tt>
        <dd>Change console communication channel.</dd>
<dt><tt>SET_SERIAL_BAUD</tt>
        <dd>[Unused, possibly delete. Feature available in comm table
        anyway]</dd>
<dt><tt>DBG_SYSCALL</tt>
        <dd>Vector used to communication between debugger functions in
        ROM and in RAM. RAM eCos configurations may install a function
        pointer here which the ROM monitor uses to get thread
        information from the kernel running in RAM.</dd>
<dt><tt>RESET</tt>
        <dd>Resets the board on call. If it is not possible to reset
        the board from software, it will jump to the ROM entry point
        which will perform a "software" reset of the board.</dd>
<dt><tt>CONSOLE_INTERRUPT_FLAG</tt>
        <dd>Set if a debugger interrupt request was detected while
        processing console IO. Allows the actual breakpoint action to
        be handled after return to RAM, ensuring proper backtraces
        etc.</dd>
<dt><tt>DELAY_US</tt>
        <dd>Will delay the specified number of microseconds. The
        precision is platform dependent to some extend - a small value
        (<100us) is likely to cause bigger delays than requested.</dd>
<dt><tt>INSTALL_BPT_FN</tt>
        <dd>Installs a breakpoint at the specified address. This is
        used by the asynchronous breakpoint support (see <a
        href="hal-stubs.html#async_bps">Asynchronous GDB
        breakpoints</a>).</dd>
</dl>

<h4>Compatibility</h4>

<p>When a platform is changed to support the calling interface,
applications will use it if so configured. That means that if an
application is run on a platform with an older ROM monitor, the
service is almost guaranteed to fail.

<p>For this reason, applications should only use Console Comm for HAL
diagnostics output if explicitly configured to do so
(CYGSEM_HAL_VIRTUAL_VECTOR_DIAG).

<p>As for asynchronous GDB interrupts, the service will always be
used. This is likely to cause a crash under older ROM monitors, but
this crash may be caught by the debugger. The old workaround still
applies: if you need asynchronous breakpoints or thread debugging
under older ROM monitors, you may have to include the debugging
support when configuring eCos.

<h4>Implementation details</h4>

<p>During the startup of a ROM monitor, the calling table will be
initialized. This also happens if eCos is configured <em>not</em> to rely on
a ROM monitor.

<p><b>Note:</b> There is reserved space (256 bytes) for the vector
table whether it gets used or not. This may be something that we want
to change if we ever have to shave off every last byte for a given
target.

<p>If thread debugging features are enabled, the function for accessing
the thread information gets registered in the table during startup of
a RAM startup configuration.

<p>Further implementation details are described where the service itself
is described.</p>

<pre>
FIXME: Need to describe the CYGARC_HAL_SAVE_GP() and
CYGARC_HAL_RESTORE_GP() macros.
</pre>


<h4>New platform ports</h4>

<p>The hal_platform_init() function must call hal_if_init().

<p>The HAL serial driver must, when called via cyg_hal_plf_comms_init
initialize the communication channels.

<p>The reset() function defined in hal_if.c will attempt to do a hardware
reset, but if this fails it will fall back to simply jumping to the
reset entry-point. On most platforms the startup initialization will
go a long way to reset the target to a sane state (there will be
exceptions, of course). For this reason, make sure to define
HAL_STUB_PLATFORM_RESET_ENTRY in plf_stub.h.

<p>All debugging features must be in place in order for the debugging
services to be functional. See general platform porting notes.


<h4>New architecture ports</h4>

<p>There are no specific requirements for a new architecture port in
order to support the calling interface, but the basic debugging
features must be in place. See general architecture porting notes.

<p><HR SIZE=3>
<h3><a name="io_channels">IO channels</a></h3>


<p>The calling interface provides procedure tables for all IO channels on
the platform. These are used for console (diagnostic) and debugger IO,
allowing a ROM monitor to provided all the needed IO routines. At
the same time, this makes it easy to switch console/debugger channels
at run-time (the old implementation had hardwired drivers for console
and debugger IO, preventing these to change at run-time).

<p>The hal_if provides wrappers which interface these services to the
eCos infrastructure diagnostics routines. This is done in a way which
ensures proper string mangling of the diagnostics output when required
(e.g. O-packetization when using a GDB compatible ROM monitor).

<h4>Available Procedures</h4>

<p>This is a brief description of the procedures</p>

<dl>
<dt><tt>CH_DATA</tt>
<dd>Pointer to the controller IO base (or a pointer to a per-device
    structure if more data than the IO base is required). All the
    procedures below are called with this data item as the first
    argument.</dd>

<dt><tt>WRITE</tt>
        <dd>Writes the buffer to the device.</dd>
<dt><tt>READ</tt>
        <dd>Fills a buffer from the device.</dd>
<dt><tt>PUTC</tt>
        <dd>Write a character to the device.</dd>
<dt><tt>GETC</tt>
        <dd>Read a character from the device.</dd>
<dt><tt>CONTROL</tt>
        <dd>Device feature control. Second argument specifies function:
  <dl>
    <dt><tt>SETBAUD</tt>
        <dd>Changes baud rate.</dd>
    <dt><tt>GETBAUD</tt>
        <dd>Returns the current baud rate.</dd>
    <dt><tt>INSTALL_DBG_ISR</tt>
        <dd>[Unused]</dd>
    <dt><tt>REMOVE_DBG_ISR</tt>
        <dd>[Unused]</dd>
    <dt><tt>IRQ_DISABLE</tt>
        <dd>Disable debugging receive interrupts on the device.</dd>
    <dt><tt>IRQ_ENABLE</tt>
        <dd>Enable debugging receive interrupts on the device.</dd>
    <dt><tt>DBG_ISR_VECTOR</tt>
        <dd>Returns the ISR vector used by the device for debugging
        receive interrupts.</dd>
    <dt><tt>SET_TIMEOUT</tt>
        <dd>Set GETC timeout in milliseconds.</dd>
   </dl>

<dt><tt>DBG_ISR</tt>
        <dd>ISR used to handle receive interrupts from the device (see <a
        href="hal-stubs.html#async_bps">Asynchronous GDB
        breakpoints</a>).</dd>
<dt><tt>GETC_TIMEOUT</tt>
        <dd>Read a character from the device with timeout.</dd>
</dl>


<h4>Usage</h4>

<p>The standard eCos diagnostics IO functions use the channel
procedure table when CYGSEM_HAL_VIRTUAL_VECTOR_DIAG is enabled. That
means that when you use diag_printf (or the libc printf function) the
stream goes through the selected console procedure table. If you use
the virtual vector function SET_CONSOLE_COMM you can change the device
which the diagnostics output goes to at run-time.</p>

<p>You can also use the table functions directly if desired
(regardless of the CYGSEM_HAL_VIRTUAL_VECTOR_DIAG setting - assuming
the ROM monitor provides the services). Here is a small example which
changes the console to use channel 2, fetches the comm procs pointer
and calls the write function from that table, then restores the
console to the original channel:</p>

<pre>
#define T "Hello World!\n"

int
main(void)
{
    hal_virtual_comm_table_t* comm;
    int cur = CYGACC_CALL_IF_SET_CONSOLE_COMM(CYGNUM_CALL_IF_SET_COMM_ID_QUERY_CURRENT);

    CYGACC_CALL_IF_SET_CONSOLE_COMM(2);

    comm = CYGACC_CALL_IF_CONSOLE_PROCS();
    CYGACC_COMM_IF_WRITE(*comm, T, strlen(T));

    CYGACC_CALL_IF_SET_CONSOLE_COMM(cur);
}
</pre>

<p>Beware that if doing something like the above, you should only do
it to a channel which does not have GDB at the other end: GDB ignores
raw data, so you would not see the output.</p>


<h4>Compatibility</h4>

<p>The use of this service is controlled by the option
CYGSEM_HAL_VIRTUAL_VECTOR_DIAG which is disabled per default on most
older platforms (thus preserving backwards compatibility with older
stubs). On newer ports, this option should always be set.

<h4>Implementation details</h4>

<p>There is an array of procedure tables (raw comm channels) for each
IO device of the platform which get initialized by the ROM monitor, or
optionally by a RAM startup configuration (allowing the RAM
configuration to take full control of the target).  In addition to
this, there's a special table which is used to hold mangler
procedures.</p>

<p>The vector table defines which of these channels are selected for
console and debugging IO respectively: console entry can be empty,
point to mangler channel, or point to a raw channel. The debugger
entry should always point to a raw channel.</p>

<p>During normal console output (i.e., diagnostic output) the console
table will be used to handle IO if defined. If not defined, the debug
table will be used.</p>

<p>This means that debuggers (such as GDB) which require text streams
to be mangled (O-packetized in the case of GDB), can rely on the ROM
monitor install mangling IO routines in the special mangler table and
select this for console output. The mangler will pass the mangled data
on to the selected debugging channel.</p>

<p>If the eCos configuration specifies a different console channel
from that used by the debugger, the console entry will point to the
selected raw channel, thus overriding any mangler provided by the ROM
monitor.</p>

<p>See hal_if_diag_* routines in hal_if.c for more details of the stream
path of diagnostic output. See cyg_hal_gdb_diag_* routines in
hal_stub.c for the mangler used for GDB communication.</p>

<pre>
FIXME: Other special channels are reserved for ethernet communication.
</pre>


<h4>New platform ports</h4>

<p>Define CDL options CYGNUM_HAL_VIRTUAL_VECTOR_COMM_CHANNELS,
CYGNUM_HAL_VIRTUAL_VECTOR_DEBUG_CHANNEL, and
CYGNUM_HAL_VIRTUAL_VECTOR_CONSOLE_CHANNEL.

<p>If CYGSEM_HAL_VIRTUAL_VECTOR_DIAG is set, make sure the infra diag
code uses the hal_if diag functions:</p>

<pre>
 #define HAL_DIAG_INIT() hal_if_diag_init()
 #define HAL_DIAG_WRITE_CHAR(_c_) hal_if_diag_write_char(_c_)
 #define HAL_DIAG_READ_CHAR(_c_) hal_if_diag_read_char(&_c_)
</pre>

<p>In addition to the above functions, the platform HAL must also
provide a function cyg_hal_plf_comms_init which initializes the
drivers and the channel procedure tables.</t>

<p>Most of the other functionality in the table is more or less
possible to copy unchanged from existing ports. Some care is necessary
though to ensure the proper handling of interrupt vectors and timeouts
for various devices handled by the same driver. See PowerPC/Cogent
platform HAL for an example implementation.</p>

<p><b>Note:</b> When vector table console code is <em>not</em> used,
the platform HAL must map the HAL_DIAG_INIT, HAL_DIAG_WRITE_CHAR and
HAL_DIAG_READ_CHAR macros directly to the low-level IO functions,
hardwired to use a compile-time configured channel.</p>

<p><b>Note:</b> On old ports the hardwired HAL_DIAG_INIT,
HAL_DIAG_WRITE_CHAR and HAL_DIAG_READ_CHAR implementations will also
contain code to O-packetize the output for GDB. This should <b>not</b>
be adopted for new ports! On new ports the ROM monitor is guaranteed
to provide the necessary mangling via the vector table. The hardwired
configuration should be reserved for ROM startups where achieving
minimal image size is crucial.<p>

<!--#include virtual="../../include/footer.html"-->

<!--
LocalWords: ctrlc packetization packetized packetize GP
LocalWords: libbsp strlen GETC comm comms DBG procs
LocalWords: dd init printf int libc TBD
-->
