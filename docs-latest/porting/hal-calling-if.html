<HTML>
<HEAD>
<TITLE>eCos/ROM Monitor Calling Interface</TITLE>
</HEAD>

<!--#include virtual="../../include/header.html"-->

<H2>eCos/ROM Monitor Calling Interface [TBD/in progress]</H2>
<HR SIZE=3>

<p>Some eCos platforms have supported full debugging capabilities via
CygMon since day one. Platforms of the architectures PowerPC, ARM, and
SH do not provide those features unless a GDB stub is included in the
application.

<p>This is going to change. All platforms will (eventually) support
all the debugging features by relying on a ROM/RAM calling interface
(also referred to as virtual vector table) provided by the ROM
monitor. This calling interface is based on the tables used by libbsp
and is thus backwards compatible with the existing CygMon supported
platforms.

<h3>The calling interface API</h3>

<p>The calling interface API is defined by hal_if.h and hal_if.c in
hal/common.

<p>The API provides a set of services. Different platforms, or
different versions of the ROM monitor for a single platform, may
implement fewer or extra service. The table has room for growth, and
any entries which are not supported map to a NOP-service (when called
it returns 0 (false)).

<p>A client of a service should either be selected by configuration,
or have suitable fall back alternatives in case the feature is not
implemented by the ROM monitor.

<p><b>Note:</b>
Checking for unimplemented service when this may be a data
field/pointer instead of a function: suggest reserving the last entry
in the table as the NOP-service pointer. Then clients can compare a
service entry with this pointer to determine whether it's initialized
or not.

<p>hal_if.h: defines the table layout and accessor macros (allowing
 primitive type checking and alternative implementations should it
 become necessary).

<p>hal_if.c: defines the table initialization function (which all HALs
 should call during platform initialization - the table will get
 initialized according to configuration).
 Here is also defined wrapper functions which map between the calling
 interface API and the API of the used eCos functions.


<h4>Implemented Services</h4>

<p>This is a brief description of the services, some of which are
described in further detail below.</p>

<ul>
<li><tt>VERSION</tt>
        <p>Version of table. Serves as a way to check for how many
        features are available in the table. This is the index of the
        last service in the table.</p>
<li><tt>ICTRL_TABLE</tt>
        <p>[Unused, possibly delete]</p>
<li><tt>EXC_TABLE</tt>
        <p>[Unused, possibly delete]</p>
<li><tt>DBG_VECTOR</tt>
        <p>ROM monitor entry point. Not supported at the moment.</p>
<li><tt>KILL_VECTOR</tt>
        <p>[Presently unused by the stub code, but initialized] This
        vector defines a function to execute when the system receives
        a kill signal from the debugger. It is initialized with the
        reset function (see below), but the application (or eCos) can
        override it if necessary.</p>
<li><tt>CONSOLE_PROCS</tt>
        <p>The communication procedure table used for console IO.
        (see <a href="#io_channels">IO channels</a>)</p>
<li><tt>DEBUG_PROCS</tt>
        <p>The communication procedure table used for debugger IO.</p>
<li><tt>FLUSH_DCACHE</tt>
        <p>Flushes the data cache for the specified
        region. Some implementations may flush the entire data cache.</p>
<li><tt>FLUSH_ICACHE</tt>
        <p>Flushes (invalidates) the instruction cache
        for the specified region. Some implementations may flush the
        entire instruction cache.</p>
<li><tt>CPU_DATA</tt>
        <p>[Presently unused] Architecture HAL may use this as a
        pointer to architecture specific data.</p>
<li><tt>BOARD_DATA</tt>
        <p>[Presently unused] Platform HAL may use this as a
        pointer to platform specific data.</p>
<li><tt>SYSINFO</tt>
        <p>[Presently unused] Could be used to return information
        about available memory, caches sizes, etc.</p>
<li><tt>SET_DEBUG_COMM</tt>
        <p>Change debugging communication channel.</p>
<li><tt>SET_CONSOLE_COMM</tt>
        <p>Change console communication channel.</p>
<li><tt>SET_SERIAL_BAUD</tt>
        <p>[Unused, possibly delete. Feature available in comm table
        anyway]</p>
<li><tt>DBG_SYSCALL</tt>
        <p>Vector used to communication between debugger functions in
        ROM and in RAM. RAM eCos configurations may install a function
        pointer here which the ROM monitor uses to get thread
        information from the kernel running in RAM.</p>
<li><tt>RESET</tt>
        <p>Resets the board on call. If it is not possible to reset
        the board from software, it will jump to the ROM entry point
        which will perform a "software" reset of the board.</p>
<li><tt>CONSOLE_INTERRUPT_FLAG</tt>
        <p>Set if a debugger interrupt request was detected while
        processing console IO. Allows the actual breakpoint action to
        be handled after return to RAM, ensuring proper backtraces
        etc.</p>
<li><tt>DELAY_US</tt>
        <p>Will delay the specified number of microseconds. The
        precision is platform dependant to some extend - a small value
        (<100us) is likely to cause bigger delays than requested.</p>
</ul>

<h4>Compatibility</h4>

<p>When a platform is changed to support the calling interface,
applications will use it if so configured. That means that if an
application is run on a platform with an older ROM monitor, the
service is almost guaranteed to fail.

<p>For this reason, applications should only use Console Comm for HAL
diagnostics output if explicitly configured to do so
(CYGSEM_HAL_VIRTUAL_VECTOR_DIAG).

<p>As for asynchronous GDB interrupts, the service will always be
used. This is likely to cause a crash under older ROM monitors, but
this crash may be caught by the debugger. The old workaround still
applies: if you need asynchronous breakpoints or thread debugging
under older ROM monitors, you may have to include the debugging
support when configuring eCos.

<h4>Implementation details</h4>

<p>During the startup of a ROM monitor, the calling table will be
initialized. This also happens if eCos is configured <em>not</em> to rely on
a ROM monitor.

<p>If thread debugging features are enabled, the function for accessing
the thread information gets registered in the table during startup of
a RAM startup configuration.

<p>Further implementation details are described where the service itself
is described.

<h4>New platform ports</h4>

<p>The hal_platform_init() function must call hal_if_init().

<p>The HAL serial driver must, when called via cyg_hal_plf_comms_init
initialize the communication channels.

<p>The reset() function defined in hal_if.c will attempt to do a hardware
reset, but if this fails it will fall back to simply jumping to the
reset entry-point. On most platforms the startup initialization will
go a long way to reset the target to a sane state (there will be
exceptions, of course). For this reason, make sure to define
HAL_STUB_PLATFORM_RESET_ENTRY in plf_stub.h.

<p>All debugging features must be in place in order for the debugging
services to be functional. See general platform porting notes.


<h4>New architecture ports</h4>

<p>There are no specific requirements for a new architecture port in
order to support the calling interface, but the basic debugging
features must be in place. See general architecture porting notes.

<p><HR SIZE=3>
<h3><a name="io_channels">IO channels</a></h3>


<p>The calling interface provides procedure tables for all IO channels on
the platform. These are used for console (diagnostic) and debugger IO,
allowing a ROM monitor to provided all the needed IO routines. At
the same time, this makes it easy to switch console/debugger channels
at run-time (the old implementation had hardwired drivers for console
and debugger IO, preventing these to change at run-time).

<p>The hal_if provides wrappers which interface these services to the
eCos infrastructure diagnostics routines. This is done in a way which
ensures proper string mangling of the diagnostics output when required
(e.g. O-packetization when using a GDB compatible ROM monitor).

<h4>Compatibility</h4>

<p>The use of this service is controlled by the option
CYGSEM_HAL_VIRTUAL_VECTOR_DIAG which is disabled per default on most
older platforms (thus preserving backwards compatibility with older
stubs). On newer ports, this option should always be set.

<h4>Implementation details</h4>

<p>There is an array of procedure tables (raw comm channels) for each
IO device of the platform which get initialized by the ROM monitor, or
optionally by a RAM startup configuration (allowing the RAM
configuration to take full control of the target).  In addition to
this, there's a special table which is used to hold mangler
procedures.

<p>The vector table defines which of these channels are selected for
console and debugging IO respectively: console entry can be empty,
point to mangler channel, or point to a raw channel. The debugger
entry should always point to a raw channel.

<p>During normal console output (i.e., diagnostic output) the console
table will be used to handle IO if defined. If not defined, the debug
table will be used.

<p>This means that debuggers (such as GDB) which require text streams
to be mangled (O-packetized in the case of GDB), can rely on the ROM
monitor install mangling IO routines in the special mangler table and
select this for console output. The mangler will pass the mangled data
on to the selected debugging channel.

<p>If the eCos configuration specifies a different console channel
from that used by the debugger, the console entry will point to the
selected raw channel, thus overriding any mangler provided by the ROM
monitor.

<p>See hal_if_diag_* routines in hal_if.c for more details of the stream
path of diagnostic output. See cyg_hal_gdb_diag_* routines in
hal_stub.c for the mangler used for GDB communication.


<h4>New platform ports</h4>

<p>Define CDL options CYGNUM_HAL_VIRTUAL_VECTOR_COMM_CHANNELS,
CYGNUM_HAL_VIRTUAL_VECTOR_DEBUG_CHANNEL, and
CYGNUM_HAL_VIRTUAL_VECTOR_CONSOLE_CHANNEL.

<p>If CYGSEM_HAL_VIRTUAL_VECTOR_DIAG is set, make sure the infra diag
code uses the hal_if diag functions:

<pre>
 #define HAL_DIAG_INIT() hal_if_diag_init()
 #define HAL_DIAG_WRITE_CHAR(_c_) hal_if_diag_write_char(_c_)
 #define HAL_DIAG_READ_CHAR(_c_) hal_if_diag_read_char(&_c_)
</pre>

<p>When vector table console code is <em>not</em> used, the platform
HAL must map the HAL_DIAG_INIT, HAL_DIAG_WRITE_CHAR and
HAL_DIAG_READ_CHAR macros directly to the low-level IO
functions. <b>This should only be necessary for compatibility with
older ROM monitors - a new port should not provide these hardwired IO
diag functions</b>

<p>The platform HAL must also provide a function
cyg_hal_plf_comms_init which initializes the drivers and (when
necessary) initializes the channel procedure tables.

<p>See PowerPC/Cogent platform HAL for an example implementation for
an old port. For a new port, assume CYGSEM_HAL_VIRTUAL_VECTOR_DIAG to
be defined as a matter of course (i.e., no <em>not</em> provide the
alternative implementation).</p>

<p><HR SIZE=3>
<h3><a name="asynch_bps">Asynchronous GDB breakpoints</a></h3>


<p>GDB allows to asynchronously break execution of a running
application. This is done by sending a 0x03 character to the
target. If the serial device has interrupts enabled the interrupt
execution path will eventually pass through hal_default_isr (see the
Note below) which will check for the 0x03 character and issue a
breakpoint. This will cause the ROM monitor to be entered, and GDB
resumes control of the target.

<p><b>Note:</b> if a serial device driver is enabled and is
using the serial receive character interrupt vector, the character
will never reach the asynchronous breakpoint handling code, and thus
GDB will <em>not</em> be able to break the application execution.  If
possible (not available on all platforms), use different serial
devices for debugging and serial communication.


<h4>Implementation details</h4>

<p>The implementation consists of two parts:

<ol>
<li><p>The serial driver initialization and ISR code</p>
<ul>
<li> <tt>IRQ_ENABLE/IRQ_DISABLE</tt>

  <p> The driver's comm table provides a control function. This
  function must respond to IRQ_ENABLE and IRQ_DISABLE commands,
  enabling respectively disabling interrupts on the device. 

  <p>Enabling the interrupts may also involve configuring interrupt levels
  on the CPU/interrupt controller.</p>


<li> <tt>DBG_ISR</tt>

 <p>This ISR will examine the device. If the device has received
 characters, check if any of these are ctrlc characters from GDB
 (using cyg_hal_is_break), and if so, sets the ctrlc flag, otherwise
 clears it.

 <p> If the device was the cause of an interrupt, acknowledge it, and
 return CYG_ISR_HANDLED, otherwise return 0.

 <p> Note that the ISR is not attached to any vector. Instead it will be
    called from the hal_ctrlc_isr function which in turn is called
    from default_isr_handler.</p>
</ul>

<li><p>The common code</p>
<ul>

<li> <tt>start</tt>

 <p>The architecture initialization code will call hal_ctrlc_isr_init
    during startup to enable the serial interrupt. This should happen
    after the call to initialize_stub.</p>

<li> <tt>hal_default_isr</tt> 

 <p>Will check if the vector matches the DBG_ISR_VECTOR reported by
 the comms vector control function, and if so call hal_ctrlc_isr.</p>

<li> <tt>hal_ctrlc_isr</tt> 

 <p>This will call the DBG_ISR function provided by the device
 driver. If the ctrlc flag is set on return, cyg_hal_user_break is
 called to set a breakpoint at the interrupt return address (to be hit
 when returning from interrupt code to normal user code <b>*</b>). </p>

  <p> <b>caveat</b> If the breakpoint is set in some code which will never
      be reached again (e.g., in a thread which gets scheduled out and
      killed during interrupt_exit) the breakpoint may never get
      hit. But it should not happen so often that it is a problem.</p>

<li> <tt>cyg_hal_user_break</tt>

  <p> Will use the ROM/RAM calling interface to place a breakpoint at
      the specified address.

  <p> If there is no calling interface, simply use BREAKPOINT which is
      a hardwired breakpoint. That becomes a dead end since GDB will
      not know how to continue from there.</p>

</ul>
</ol>

<h4>New platform ports</h4>

<p>Implement IO procedure functions to enable/disable the receive
interrupt for a given channel. Also implement the ISR function.


<h4>New architecture ports</h4>

<p>If the architecture uses a "Global Pointer" register for accessing
data, CYGARC_HAL_SAVE_GP and CYGARC_HAL_RESTORE_GP macros must be
implemented. 

<p>hal_ctrlc_isr_init must be called from vectors.S after the call to
initialize_stub.

<p>Regular GDB stub support must be in place.


<!--#include virtual="../../include/footer.html"-->

<!--
LocalWords: ctrlc CTRLC packetization packetized comm COMM GP
-->
