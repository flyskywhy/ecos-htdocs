<HTML>
<HEAD>
<TITLE>eCos GDB stubs</TITLE>
</HEAD>

<!--#include virtual="../../include/header.html"-->

<H2>eCos GDB stubs [TBD]</H2>
<HR SIZE=3>

<ul>
<li> What do they do
<li> How (protocol details, target side operation)
<li> Implementation outline (links to arch/plf porting pages)
</ul>

<p><HR SIZE=3>
<h3><a name="async_bps">Asynchronous GDB breakpoints</a></h3>


<p>GDB allows to asynchronously break execution of a running
application. This is done by sending a 0x03 character to the
target. If the serial device has interrupts enabled the interrupt
execution path will eventually pass through hal_default_isr (see the
Note below) which will check for the 0x03 character and issue a
breakpoint. This will cause the ROM monitor to be entered, and GDB
resumes control of the target.</p>

<p><b>Note:</b> if a serial device driver is enabled and is
using the serial receive character interrupt vector, the character
will never reach the asynchronous breakpoint handling code, and thus
GDB will <em>not</em> be able to break the application execution.  If
possible (not available on all platforms), use different serial
devices for debugging and serial communication.</p>


<h4>Implementation details</h4>

<p>The implementation consists of two parts:</p>

<ol>
<li><p>The serial driver initialization and ISR code:
<dl>
<dt><tt>IRQ_ENABLE/IRQ_DISABLE</tt>
        <dd> The driver's comm table provides a control function. This
        function must respond to IRQ_ENABLE and IRQ_DISABLE commands,
        enabling respectively disabling interrupts on the
        device. </dd>

        <dd>Enabling the interrupts may also involve configuring
        interrupt levels on the CPU/interrupt controller.</dd>

<dt><tt>DBG_ISR</tt>
        <dd>This ISR will examine the device. If the device has
        received characters, check if any of these are ctrlc
        characters from GDB (using cyg_hal_is_break), and if so, sets
        the ctrlc flag, otherwise clears it.</dd>

        <dd> If the device was the cause of an interrupt, acknowledge
        it, and return CYG_ISR_HANDLED, otherwise return 0.</dd>

        <dd> Note that the ISR is not attached to any vector. Instead
        it will be called from the hal_ctrlc_isr function which in
        turn is called from default_isr_handler.</dd>
</dl></p>

<li><p>The common code
<dl>
<dt><tt>start</tt>
        <dd>The architecture initialization code will call
        hal_ctrlc_isr_init during startup to enable the serial
        interrupt. This should happen after the call to
        initialize_stub.</dd>

<dt><tt>hal_default_isr</tt> 
        <dd>Will check if the vector matches the DBG_ISR_VECTOR
        reported by the comms vector control function, and if so call
        hal_ctrlc_isr.</dd>

<dt><tt>hal_ctrlc_isr</tt> 
        <dd>This will call the DBG_ISR function provided by the device
        driver. If the ctrlc flag is set on return, cyg_hal_user_break
        is called to set a breakpoint at the interrupt return address
        (to be hit when returning from interrupt code to normal user
        code <b>*</b>). </dd>

        <dd><b>* caveat:</b> If the breakpoint is set in some code which
        will never be reached again (e.g., in a thread which gets
        scheduled out and killed during interrupt_exit) the breakpoint
        may never get hit. But it should not happen so often that it
        is a problem.</dd>

<dt><tt>cyg_hal_user_break</tt>
        <dd> Will use the ROM/RAM calling interface to place a
        breakpoint at the specified address.

        <dd> If there is no calling interface, simply use BREAKPOINT
        which is a hardwired breakpoint. That becomes a dead end since
        GDB will not know how to continue from there.</dd>
</dl></p>
</ol>

<h4>New platform ports</h4>

<p>Implement IO procedure functions to enable/disable the receive
interrupt for a given channel. Also implement the ISR function.</p>


<h4>New architecture ports</h4>

<p>If the architecture uses a "Global Pointer" register for accessing
data, CYGARC_HAL_SAVE_GP and CYGARC_HAL_RESTORE_GP macros must be
implemented.</p>

<p>hal_ctrlc_isr_init must be called from vectors.S after the call to
initialize_stub.</p>

<p>Regular GDB stub support must be in place.</p>


<!--#include virtual="../../include/footer.html"-->

<!--
LocalWords: ctrlc packetization packetized packetize GP
LocalWords: libbsp strlen GETC comm comms DBG procs
LocalWords: dd init printf int libc TBD
-->
