<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML EXPERIMENTAL 970324//EN">
<HTML>
<HEAD><!--version 1.4/Thur Aug 03 12:18:56 BST 2000-->
<META NAME="GENERATOR" CONTENT="Adobe FrameMaker 5.5/HTML Export Filter">
<LINK REL="STYLESHEET" HREF="cygnus.css">
<TITLE> POSIX Standard Support </TITLE></HEAD>
<BODY BGCOLOR="#ffffff">
<DIV>
<TABLE STYLE="ECOS" WIDTH="100%" BORDER="0" ALIGN="LEFT" CELLPADDING="3"><TR><TH COLSPAN="2" ALIGN="center"><P CLASS="Gotos">POSIX Standard Support </P></TH></TR><TR><TD WIDTH="47%" ALIGN="center">
        <P CLASS="Gotos"><A HREF="ecos-elix.html">To&nbsp;copyright information</A></P>
      </TD><TD WIDTH="47%" ALIGN="center">
        <P CLASS="Gotos"><A HREF="ecos-elix.1.html">To&nbsp;Contents</A></P>
      </TD></TR></TABLE><P ALIGN="LEFT">&nbsp;</P><BR><HR ALIGN="center"></DIV>
<H2 CLASS="ChapterTitle">
<A NAME="pgfId=2627108">
 </A>
POSIX Standard Support <DIV>
<IMG SRC="botclear.gif">
</DIV>
</H2>
<P CLASS="BodyAfterHead">
<A NAME="pgfId=2626982">
 </A>
eCos contains support for the POSIX Specification (ISO/IEC 9945-1)[POSIX]. This support follows EL/IX level 1 in the functionality supplied [ELIX].</P>
<P CLASS="Body">
<A NAME="pgfId=2626765">
 </A>
POSIX support is divided between the POSIX and the FILEIO packages. The POSIX package provides support for threads, signals, synchronization, timers and message queues. The FILEIO package provides support for file and device I/O. The two packages may be used together or separately, depending on configuration.</P>
<P CLASS="Body">
<A NAME="pgfId=2626766">
 </A>
This document takes a functional appoach to the POSIX library. Support for a function implies that the data types and definitions necessary to support that function, and the objects it manipulates, are also defined. Any exceptions to this are noted, and unless otherwise noted, implemented functions behave as specified in the POSIX standard.</P>
<P CLASS="Body">
<A NAME="pgfId=2626767">
 </A>
This document only covers the differences between the eCos implementation and the standard; it does not provide complete documentation. For full information, see the POSIX standard [POSIX]. Online, the Open Group Single Unix Specification [SUS2] provides complete documentation of a superset of POSIX. If you have access to a Unix system with POSIX compatibility, then the manual pages for this will be of use.  There are also a number of books available. [Lewine] covers the process, signal, file and I/O functions, while [Lewis1], [Lewis2], [Nichols] and [Norton] cover Pthreads and related topics (see Bibliography, xref). However, many of these books are oriented towards using POSIX in non-embedded systems, so care should be taken in applying them to programming under eCos.</P>
<P CLASS="Body">
<A NAME="pgfId=2626768">
 </A>
The remainder of this chapter broadly follows the structure of the POSIX Specification. References to the appropriate section of the Standard are included.</P>
<P CLASS="Body">
<A NAME="pgfId=2626769">
 </A>
Omitted functions marked with &quot;// TBA&quot; are potential candidates for later implementation.</P>
<H3 CLASS="Heading2">
<A NAME="pgfId=2626770">
 </A>
Process Primitives [POSIX Section 3]</H3>
<H4 CLASS="Heading3">
<A NAME="pgfId=2626771">
 </A>
Functions Implemented</H4>
<PRE CLASS="CodeExample"><A NAME="pgfId=2627171"> </A>
int kill(pid_t pid, int sig); 
int pthread_kill(pthread_t thread, int sig); 
int sigaction(int sig, const struct sigaction *act,
	struct sigaction *oact); 
int sigqueue(pid_t pid, int sig, const union sigval value); 
int sigprocmask(int how, const sigset_t *set, sigset_t *oset); 
int pthread_sigmask(int how, const sigset_t *set, sigset_t *oset); 
int sigpending(sigset_t *set); int sigsuspend(const sigset_t *set); 
int sigwait(const sigset_t *set, int *sig); 
int sigwaitinfo(const sigset_t *set, siginfo_t *info); 
int sigtimedwait(const sigset_t *set, siginfo_t *info,
	const struct timespec *timeout); 
int sigemptyset(sigset_t *set); 
int sigfillset(sigset_t *set); 
int sigaddset(sigset_t *set, int signo); 
int sigdelset(sigset_t *set, int signo); 
int sigismember(const sigset_t *set, int signo);
unsigned int alarm( unsigned int seconds ); int pause( void ); 
unsigned int sleep( unsigned int seconds );</PRE>
<H4 CLASS="Heading3">
<A NAME="pgfId=2626773">
 </A>
Functions Omitted</H4>
<PRE CLASS="CodeExample"><A NAME="pgfId=2626774"> </A>
pid_t fork(void); 
int execl( const char *path, const char *arg, ... ); 
int execv( const char *path, char *const argv[] ); 
int execle( const char *path, const char *arg, ... ); 
int execve( const char *path, char *const argv[], char *const envp[] ); 
int execlp( const char *path, const char *arg, ... ); 
int execvp( const char *path, char *const argv[] ); 
int pthread_atfork( void(*prepare)(void), void (*parent)(void), void 		 
	(*child)() ); 
pid_t wait( int *stat_loc );		    
pid_t waitpid( pid_t pid, int *stat_loc, int options ); 
void _exit( int status );					// TBA</PRE>
<H4 CLASS="Heading3">
<A NAME="pgfId=2628748">
 </A>
Notes</H4>
<UL>
<P><LI>
<A NAME="pgfId=2628749">
 </A>
<EM CLASS="Emphasis">
kill()</EM>
 and <EM CLASS="Emphasis">
sigqueue()</EM>
 may only take a <STRONG CLASS="BoldEmphasis">
pid</STRONG>
 argument of zero, which maps to the current process.</LI>
<P><LI>
<A NAME="pgfId=2626777">
 </A>
The <EM CLASS="Emphasis">
SIGEV_THREAD</EM>
 notification type is not currently implemented.</LI>
<P><LI>
<A NAME="pgfId=2626778">
 </A>
Job Control and Memory Protection signals are not supported.</LI>
<P><LI>
<A NAME="pgfId=2626779">
 </A>
An extra implementation defined <EM CLASS="Emphasis">
si_code</EM>
 value, <EM CLASS="Emphasis">
SI_EXCEPT,</EM>
 is defined to distinguish hardware generated exceptions from others.</LI>
<P><LI>
<A NAME="pgfId=2626780">
 </A>
Extra signals are defined: _SIGTRAP_,_SIGIOT_, _SIGEMT_, and _SIGSYS_. These are largely to maintain compatibility with the signal numbers used by GDB.</LI>
<P><LI>
<A NAME="pgfId=2626781">
 </A>
Signal delivery may currently occur at unexpected places in some API functions. Using <EM CLASS="Emphasis">
longjmp()</EM>
 to transfer control out of a signal handler may result in the interrupted function not being able to complete properly. This may result in later function calls failing or deadlocking.</LI>
</UL>
<H3 CLASS="Heading2">
<A NAME="pgfId=2626782">
 </A>
Process Environment [POSIX Section 4]</H3>
<H4 CLASS="Heading3">
<A NAME="pgfId=2626783">
 </A>
Functions Implemented</H4>
<PRE CLASS="CodeExample"><A NAME="pgfId=2626784"> </A>
int uname( struct utsname *name ); 
time_t time( time_t *tloc ); 
char *getenv( const char *name ); 
int isatty( int fd ); long sysconf( int name );</PRE>
<H4 CLASS="Heading3">
<A NAME="pgfId=2626785">
 </A>
Functions Omitted</H4>
<PRE CLASS="CodeExample"><A NAME="pgfId=2627211"> </A>
pid_t getpid( void ); 
pid_t getppid( void ); 
uid_t getuid( void ); 
uid_t geteuid( void ); 
gid_t getgid( void ); 
gid_t getegid( void ); 
int setuid( uid_t uid ); 
int setgid( gid_t gid ); 
int getgroups( int gidsetsize, gid_t grouplist[] ); 
char *getlogin( void ); 
int getlogin_r( char *name, size_t namesize ); 
pid_t getpgrp( void ); 
pid_t setsid( void ); int setpgid( pid_t pid, pid_t pgid ); 
char *ctermid( char *s); 
char *ttyname( int fd );					// TBA 
int ttyname_r( int fd, char *name, size_t namesize );		// TBA 
clock_t times( struct tms *buffer );				// TBA</PRE>
<H4 CLASS="Heading3">
<A NAME="pgfId=2626786">
 </A>
Notes</H4>
<UL>
<P><LI>
<A NAME="pgfId=2626787">
 </A>
The fields of the utsname structure are initialized as follows: <BR>
sysname	&quot;	eCos&quot; <BR>
nodename	&quot;&quot;	(gethostname() is currently not available)  <BR>
release		Major version number of the kernel <BR>
version   		Minor version number of the kernel <BR>
machine	&quot;&quot; 	(Requires some config tool changes)</LI>
<P><LI>
<A NAME="pgfId=2626788">
 </A>
The <EM CLASS="Emphasis">
time()</EM>
 function is currently implemented in the C library. </LI>
<P><LI>
<A NAME="pgfId=2627253">
 </A>
A set of environment strings may be defined at configuration time with the CYGDAT_LIBC_DEFAULT_ENVIRONMENT option. The application may also define an environment by direct assignment to the <STRONG CLASS="BoldEmphasis">
environ</STRONG>
 variable. </LI>
<P><LI>
<A NAME="pgfId=2627254">
 </A>
At present <EM CLASS="Emphasis">
isatty()</EM>
 assumes that any character device is a tty and that all other devices are not ttys. Since the only kind of device that eCos currently supports is serial character devices, this is an adequate distinction. </LI>
<P><LI>
<A NAME="pgfId=2627255">
 </A>
All system variables supported by sysconf will yield a value. However, those that are irrelevant to eCos will either return the default minimum defined in &lt;limits.h&gt;, or zero.</LI>
</UL>
<H3 CLASS="Heading2">
<A NAME="pgfId=2626789">
 </A>
Files and Directories [POSIX Section 5]</H3>
<H4 CLASS="Heading3">
<A NAME="pgfId=2626790">
 </A>
Functions Implemented</H4>
<PRE CLASS="CodeExample"><A NAME="pgfId=2626791"> </A>
DIR *opendir( const char *dirname ); 
struct dirent *readdir( DIR *dirp ); 
int readdir_r( DIR *dirp, struct dirent *entry, struct dirent **result ); 
void rewinddir( DIR *dirp ); 
int closedir( DIR *dirp ); 
int chdir( const char *path ); 
int open( const char * path , int oflag , ... ); 
int creat( const char * path, mode_t mode ); 
int link( const char *existing, const char *new ); 
int mkdir( const char *path, mode_t mode ); 
int unlink( const char *path ); 
int rmdir( const char *path ); 
int rename( const char *old, const char *new ); 
int stat( const char *path, struct stat *buf ); 
int fstat( int fd, struct stat *buf ); 
int access( const char *path, int amode ); 
long pathconf(const char *path, int name); 
long fpathconf(int fd, int name);</PRE>
<H4 CLASS="Heading3">
<A NAME="pgfId=2626792">
 </A>
Functions Omitted</H4>
<PRE CLASS="CodeExample"><A NAME="pgfId=2626793"> </A>
char *getcwd( char *buf, size_t size );				// TBA 
mode_t umask( mode_t cmask ); 
int mkfifo( const char *path, mode_t mode ); 
int chmod( const char *path, mode_t mode );			// TBA 
int fchmod( int fd, mode_t mode );				// TBA 
int chown( const char *path, uid_t owner, gid_t group ); 
int utime( const char *path, const struct utimbuf *times );	// TBA 
int ftruncate( int fd, off_t length );				// TBA</PRE>
<H4 CLASS="Heading3">
<A NAME="pgfId=2626794">
 </A>
Notes</H4>
<UL>
<P><LI>
<A NAME="pgfId=2626795">
 </A>
If a call to <EM CLASS="Emphasis">
open()</EM>
 or <EM CLASS="Emphasis">
creat()</EM>
 supplies the third _mode_ parameter, it will be ignored.</LI>
<P><LI>
<A NAME="pgfId=2626796">
 </A>
Most of the functionality of these functions depends on the underlying filesystem.</LI>
<P><LI>
<A NAME="pgfId=2626797">
 </A>
Currently<EM CLASS="Emphasis">
 access()</EM>
 only checks the <EM CLASS="Emphasis">
F_OK</EM>
 mode explicitly, the others are all assumed to be true by default.</LI>
<P><LI>
<A NAME="pgfId=2627287">
 </A>
The maximum number of open files allowed is supplied by the CYGNUM_FILEIO_NFILE option. The maximum number of file descriptors is supplied by the CYGNUM_FILEIO_NFD option.  </LI>
</UL>
<H3 CLASS="Heading2">
<A NAME="pgfId=2627288">
 </A>
Input and Output [POSIX Section 6] </H3>
<H4 CLASS="Heading3">
<A NAME="pgfId=2627289">
 </A>
Functions Implemented</H4>
<PRE CLASS="CodeExample"><A NAME="pgfId=2626801"> </A>
int dup( int fd ); 
int dup2( int fd, int fd2 ); 
int close(int fd); 
ssize_t	read(int fd, void *buf, size_t nbyte); 
ssize_t	write(int fd, const void *buf, size_t nbyte); 
int fcntl( int fd, int cmd, ... ); 
off_t lseek(int fd, off_t offset, int whence); 
int fsync( int fd ); int fdatasync( int fd );</PRE>
<H4 CLASS="Heading3">
<A NAME="pgfId=2626802">
 </A>
Functions Omitted</H4>
<PRE CLASS="CodeExample"><A NAME="pgfId=2627303"> </A>
int pipe( int fildes[2] ); 
int aio_read( struct aiocb *aiocbp );				// TBA 
int aio_write( struct aiocb *aiocbp );				// TBA 
int lio_listio( int mode, struct aiocb *const list[], int nent,
 	struct sigevent *sig);				// TBA 
int aio_error( struct aiocb *aiocbp );				// TBA 
int aio_return( struct aiocb *aiocbp );				// TBA 
int aio_cancel( int fd, struct aiocb *aiocbp );			// TBA 
int aio_suspend( const struct aiocb *const list[], int nent, 
	 const struct timespec *timeout );		// TBA 
int aio_fsync( int op, struct aiocb *aiocbp );			// TBA</PRE>
<H4 CLASS="Heading3">
<A NAME="pgfId=2626804">
 </A>
Notes</H4>
<UL>
<P><LI>
<A NAME="pgfId=2626805">
 </A>
Only the <EM CLASS="Emphasis">
F_DUPFD</EM>
 command of <EM CLASS="Emphasis">
fcntl()</EM>
 is currently implemented.</LI>
<P><LI>
<A NAME="pgfId=2626806">
 </A>
Most of the functionality of these functions depends on the underlying filesystem.</LI>
</UL>
<H3 CLASS="Heading2">
<A NAME="pgfId=2626807">
 </A>
Device and Class Specific Functions [POSIX Section 7]</H3>
<H4 CLASS="Heading3">
<A NAME="pgfId=2626808">
 </A>
Functions Implemented</H4>
<PRE CLASS="CodeExample"><A NAME="pgfId=2626809"> </A>
speed_t cfgetospeed( const struct termios *termios_p ); 
int cfsetospeed( struct termios *termios_p, speed_t speed ); 
speed_t cfgetispeed( const struct termios *termios_p ); 
int cfsetispeed( struct termios *termios_p, speed_t speed ); 
int tcgetattr( int fd, struct termios *termios_p ); 
int tcsetattr( int fd, int optional_actions,
	const struct termios *termios_p ); 
int tcsendbreak( int fd, int duration ); 
int tcdrain( int fd ); int tcflush( int fd, int queue_selector ); 
int tcsendbreak( int fd, int action ); 	       </PRE>
<H4 CLASS="Heading3">
<A NAME="pgfId=2627328">
 </A>
Functions Omitted</H4>
<PRE CLASS="CodeExample"><A NAME="pgfId=2626810"> </A>
pid_t tcgetpgrp( int fd ); 
int tcsetpgrp( int fd, pid_t pgrp );</PRE>
<H4 CLASS="Heading3">
<A NAME="pgfId=2626811">
 </A>
Notes</H4>
<UL>
<P><LI>
<A NAME="pgfId=2626812">
 </A>
Only the functionality relevant to basic serial device control is implemented. Only very limited support for canonical input is provided, and then only via the &quot;tty&quot; devices, not the &quot;serial&quot; devices. None of the functionality relevant to job control, controlling terminals and sessions is implemented.</LI>
<P><LI>
<A NAME="pgfId=2626813">
 </A>
Only <EM CLASS="Emphasis">
MIN</EM>
 = 0 and <EM CLASS="Emphasis">
TIME</EM>
 = 0 functionality is provided. </LI>
<P><LI>
<A NAME="pgfId=2627801">
 </A>
Hardware flow control is supported if the underlying device driver and serial port support it.</LI>
<P><LI>
<A NAME="pgfId=2626814">
 </A>
Support for break, framing and parity errors depends on the functionality of the hardware and device driver.  </LI>
</UL>
<H3 CLASS="Heading2">
<A NAME="pgfId=2626815">
 </A>
C Language Services [POSIX Section 8]</H3>
<H4 CLASS="Heading3">
<A NAME="pgfId=2626816">
 </A>
Functions Implemented</H4>
<PRE CLASS="CodeExample"><A NAME="pgfId=2626817"> </A>
char *setlocale( int category, const char *locale ); 
int fileno( FILE *stream ); 
FILE *fdopen( int fd, const char *type ); 
int getc_unlocked( FILE *stream); 
int getchar_unlocked( void ); 
int putc_unlocked( FILE *stream ); 
int putchar_unlocked( void ); 
char *strtok_r( char *s, const char *sep, char **lasts ); 
char *asctime_r( const struct tm *tm, char *buf ); 
char *ctime_r( const time_t *clock, char *buf ); 
struct tm *gmtime_r( const time_t *clock, struct tm *result ); 
struct tm *localtime_r( const time_t *clock, struct tm *result ); 
int rand_r( unsigned int *seed );</PRE>
<H4 CLASS="Heading3">
<A NAME="pgfId=2626818">
 </A>
Functions Omitted</H4>
<PRE CLASS="CodeExample"><A NAME="pgfId=2626819"> </A>
void flockfile( FILE *file ); 
int ftrylockfile( FILE *file ); 
void funlockfile( FILE *file ); 
int sigsetjmp( sigjmp_buf env, int savemask );			// TBA 
void siglongjmp( sigjmp_buf env, int val );			// TBA 
void tzset(void);						// TBA</PRE>
<H4 CLASS="Heading3">
<A NAME="pgfId=2626820">
 </A>
Notes</H4>
<UL>
<P><LI>
<A NAME="pgfId=2626821">
 </A>
<EM CLASS="Emphasis">
setlocale()</EM>
 is implemented in the C library Internationalization package.</LI>
<P><LI>
<A NAME="pgfId=2628130">
 </A>
Functions <EM CLASS="Emphasis">
fileno()</EM>
 and <EM CLASS="Emphasis">
fdopen()</EM>
 are implemented in the C library STDIO package.</LI>
<P><LI>
<A NAME="pgfId=2628134">
 </A>
functions <EM CLASS="Emphasis">
getc_unlocked(),</EM>
 <EM CLASS="Emphasis">
getchar_unlocked(),</EM>
 <EM CLASS="Emphasis">
putc_unlocked()</EM>
 and <EM CLASS="Emphasis">
putchar_unlocked()</EM>
 are defined but are currently identical to their non-unlocked equivalents. </LI>
<P><LI>
<A NAME="pgfId=2628135">
 </A>
<EM CLASS="Emphasis">
strtok_r(),</EM>
 <EM CLASS="Emphasis">
asctime_r(),</EM>
 <EM CLASS="Emphasis">
ctime_r(),</EM>
 <EM CLASS="Emphasis">
gmtime_r(),</EM>
 <EM CLASS="Emphasis">
localtime_r()</EM>
 and <EM CLASS="Emphasis">
rand_r()</EM>
 are all currently in the C library, alongside their non-reentrant versions.</LI>
</UL>
<H3 CLASS="Heading2">
<A NAME="pgfId=2626824">
 </A>
System Databases [POSIX Section 9]</H3>
<H4 CLASS="Heading3">
<A NAME="pgfId=2627387">
 </A>
Functions Implemented</H4>
<P CLASS="Body">
<A NAME="pgfId=2626825">
 </A>
&lt;none&gt;</P>
<H4 CLASS="Heading3">
<A NAME="pgfId=2626826">
 </A>
Functions Omitted</H4>
<PRE CLASS="CodeExample"><A NAME="pgfId=2626827"> </A>
struct group *getgrgid( gid_t gid ); 
int getgrgid( gid_t gid, struct group *grp, char *buffer, 
	  size_t bufsize, struct group **result ); 
struct group *getgrname( const char *name ); 
int getgrname_r( const char *name, struct group *grp, char *buffer, 
	 size_t bufsize, struct group **result ); 
struct passwd *getpwuid( uid_t uid ); 
int getpwuid_r( uid_t uid, struct passwd *pwd, char *buffer, 
	size_t bufsize, struct passwd **result ); 
struct passwd *getpwnam( const char *name ); 
int getpwnam_r( const char *name, struct passwd *pwd, char *buffer,
	size_t bufsize, struct passwd **result );</PRE>
<H4 CLASS="Heading3">
<A NAME="pgfId=2626828">
 </A>
Notes</H4>
<UL>
<P><LI>
<A NAME="pgfId=2626829">
 </A>
None of the functions in this section are implemented.</LI>
</UL>
<H3 CLASS="Heading2">
<A NAME="pgfId=2626830">
 </A>
Data Interchange Format [POSIX Section 10]</H3>
<P CLASS="Body">
<A NAME="pgfId=2626831">
 </A>
This section details <EM CLASS="Emphasis">
tar</EM>
 and <EM CLASS="Emphasis">
cpio</EM>
 formats. Neither of these is supported by eCos.</P>
<H3 CLASS="Heading2">
<A NAME="pgfId=2626832">
 </A>
Synchronization [POSIX Section 11]</H3>
<H4 CLASS="Heading3">
<A NAME="pgfId=2626833">
 </A>
Functions Implemented</H4>
<PRE CLASS="CodeExample"><A NAME="pgfId=2626834"> </A>
int sem_init(sem_t *sem, int pshared, unsigned int value); 
int sem_destroy(sem_t *sem); 
int sem_wait(sem_t *sem); 
int sem_trywait(sem_t *sem); 
int sem_post(sem_t *sem); int sem_getvalue(sem_t *sem, int *sval); 
int pthread_mutexattr_init( pthread_mutexattr_t *attr); 
int pthread_mutexattr_destroy( pthread_mutexattr_t *attr); 
int pthread_mutex_init(pthread_mutex_t *mutex, 		
	const pthread_mutexattr_t *mutex_attr); 
int pthread_mutex_destroy(pthread_mutex_t *mutex); 
int pthread_mutex_lock(pthread_mutex_t *mutex); 
int pthread_mutex_trylock(pthread_mutex_t *mutex); 
int pthread_mutex_unlock(pthread_mutex_t *mutex); 
int pthread_condattr_init(pthread_condattr_t *attr); 
int pthread_condattr_destroy(pthread_condattr_t *attr); 
int pthread_cond_init(pthread_cond_t *cond, 
	const pthread_condattr_t *attr); 
int pthread_cond_destroy(pthread_cond_t *cond); 
int pthread_cond_signal(pthread_cond_t *cond); 
int pthread_cond_broadcast(pthread_cond_t *cond); 
int pthread_cond_wait(pthread_cond_t *cond, 
	pthread_mutex_t *mutex);
int pthread_cond_timedwait(pthread_cond_t *cond,
	pthread_mutex_t *mutex,
	const struct timespec *abstime);</PRE>
<H4 CLASS="Heading3">
<A NAME="pgfId=2626836">
 </A>
Functions Omitted</H4>
<PRE CLASS="CodeExample"><A NAME="pgfId=2627439"> </A>
sem_t *sem_open(const char *name, int oflag, ...);		// TBA 
int sem_close(sem_t *sem);					// TBA 
int sem_unlink(const char *name);				// TBA 
int pthread_mutexattr_getpshared( const pthread_mutexattr_t *attr,
	int *pshared );
int pthread_mutexattr_setpshared( const pthread_mutexattr_t *attr,
	 int pshared ); 
int  pthread_condattr_getpshared( const pthread_condattr_t *attr, 
	 int *pshared);				  
int  pthread_condattr_setpshared( const pthread_condattr_t *attr, 	
	 int pshared);				  </PRE>
<H4 CLASS="Heading3">
<A NAME="pgfId=2626837">
 </A>
Notes</H4>
<UL>
<P><LI>
<A NAME="pgfId=2626838">
 </A>
The <STRONG CLASS="BoldEmphasis">
pshared</STRONG>
 argument to <EM CLASS="Emphasis">
sem_init()</EM>
 is not implemented, its value is ignored.</LI>
<P><LI>
<A NAME="pgfId=2626839">
 </A>
Functions <EM CLASS="Emphasis">
sem_open(),</EM>
 <EM CLASS="Emphasis">
sem_close()</EM>
 and <EM CLASS="Emphasis">
sem_unlink()</EM>
 are present but always return an error (ENOSYS).</LI>
<P><LI>
<A NAME="pgfId=2626840">
 </A>
{_POSIX_THREAD_PROCESS_SHARED} is not defined, so the <STRONG CLASS="BoldEmphasis">
process-shared</STRONG>
 mutex and condition variable attributes are not supported, and neither are the functions <EM CLASS="Emphasis">
pthread_mutexattr_getpshared(),</EM>
 <EM CLASS="Emphasis">
pthread_mutexattr_setpshared(),</EM>
 <EM CLASS="Emphasis">
pthread_condattr_getpshared()</EM>
 and <EM CLASS="Emphasis">
pthread_condattr_setpshared().</EM>
 </LI>
<P><LI>
<A NAME="pgfId=2627459">
 </A>
Condition variables do not become bound to a particular mutex when <EM CLASS="Emphasis">
pthread_cond_wait()</EM>
 is called. Hence different threads may wait on a condition variable with different mutexes. This is at variance with the standard, which requires a condition variable to become (dynamically) bound by the first waiter, and unbound when the last finishes. However, this difference is largely benign, and the cost of policing this feature is non-trivial.</LI>
</UL>
<H3 CLASS="Heading2">
<A NAME="pgfId=2626841">
 </A>
Memory Management [POSIX Section 12] </H3>
<H4 CLASS="Heading3">
<A NAME="pgfId=2627463">
 </A>
Functions Implemented</H4>
<P CLASS="Body">
<A NAME="pgfId=2626842">
 </A>
&lt;none&gt;</P>
<H4 CLASS="Heading3">
<A NAME="pgfId=2626843">
 </A>
Functions Omitted</H4>
<PRE CLASS="CodeExample"><A NAME="pgfId=2626844"> </A>
int mlockall( int flags ); 
int munlockall( void ); 
int mlock( const void *addr, size_t len ); 
int munlock( const void *addr, size_t len ); 
void mmap( void *addr, size_t len, int prot, int flags, 	 
	int fd, off_t off ); 
int munmap( void *addr, size_t len ); 
int mprotect( const void *addr, size_t len, int prot ); 
int msync( void *addr, size_t len, int flags ); 
int shm_open( const char *name, int oflag, mode_t mode ); 
int shm_unlink( const char *name );</PRE>
<H4 CLASS="Heading3">
<A NAME="pgfId=2626845">
 </A>
Notes</H4>
<UL>
<P><LI>
<A NAME="pgfId=2626846">
 </A>
None of these functions are currently provided. Some may be provided in a restricted form in the future.</LI>
</UL>
<H3 CLASS="Heading2">
<A NAME="pgfId=2626847">
 </A>
Execution Scheduling [POSIX Section 13]  </H3>
<H4 CLASS="Heading3">
<A NAME="pgfId=2627494">
 </A>
Functions Implemented</H4>
<PRE CLASS="CodeExample"><A NAME="pgfId=2628724"> </A>
int sched_yield(void); 
int sched_get_priority_max(int policy); 
int sched_get_priority_min(int policy); 
int sched_rr_get_interval(pid_t pid, struct timespec *t); 
int pthread_attr_setscope(pthread_attr_t *attr, int scope); 
int pthread_attr_getscope(const pthread_attr_t *attr, int *scope); 
int pthread_attr_setinheritsched(pthread_attr_t *attr, int inherit); 
int pthread_attr_getinheritsched(const pthread_attr_t *attr,
	int *inherit); 
int pthread_attr_setschedpolicy(pthread_attr_t *attr, int policy); 
int pthread_attr_getschedpolicy(const pthread_attr_t *attr,
	int *policy);
int pthread_attr_setschedparam( pthread_attr_t *attr, 
	const struct sched_param *param); 
int pthread_attr_getschedparam( const pthread_attr_t *attr,
	struct sched_param *param); 
int pthread_setschedparam(pthread_t thread, int policy,
	const struct sched_param *param); 
int pthread_getschedparam(pthread_t thread, int *policy,
	struct sched_param *param); 
int pthread_mutexattr_setprotocol( pthread_mutexattr_t *attr, int protocol);
int pthread_mutexattr_getprotocol( pthread_mutexattr_t *attr, int *protocol); 
int pthread_mutexattr_setprioceiling( pthread_mutexattr_t *attr, int prioceiling); 
int pthread_mutexattr_getprioceiling( pthread_mutexattr_t *attr,
	int *prioceiling);
int pthread_mutex_setprioceiling( pthread_mutex_t *mutex,
	int prioceiling,
	int *old_ceiling); 
int pthread_mutex_getprioceiling( pthread_mutex_t *mutex, int *prioceiling);</PRE>
<H4 CLASS="Heading3">
<A NAME="pgfId=2626849">
 </A>
Functions Omitted</H4>
<PRE CLASS="CodeExample"><A NAME="pgfId=2627512"> </A>
int sched_setparam(pid_t pid, const struct sched_param *param); 
int sched_getparam(pid_t pid, struct sched_param *param); 
int sched_setscheduler(pid_t pid, int policy,
	const struct sched_param *param); 
int sched_getscheduler(pid_t pid);</PRE>
<H4 CLASS="Heading3">
<A NAME="pgfId=2626850">
 </A>
Notes</H4>
<UL>
<P><LI>
<A NAME="pgfId=2626851">
 </A>
The functions <EM CLASS="Emphasis">
sched_setparam(),</EM>
 <EM CLASS="Emphasis">
sched_getparam(),</EM>
 <EM CLASS="Emphasis">
sched_setscheduler()</EM>
 and <EM CLASS="Emphasis">
sched_getscheduler()</EM>
 are present but always return an error.</LI>
<P><LI>
<A NAME="pgfId=2626852">
 </A>
The scheduler policy <EM CLASS="Emphasis">
SCHED_OTHER</EM>
 is equivalent to <EM CLASS="Emphasis">
SCHED_RR.</EM>
</LI>
<P><LI>
<A NAME="pgfId=2627884">
 </A>
Only <EM CLASS="Emphasis">
PTHREAD_SCOPE_SYSTEM</EM>
 is supported as a <STRONG CLASS="BoldEmphasis">
contentionscope</STRONG>
 attribute.</LI>
<P><LI>
<A NAME="pgfId=2627999">
 </A>
The default thread scheduling attributes are:<BR>
		<STRONG CLASS="BoldEmphasis">
contentionscope</STRONG>
		    PTHREAD_SCOPE_SYSTEM<BR>
		<STRONG CLASS="BoldEmphasis">
inheritsched</STRONG>
		    PTHREAD_INHERIT_SCHED<BR>
		<STRONG CLASS="BoldEmphasis">
schedpolicy</STRONG>
		    SCHED_OTHER<BR>
		<STRONG CLASS="BoldEmphasis">
schedparam.sched_priority</STRONG>
	    0    </LI>
<P><LI>
<A NAME="pgfId=2628002">
 </A>
Mutex priority inversion protection is controlled by a number of kernel configuration options. If CYGSEM_KERNEL_SYNCH_MUTEX_PRIORITY_INVERSION_PROTOCOL_INHERIT is defined then {_POSIX_THREAD_PRIO_INHERIT} will be defined and PTHREAD_PRIO_INHERIT may be set as the protocol in a <EM CLASS="Emphasis">
pthread_mutexattr_t</EM>
 object. If CYGSEM_KERNEL_SYNCH_MUTEX_PRIORITY_INVERSION_PROTOCOL_CEILING is defined then {_POSIX_THREAD_PRIO_PROTECT} will be defined and PTHREAD_PRIO_PROTECT may be set as the protocol in a <EM CLASS="Emphasis">
pthread_mutexattr_t </EM>
object. </LI>
<P><LI>
<A NAME="pgfId=2627536">
 </A>
The default attribute values set by <EM CLASS="Emphasis">
pthread_mutexattr_init()</EM>
 is to set the protocol attribute to PTHREAD_PRIO_NONE and the prioceiling attribute to zero.</LI>
</UL>
<H3 CLASS="Heading2">
<A NAME="pgfId=2626855">
 </A>
Clocks and Timers [POSIX Section 14]</H3>
<H4 CLASS="Heading3">
<A NAME="pgfId=2626856">
 </A>
Functions Implemented</H4>
<PRE CLASS="CodeExample"><A NAME="pgfId=2626857"> </A>
int clock_settime( clockid_t clock_id, const struct timespec *tp); 
int clock_gettime( clockid_t clock_id, struct timespec *tp); 
int clock_getres( clockid_t clock_id, struct timespec *tp); 
int timer_create( clockid_t clock_id, struct sigevent *evp,
	timer_t *timer_id); int timer_delete( timer_t timer_id ); 
int timer_settime( timer_t timerid, int flags,
	const struct itimerspec *value,
	struct itimerspec *ovalue ); 
int timer_gettime( timer_t timerid, struct itimerspec *value ); 
int timer_getoverrun( timer_t timerid ); 
int nanosleep( const struct timespec *rqtp, struct timespec *rmtp);</PRE>
<H4 CLASS="Heading3">
<A NAME="pgfId=2626858">
 </A>
Functions Omitted</H4>
<P CLASS="Body">
<A NAME="pgfId=2626859">
 </A>
&lt;none&gt;</P>
<H4 CLASS="Heading3">
<A NAME="pgfId=2626860">
 </A>
Notes</H4>
<UL>
<P><LI>
<A NAME="pgfId=2626861">
 </A>
Currently <EM CLASS="Emphasis">
timer_getoverrun()</EM>
 only reports timer notifications that are delayed in the timer subsystem. If they are delayed in the signal subsystem, due to signal masks for example, this is not counted as an overrun.</LI>
</UL>
<H3 CLASS="Heading2">
<A NAME="pgfId=2626862">
 </A>
Message Passing [POSIX Section 15]</H3>
<H4 CLASS="Heading3">
<A NAME="pgfId=2626863">
 </A>
Functions Implemented</H4>
<PRE CLASS="CodeExample"><A NAME="pgfId=2627577"> </A>
mqd_t mq_open( const char *name, int  oflag, ... ); 
int mq_close( mqd_t  mqdes ); 
int mq_unlink( const char *name );
int mq_send( mqd_t mqdes, const char *msg_ptr,
	size_t msg_len, unsigned int msg_prio ); 
ssize_t mq_receive( mqd_t mqdes, char *msg_ptr,
	size_t msg_len, unsigned int *msg_prio );
int mq_setattr( mqd_t mqdes, const struct mq_attr *mqstat,
	struct mq_attr *omqstat ); 
int mq_getattr( mqd_t mqdes, struct mq_attr *mqstat ); 
int mq_notify( mqd_t mqdes, const struct sigevent *notification );</PRE>
<H4 CLASS="Heading3">
<A NAME="pgfId=2626865">
 </A>
Functions Omitted</H4>
<P CLASS="Body">
<A NAME="pgfId=2626866">
 </A>
&lt;none&gt;</P>
<H4 CLASS="Heading3">
<A NAME="pgfId=2626867">
 </A>
Notes</H4>
<UL>
<P><LI>
<A NAME="pgfId=2626868">
 </A>
The presence of message queues is controlled by the CYGPKG_POSIX_MQUEUES option. Setting this will cause [_POSIX_MESSAGE_PASSING] to be defined and the message queue API to be made available.</LI>
<P><LI>
<A NAME="pgfId=2626869">
 </A>
Message queues are not currenly filesystem objects. They live in their own name and descriptor spaces.</LI>
</UL>
<H3 CLASS="Heading2">
<A NAME="pgfId=2626870">
 </A>
Thread Management [POSIX Section 16]</H3>
<H4 CLASS="Heading3">
<A NAME="pgfId=2626871">
 </A>
Functions Implemented</H4>
<PRE CLASS="CodeExample"><A NAME="pgfId=2626872"> </A>
int pthread_attr_init(pthread_attr_t *attr); 
int pthread_attr_destroy(pthread_attr_t *attr); 
int pthread_attr_setdetachstate(pthread_attr_t *attr, int detachstate); 
int pthread_attr_getdetachstate(const pthread_attr_t *attr,
	 int *detachstate); 
int pthread_attr_setstackaddr(pthread_attr_t *attr, void *stackaddr); 
int pthread_attr_getstackaddr(const pthread_attr_t *attr,
	void **stackaddr); 
int pthread_attr_setstacksize(pthread_attr_t *attr, size_t stacksize); 
int pthread_attr_getstacksize(const pthread_attr_t *attr,
	 size_t *stacksize); 
int pthread_create( pthread_t *thread, const pthread_attr_t *attr,
	void *(*start_routine)(void *),
	void *arg); pthread_t pthread_self( void ); 
int pthread_equal(pthread_t thread1, pthread_t thread2); 
void pthread_exit(void *retval) CYGBLD_ATTRIB_NORET; 
int pthread_join(pthread_t thread, void **thread_return); 
int pthread_detach(pthread_t thread); 
int pthread_once(pthread_once_t *once_control,
	void (*init_routine)(void));</PRE>
<H4 CLASS="Heading3">
<A NAME="pgfId=2626874">
 </A>
Functions Omitted</H4>
<P CLASS="Body">
<A NAME="pgfId=2626875">
 </A>
&lt;none&gt;</P>
<H4 CLASS="Heading3">
<A NAME="pgfId=2626876">
 </A>
Notes</H4>
<UL>
<P><LI>
<A NAME="pgfId=2628005">
 </A>
The default (non-scheduling) thread attributes are:<BR>
	      <STRONG CLASS="BoldEmphasis">
detachstate</STRONG>
		PTHREAD_CREATE_JOINABLE       <BR>
	      <STRONG CLASS="BoldEmphasis">
stackaddr</STRONG>
		 unset       <BR>
	      <STRONG CLASS="BoldEmphasis">
stacksize</STRONG>
		 unset</LI>
<P><LI>
<A NAME="pgfId=2626878">
 </A>
Dynamic thread stack allocation is only provided if there is an implementation of <EM CLASS="Emphasis">
malloc()</EM>
 configured (a package implements the CYGINT_MEMALLOC_MALLOC_ALLOCATORS interface). If there is no malloc() available, then the thread creator must supply a stack. If only a stack address is supplied then the stack is assumed to be PTHREAD_STACK_MIN bytes long. This size is seldom useful for any but the most trivial of threads. If a different sized stack is used, both the stack address and stack size must be supplied.</LI>
<P><LI>
<A NAME="pgfId=2626879">
 </A>
The value of PTHREAD_THREADS_MAX is supplied by the CYGNUM_POSIX_PTHREAD_THREADS_MAX option.</LI>
<P><LI>
<A NAME="pgfId=2627634">
 </A>
When the POSIX package is installed, the thread that calls <EM CLASS="Emphasis">
main()</EM>
 is initialized as a POSIX thread. The properties of that thread are controlled by the following options: </LI>
</UL>
<P CLASS="BodyListFollow">
<A NAME="pgfId=2627635">
 </A>
CYGNUM_POSIX_MAIN_DEFAULT_STACK_SIZEsize of thread's stack<BR>
CYGNUM_POSIX_MAIN_DEFAULT_PRIORITY	  default POSIX priority of thread</P>
<H3 CLASS="Heading2">
<A NAME="pgfId=2627636">
 </A>
Thread-Specific Data [POSIX Section 17]</H3>
<H4 CLASS="Heading3">
<A NAME="pgfId=2627637">
 </A>
Functions Implemented</H4>
<PRE CLASS="CodeExample"><A NAME="pgfId=2626882"> </A>
int pthread_key_create(pthread_key_t *key,
	void (*destructor)(void *)); 
int pthread_setspecific(pthread_key_t key, const void *pointer); 
void *pthread_getspecific(pthread_key_t key); 
int pthread_key_delete(pthread_key_t key);</PRE>
<H4 CLASS="Heading3">
<A NAME="pgfId=2626883">
 </A>
Functions Omitted</H4>
<P CLASS="Body">
<A NAME="pgfId=2626884">
 </A>
&lt;none&gt;</P>
<H4 CLASS="Heading3">
<A NAME="pgfId=2626885">
 </A>
Notes</H4>
<UL>
<P><LI>
<A NAME="pgfId=2626886">
 </A>
The value of PTHREAD_DESTRUCTOR_ITERATIONS is provided by the CYGNUM_POSIX_PTHREAD_DESTRUCTOR_ITERATIONS option.</LI>
<P><LI>
<A NAME="pgfId=2626887">
 </A>
The value of PTHREAD_KEYS_MAX is provided by the CYGNUM_POSIX_PTHREAD_KEYS_MAX option.  </LI>
</UL>
<H3 CLASS="Heading2">
<A NAME="pgfId=2626888">
 </A>
Thread Cancellation [POSIX Section 18]</H3>
<H4 CLASS="Heading3">
<A NAME="pgfId=2626889">
 </A>
Functions Implemented</H4>
<PRE CLASS="CodeExample"><A NAME="pgfId=2626890"> </A>
int pthread_cancel(pthread_t thread); 
int pthread_setcancelstate(int state, int *oldstate); 
int pthread_setcanceltype(int type, int *oldtype); 
void pthread_testcancel(void); 
void pthread_cleanup_push( void (*routine)(void *), void *arg); 
void pthread_cleanup_pop( int execute);</PRE>
<H4 CLASS="Heading3">
<A NAME="pgfId=2626891">
 </A>
Functions Omitted</H4>
<P CLASS="Body">
<A NAME="pgfId=2626892">
 </A>
&lt;none&gt;</P>
<H4 CLASS="Heading3">
<A NAME="pgfId=2626893">
 </A>
Notes</H4>
<UL>
<P><LI>
<A NAME="pgfId=2626894">
 </A>
Asynchronous cancellation is only partially implemented. In particular, cancellation may occur in unexpected places in some functions. Extra work will be needed to fix this.</LI>
</UL>
<H4 CLASS="Heading3">
<A NAME="pgfId=2626896">
 </A>
Non-POSIX Functions</H4>
<P CLASS="Body">
<A NAME="pgfId=2626897">
 </A>
In addition to the standard POSIX functions defined above, the following non-POSIX are defined in the FILEIO package.</P>
<H5 CLASS="Heading4">
<A NAME="pgfId=2626898">
 </A>
General I/O Functions</H5>
<PRE CLASS="CodeExample"><A NAME="pgfId=2626899"> </A>
int ioctl( int fd, CYG_ADDRWORD com, CYG_ADDRWORD data ); 
int select( int nfd, fd_set *in, fd_set *out, fd_set *ex, 	    struct timeval *tv);     </PRE>
<H5 CLASS="Heading4">
<A NAME="pgfId=2626900">
 </A>
Socket Functions	</H5>
<PRE CLASS="CodeExample"><A NAME="pgfId=2627718"> </A>
int socket( int domain, int type, int protocol); 
int bind( int s, const struct sockaddr *sa, unsigned int len); 
int listen( int s, int len); 
int accept( int s, struct sockaddr *sa, socklen_t *addrlen); 
int connect( int s, const struct sockaddr *sa, socklen_t len); 
int getpeername( int s, struct sockaddr *sa, socklen_t *len); 
int getsockname( int s, struct sockaddr *sa, socklen_t *len); 
int setsockopt( int s, int level, int optname, const void *optval, 	
	socklen_t optlen); 
int getsockopt( int s, int level, int optname, void *optval, 	
	socklen_t *optlen); 
ssize_t recvmsg( int s, struct msghdr *msg, int flags); 
ssize_t recvfrom( int s, void *buf, size_t len, int flags, 
	struct sockaddr *from, socklen_t *fromlen); 
ssize_t recv( int s, void *buf, size_t len, int flags); 
ssize_t sendmsg( int s, const struct msghdr *msg, int flags); 
ssize_t sendto( int s, const void *buf, size_t len, int flags, 
	const struct sockaddr *to, socklen_t tolen); 
ssize_t send( int s, const void *buf, size_t len, int flags); 
int shutdown( int s, int how);</PRE>
<H4 CLASS="Heading3">
<A NAME="pgfId=2626901">
 </A>
Notes</H4>
<UL>
<P><LI>
<A NAME="pgfId=2626902">
 </A>
The precise behaviour of these function depends mainly on the functionality of the underlying filesystem or network stack to which they are applied.</LI>
</UL>
<H3 CLASS="Heading2">
<A NAME="pgfId=2626903">
 </A>
References/Bibliography</H3>
<TABLE>
<TR>
    <TD ROWSPAN="1" COLSPAN="1" valign="top"> 
      <P CLASS="CellBody"> <A NAME="pgfId=2629071"> </A> [ELIX]</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=2629073">
 </A>
<EM CLASS="Emphasis">
Embedded Linux API Specification</EM>
<A HREF="http://sources.redhat.com/elix" CLASS="URL">
;    <BR>
http://sources.redhat.com/elix</A>
</P>
</TD>
</TR>
<TR>
    <TD ROWSPAN="1" COLSPAN="1" valign="top"> 
      <P CLASS="CellBody"> <A NAME="pgfId=2629075"> </A> [Lewine]</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=2629077">
 </A>
Donald A. Lewine; Posix Programmer's Guide: Writing Portable Unix Programs With the POSIX.1 Standard<BR>
O'Reilly &amp; 	 Associates; ISBN: 0937175730.</P>
</TD>
</TR>
<TR>
    <TD ROWSPAN="1" COLSPAN="1" valign="top"> 
      <P CLASS="CellBody"> <A NAME="pgfId=2629079"> </A> [Lewis1]</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=2629081">
 </A>
Bil Lewis, Daniel J. Berg (Contributor); <EM CLASS="Emphasis">
Threads Primer: A Guide to Multithreaded Programming</EM>
 <BR>
Prentice Hall; ISBN: 013443698. 	 </P>
</TD>
</TR>
<TR>
    <TD ROWSPAN="1" COLSPAN="1" valign="top"> 
      <P CLASS="CellBody"> <A NAME="pgfId=2629083"> </A> [Lewis2]</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=2629085">
 </A>
Bil Lewis, Daniel J. Berg; <EM CLASS="Emphasis">
Multithreaded Programming With Pthreads<BR>
</EM>
Prentice Hall Computer Books; ISBN: 0136807291.</P>
</TD>
</TR>
<TR>
    <TD ROWSPAN="1" COLSPAN="1" valign="top"> 
      <P CLASS="CellBody"> <A NAME="pgfId=2629087"> </A> [Nichols]</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=2629089">
 </A>
Bradford Nichols, Dick Buttlar, Jacqueline Proulx Farrell, Jackie Farrell; <EM CLASS="Emphasis">
Pthreads Programming: A POSIX Standard for Better Multiprocessing<BR>
</EM>
(O'Reilly Nutshell); O'Reilly &amp; Associates; ISBN: 1565921151.</P>
</TD>
</TR>
<TR>
    <TD ROWSPAN="1" COLSPAN="1" valign="top"> 
      <P CLASS="CellBody"> <A NAME="pgfId=2629091"> </A> [Norton]</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=2629093">
 </A>
Scott J. Norton, Mark D. Depasquale; <EM CLASS="Emphasis">
Thread Time: The MultiThreaded Programming Guide <BR>
</EM>
Prentice Hall; ISBN: 0131900676.</P>
</TD>
</TR>
<TR>
    <TD ROWSPAN="1" COLSPAN="1" valign="top"> 
      <P CLASS="CellBody"> <A NAME="pgfId=2629095"> </A> [POSIX]</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=2629097">
 </A>
<EM CLASS="Emphasis">
Portable Operating System Interface(POSIX) - Part 1: System Application Programming Interface (API)[C Language]</EM>
 <BR>
ISO/IEC 9945-1:1996, IEEE.</P>
</TD>
</TR>
<TR>
    <TD ROWSPAN="1" COLSPAN="1" valign="top"> 
      <P CLASS="CellBody"> <A NAME="pgfId=2629099"> </A> [SUS2]</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=2629101">
 </A>
<EM CLASS="Emphasis">
Open Group; Single Unix Specification, Version 2</EM>
<A HREF="http://www.opengroup.org/public/pubs/online/7908799/index.html" CLASS="URL">
    <BR>
http://www.opengroup.org/public/pubs/online/7908799/index.html</A>
</P>
</TD>
</TR>
</TABLE>
<P CLASS="BodyListFollow">
<A NAME="pgfId=2629040">
 </A>
</P>
<HR ALIGN="center"><TABLE STYLE="ECOS"WIDTH="100%" BORDER="0" ALIGN="LEFT" CELLPADDING="3"><TR><TH COLSPAN="2" ALIGN="center"><P CLASS="Gotos">POSIX Standard Support </P></TH></TR><TR><TD WIDTH="47%" ALIGN="center">
      <P CLASS="Gotos"><A HREF="ecos-elix.html">To&nbsp;copyright information</A></P>
    </TD><TD WIDTH="47%" ALIGN="center">
      <P CLASS="Gotos"><A HREF="ecos-elix.1.html">To&nbsp;Contents</A></P>
    </TD></TR></TABLE></BODY>
</HTML>
