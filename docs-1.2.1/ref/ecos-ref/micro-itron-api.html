<HTML
><HEAD
><TITLE
>ITRON API</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.33"><LINK
REL="HOME"
TITLE="eCos Reference
Manual"
HREF="ecos-ref.html"><LINK
REL="UP"
TITLE="Kernel APIs"
HREF="kernel-apis.html"><LINK
REL="PREVIOUS"
TITLE="Flags"
HREF="flags.html"><LINK
REL="NEXT"
TITLE="Task-Dependent Synchronization Functions"
HREF="task-dependent-synchronization-functions.html"></HEAD
><BODY
><DIV
CLASS="NAVHEADER"
><TABLE
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="3"
ALIGN="center"
><SPAN
CLASS="TRADEMARK"
>eCos</SPAN
><SUP
><FONT
SIZE="-4"
>TM</FONT
></SUP
> Reference
Manual</TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="bottom"
><A
HREF="flags.html"
>Prev</A
></TD
><TD
WIDTH="80%"
ALIGN="center"
VALIGN="bottom"
></TD
><TD
WIDTH="10%"
ALIGN="right"
VALIGN="bottom"
><A
HREF="task-dependent-synchronization-functions.html"
>Next</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><DIV
CLASS="CHAPTER"
><H1
><A
NAME="MICRO-ITRON-API"
>Chapter 6. µITRON API</A
></H1
><DIV
CLASS="TOC"
><DL
><DT
><B
>Table of Contents</B
></DT
><DT
><A
HREF="micro-itron-api.html#TASK-MANAGEMENT-FUNCTIONS"
>Task Management Functions</A
></DT
><DT
><A
HREF="task-dependent-synchronization-functions.html"
>Task-Dependent Synchronization Functions</A
></DT
><DT
><A
HREF="synchronization-and-communication-functions.html"
>Synchronization and Communication
Functions</A
></DT
><DT
><A
HREF="x2950.html"
>Extended
Synchronization and Communication Functions</A
></DT
><DT
><A
HREF="interrupt-management-functions.html"
>Interrupt
management functions</A
></DT
><DT
><A
HREF="memory-pool-management-functions.html"
>Memory
pool Management Functions</A
></DT
><DT
><A
HREF="time-management-functions.html"
>Time Management Functions</A
></DT
><DT
><A
HREF="system-management-functions.html"
>System Management Functions</A
></DT
><DT
><A
HREF="network-support-functions.html"
>Network Support Functions</A
></DT
></DL
></DIV
><P
>TheµITRON
specification defines a highly flexible operating system architecture designed
specifically for application in embedded systems. The specification addresses
features which are common to the majority of processor architectures
and deliberately avoids virtualization which would adversely impact
real-time performance. The µITRON specification may be
implemented on many hardware platforms and provides significant
advantages by reducing the effort involved in understanding and
porting application software to new processor architectures. </P
><P
>Several revisions of the µITRON specification exist.
In this release, <SPAN
CLASS="PRODUCTNAME"
>eCos</SPAN
> supports the µITRON
version 3.02 specification, with complete &#8220;Standard functionality&#8221; (level
S), plus many &#8220;Extended&#8221; (level E) functions.
The definitive reference on µITRON is Dr. Sakamura&#8217;s
book <I
CLASS="CITETITLE"
>µITRON 3.0, An Open and Portable Real-Time
Operating System for Embedded Systems</I
>. If you have purchased
the <SPAN
CLASS="PRODUCTNAME"
>eCos</SPAN
> Developer"s Kit, you
will have received a copy of this book. Otherwise, the book can
be purchased from the IEEE Press, and an ASCII version of the standard
can be found online at<A
HREF="http://www.itron.gr.jp/"
TARGET="_top"
>http://www.itron.gr.jp/</A
>(The
old address <A
HREF="http://tron.um.u-tokyo.ac.jp/TRON/ITRON/"
TARGET="_top"
>http://tron.um.u-tokyo.ac.jp/TRON/ITRON/</A
>still
exists as a mirror site.) </P
><P
>The <SPAN
CLASS="PRODUCTNAME"
>eCos</SPAN
> kernel implements the
functionality used by the µITRON compatibility subsystem.
The configuration of the kernel influences the behavior of µITRON programs.</P
><P
>In particular, the default configuration has time slicing
(also known as round-robin scheduling) switched on; this means that
a task can be moved from <TT
CLASS="LITERAL"
>RUN</TT
> state to <TT
CLASS="LITERAL"
>READY</TT
> state
at any time, in order that one of its peers may run. This is not
strictly conformant to the µITRON specification, which
states that timeslicing may be implemented by periodically issuing
a <TT
CLASS="LITERAL"
>rot_rdq(0)</TT
> call from within a periodic
task or cyclic handler; otherwise it is expected that a task runs
until it is pre-empted in consequence of synchronization or communications
calls it makes, or the effects of an interrupt or other external
event on a higher priority task cause that task to become <TT
CLASS="LITERAL"
>READY</TT
>.
To disable timeslicing functionality in the kernel and µITRON
compatibility environment, please disable the <TT
CLASS="PARAMETER"
><I
>CYGSEM_KERNEL_SCHED_TIMESLICE</I
></TT
> configuration
option in the kernel package. A description of kernel scheduling
is in <A
HREF="thread-operations.html"
>the section called <I
>Thread operations</I
> in Chapter 5</A
>,
and the configuration options for scheduling are detailed in <A
HREF="c-cygpkg-kernel-sched.html"
>the section called <I
>Component: Kernel schedulers</I
> in Chapter 17</A
>. </P
><P
>For another example, the semantics of task queueing when waiting
on a synchronization object depend solely on the way the underlying
kernel is configured. As discussed above, the multi-level queue
scheduler is the only one which is µITRON compliant, and
it queues waiting tasks in FIFO order. Future releases of that scheduler might
be configurable to support priority ordering of task queues. Other
schedulers might be different again: for example the bitmap scheduler
can be used with the µITRON compatibility layer, even though
it only allows one task at each priority and as such is not µITRON
compliant, but it supports only priority ordering of task queues.
So which queueing scheme is supported is not really a property of
the µITRON compatibility layer; it depends on the kernel. </P
><P
>In this version of the µITRON compatibility layer,
the calls to disable and enable scheduling and interrupts (<TT
CLASS="FUNCTION"
><B
>dis_dsp()</B
></TT
>, <TT
CLASS="FUNCTION"
><B
>ena_dsp()</B
></TT
>, <TT
CLASS="FUNCTION"
><B
>loc_cpu()</B
></TT
> and <TT
CLASS="FUNCTION"
><B
>unl_cpu()</B
></TT
>)
call underlying kernel functions; in particular, the <TT
CLASS="FUNCTION"
><B
>xxx_dsp()</B
></TT
> functions
lock the scheduler entirely, which prevents dispatching of DSRs;
functions implemented by DSRs include clock counters and alarm timers.
Thus time &#8220;stops&#8221; while dispatching is disabled
with <TT
CLASS="FUNCTION"
><B
>dis_dsp()</B
></TT
>. </P
><P
>Like all parts of the <SPAN
CLASS="PRODUCTNAME"
>eCos</SPAN
> system,
the detailed semantics of the µITRON layer are dependent
on its configuration and the configuration of other components that
it uses. The µITRON configuration options are all defined
in the file <TT
CLASS="FILENAME"
>pkgconf/uitron.h</TT
>, and can
be set using the configuration tool or editing this file by hand. </P
><P
>An important configuration option for the µITRON
compatibility layer is <TT
CLASS="PARAMETER"
><I
>CYGSEM_UITRON_BAD_PARAMS_RETURN_ERRORS</I
></TT
> (see <A
HREF="o-cygsem-uitron-bad-params-return-errors.html"
>the section called <I
>Option:
Return Error Codes for Bad Params</I
> in Chapter 18</A
>), which allows a lot of the error
checking code in the µITRON compatibility layer to be removed;
of course this leaves a program open to undetected errors, so it
should only be used once an application is fully debugged and tested.
Its benefits include reduced code size and faster execution. However,
it affects the API significantly, in that with this option enabled,
bad calls do not return errors, but either cause an assert failure
(if that is itself enabled: see <A
HREF="c-cygpkg-infra-debug.html#C-CYGDBG-USE-ASSERTS"
>the section called <I
>Component: Use asserts</I
> in Chapter 16</A
>) or malfunction internally. There
is discussion in more detail about this in each section below.</P
><P
>We now give a brief description of the µITRON functions
which are implemented in this release. Note that all C and C++ source
files should have the following <TT
CLASS="LITERAL"
>#include</TT
> statement: </P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>&#13;#include &#60;cyg/compat/uitron/uit_func.h&#62;</PRE
></TD
></TR
></TABLE
><DIV
CLASS="SECT1"
><H1
CLASS="SECT1"
><A
NAME="TASK-MANAGEMENT-FUNCTIONS"
>Task Management Functions</A
></H1
><P
>The following functions are fully supported in this release: </P
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><CODE
CLASS="FUNCDEF"
>ER <B
CLASS="FSFUNC"
>sta_tsk</B
></CODE
>(ID <VAR
CLASS="PDPARAM"
>tskid</VAR
>, INT <VAR
CLASS="PDPARAM"
>stacd</VAR
>);<P
></P
></DIV
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><CODE
CLASS="FUNCDEF"
>void <B
CLASS="FSFUNC"
>ext_tsk</B
></CODE
>(void);<P
></P
></DIV
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><CODE
CLASS="FUNCDEF"
>void <B
CLASS="FSFUNC"
>exd_tsk</B
></CODE
>(void);<P
></P
></DIV
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><CODE
CLASS="FUNCDEF"
>ER <B
CLASS="FSFUNC"
>dis_dsp</B
></CODE
>(void);<P
></P
></DIV
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><CODE
CLASS="FUNCDEF"
>ER <B
CLASS="FSFUNC"
>ena_dsp</B
></CODE
>(void);<P
></P
></DIV
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><CODE
CLASS="FUNCDEF"
>ER <B
CLASS="FSFUNC"
>chg_pri</B
></CODE
>(ID <VAR
CLASS="PDPARAM"
>tskid</VAR
>,  PRI <VAR
CLASS="PDPARAM"
>tskpri</VAR
>);<P
></P
></DIV
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><CODE
CLASS="FUNCDEF"
>ER <B
CLASS="FSFUNC"
>rot_rdq</B
></CODE
>(PRI <VAR
CLASS="PDPARAM"
>tskpri</VAR
>);<P
></P
></DIV
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><CODE
CLASS="FUNCDEF"
>ER <B
CLASS="FSFUNC"
>get_tid</B
></CODE
>(ID *<VAR
CLASS="PDPARAM"
>p_tskid</VAR
>);<P
></P
></DIV
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><CODE
CLASS="FUNCDEF"
>ER <B
CLASS="FSFUNC"
>ref_tsk</B
></CODE
>(T_RTSK *<VAR
CLASS="PDPARAM"
>pk_rtsk</VAR
>, ID <VAR
CLASS="PDPARAM"
>tskid</VAR
>);<P
></P
></DIV
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><CODE
CLASS="FUNCDEF"
>ER <B
CLASS="FSFUNC"
>ter_tsk</B
></CODE
>(ID <VAR
CLASS="PDPARAM"
>tskid</VAR
>);<P
></P
></DIV
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><CODE
CLASS="FUNCDEF"
>ER <B
CLASS="FSFUNC"
>rel_wai</B
></CODE
>(ID <VAR
CLASS="PDPARAM"
>tskid</VAR
>);<P
></P
></DIV
><P
>The following two functions are supported in this release,
when enabled with the configuration option CYGPKG_UITRON_TASKS_CREATE_DELETE
(see <A
HREF="c-cygpkg-uitron-tasks.html#C-CYGPKG-UITRON-TASKS-CREATE-DELETE"
>the section called <I
>Component:
Support create and delete</I
> in Chapter 18</A
>), with some restrictions:</P
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><CODE
CLASS="FUNCDEF"
>ER <B
CLASS="FSFUNC"
>cre_tsk</B
></CODE
>(ID <VAR
CLASS="PDPARAM"
>tskid</VAR
>, T_CTSK *<VAR
CLASS="PDPARAM"
>pk_ctsk</VAR
>);<P
></P
></DIV
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><CODE
CLASS="FUNCDEF"
>ER <B
CLASS="FSFUNC"
>del_tsk</B
></CODE
>(ID <VAR
CLASS="PDPARAM"
>tskid</VAR
>);<P
></P
></DIV
><P
>These functions are restricted as follows:</P
><P
>Because of the static initialization facilities provided for
system objects, a task is allocated stack space statically in the
configuration (see <A
HREF="c-cygpkg-uitron-tasks.html"
>the section called <I
>Component: Tasks</I
> in Chapter 18</A
>). So while tasks can be created and
deleted, the same stack space is used for that task (task ID number)
each time. Thus the stack size (pk_ctsk-&#62;stksz)
requested in <TT
CLASS="FUNCTION"
><B
>cre_tsk()</B
></TT
> is checked for being
less than that which was statically allocated, and otherwise ignored.
This ensures that the new task will have enough stack to run. For this
reason <TT
CLASS="FUNCTION"
><B
>del_tsk()</B
></TT
> does not in any sense free
the memory that was in use for the task"s stack. </P
><P
>The task attributes (pk_ctsk-&#62;tskatr) are
ignored; current versions of <SPAN
CLASS="PRODUCTNAME"
>eCos</SPAN
> do
not need to know whether a task is written in assembler or C/C++ so
long as the procedure call standard appropriate to the CPU is followed.</P
><P
>Extended information (pk_ctsk-&#62;exinf) is
ignored.</P
><H2
CLASS="BRIDGEHEAD"
>Error checking</H2
><P
>For all these calls, an invalid task id (tskid) (less than
1 or greater than the number of configured tasks) only returns E_ID
when bad params return errors (<TT
CLASS="PARAMETER"
><I
>CYGSEM_UITRON_BAD_PARAMS_RETURN_ERRORS</I
></TT
> is
enabled, see above).</P
><P
>Similarly, the following conditions are only checked for,
and only return errors if <TT
CLASS="PARAMETER"
><I
>CYGSEM_UITRON_BAD_PARAMS_RETURN_ERRORS</I
></TT
> is
enabled:</P
><P
></P
><UL
><LI
><P
>pk_crtk in <TT
CLASS="FUNCTION"
><B
>cre_tsk()</B
></TT
> is
a valid pointer, otherwise return E_PAR</P
></LI
><LI
><P
><TT
CLASS="FUNCTION"
><B
>ter_tsk()</B
></TT
> or <TT
CLASS="FUNCTION"
><B
>rel_wai()</B
></TT
> on
the calling task returns E_OBJ</P
></LI
><LI
><P
>the CPU is not locked already in <TT
CLASS="FUNCTION"
><B
>dis_dsp()</B
></TT
> and <TT
CLASS="FUNCTION"
><B
>ena_dsp()</B
></TT
>;
returns E_CTX</P
></LI
><LI
><P
>priority level in <TT
CLASS="FUNCTION"
><B
>chg_pri()</B
></TT
> and <TT
CLASS="FUNCTION"
><B
>rot_rdq()</B
></TT
> is
checked for validity, E_PAR</P
></LI
><LI
><P
>return value pointer in <TT
CLASS="FUNCTION"
><B
>get_tid()</B
></TT
> and <TT
CLASS="FUNCTION"
><B
>ref_tsk()</B
></TT
> is
a valid pointer, or E_PAR</P
></LI
></UL
><P
>The following conditions are checked for, and return error
codes if appropriate, regardless of the setting of <TT
CLASS="PARAMETER"
><I
>CYGSEM_UITRON_BAD_PARAMS_RETURN_ERRORS</I
></TT
>:</P
><P
></P
><UL
><LI
><P
>When create and delete functions <TT
CLASS="FUNCTION"
><B
>cre_tsk()</B
></TT
> and <TT
CLASS="FUNCTION"
><B
>del_tsk()</B
></TT
> are
supported, all calls which use a valid task ID number check that
the task exists; if not, E_NOEXS is returned</P
></LI
><LI
><P
>When supported, <TT
CLASS="FUNCTION"
><B
>cre_tsk()</B
></TT
>:
the task must not already exist; otherwise E_OBJ</P
></LI
><LI
><P
>When supported, <TT
CLASS="FUNCTION"
><B
>cre_tsk()</B
></TT
>:
the requested stack size must not be larger than that statically
configured for the task; see <A
HREF="c-cygpkg-uitron-tasks.html#O-CYGDAT-UITRON-TASK-INITIALIZERS"
>the section called <I
>Option: Static
initializers</I
> in Chapter 18</A
> and <A
HREF="c-cygpkg-uitron-tasks.html#O-CYGNUM-UITRON-STACK-SIZE"
>the section called <I
>Option: Default
stack size</I
> in Chapter 18</A
>.
Else E_NOMEM</P
></LI
><LI
><P
>When supported, <TT
CLASS="FUNCTION"
><B
>del_tsk()</B
></TT
>:
the underlying <SPAN
CLASS="PRODUCTNAME"
>eCos</SPAN
> thread must not be
running - this would imply either a bug or some program bypassing
the µITRON compatibility layer and manipulating the thread
directly. E_OBJ</P
></LI
><LI
><P
><TT
CLASS="FUNCTION"
><B
>sta_tsk()</B
></TT
>: the task must be
dormant, else E_OBJ</P
></LI
><LI
><P
><TT
CLASS="FUNCTION"
><B
>ter_tsk()</B
></TT
>: the task must not
be dormant, else E_OBJ</P
></LI
><LI
><P
><TT
CLASS="FUNCTION"
><B
>chg_pri()</B
></TT
>: the task must not
be dormant, else E_OBJ</P
></LI
><LI
><P
><TT
CLASS="FUNCTION"
><B
>rel_wai()</B
></TT
>: the task must be
in <TT
CLASS="LITERAL"
>WAIT<TT
CLASS="LITERAL"
> or </TT
>WAIT-SUSPEND</TT
> state,
else E_OBJ</P
></LI
></UL
></DIV
></DIV
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="flags.html"
>Prev</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="ecos-ref.html"
>Home</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="task-dependent-synchronization-functions.html"
>Next</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>Flags</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="kernel-apis.html"
>Up</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>Task-Dependent Synchronization Functions</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>