<HTML
><HEAD
><TITLE
>Serial driver details</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.33"><LINK
REL="HOME"
TITLE="eCos Reference
Manual"
HREF="ecos-ref.html"><LINK
REL="UP"
TITLE="IO Package (Device Drivers)"
HREF="ecos-device-drivers.html"><LINK
REL="PREVIOUS"
TITLE="User
API"
HREF="io-package-user-api.html"><LINK
REL="NEXT"
TITLE="tty driver"
HREF="tty-driver.html"></HEAD
><BODY
><DIV
CLASS="NAVHEADER"
><TABLE
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="3"
ALIGN="center"
><SPAN
CLASS="TRADEMARK"
>eCos</SPAN
><SUP
><FONT
SIZE="-4"
>TM</FONT
></SUP
> Reference
Manual</TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="bottom"
><A
HREF="io-package-user-api.html"
>Prev</A
></TD
><TD
WIDTH="80%"
ALIGN="center"
VALIGN="bottom"
></TD
><TD
WIDTH="10%"
ALIGN="right"
VALIGN="bottom"
><A
HREF="tty-driver.html"
>Next</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><DIV
CLASS="CHAPTER"
><H1
><A
NAME="SERIAL-DRIVER-DETAILS"
>Chapter 11. Serial driver details</A
></H1
><DIV
CLASS="TOC"
><DL
><DT
><B
>Table of Contents</B
></DT
><DT
><A
HREF="serial-driver-details.html#SIMPLE-SERIAL-DRIVER"
>&#8220;simple serial&#8221; driver</A
></DT
><DT
><A
HREF="tty-driver.html"
>&#8220;tty&#8221; driver</A
></DT
></DL
></DIV
><P
>Two different classes of serial drivers are provided as a
standard part of the eCos system. These are described as &#8220;simple
serial&#8221; (serial) and &#8220;tty-like&#8221; (tty). </P
><DIV
CLASS="SECT1"
><H1
CLASS="SECT1"
><A
NAME="SIMPLE-SERIAL-DRIVER"
>&#8220;simple serial&#8221; driver</A
></H1
><P
>Use the include file <TT
CLASS="FILENAME"
>cyg/io/serialio.h</TT
> for
this driver. </P
><P
>The simple serial driver is capable of
sending and receiving blocks of raw data to a serial device. Controls
are provided to configure the actual hardware, but there is no manipulation
of the data by this driver. </P
><P
>There may be many instances of this driver in a given system,
one for each serial channel. Each channel corresponds to a physical
device and there will typically be a device module created for this
purpose. The device modules themselves are configurable, allowing
specification of the actual hardware details, as well as such details
as whether the channel should be buffered by the serial driver,
etc. </P
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN4560"
>Runtime configuration</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>typedef struct {
 cyg_serial_baud_rate_t baud;
 cyg_serial_stop_bits_t stop;
 cyg_serial_parity_t parity;
 cyg_serial_word_length_t word_length;
 cyg_uint32 flags;
} cyg_serial_info_t;
	</PRE
></TD
></TR
></TABLE
><P
>The field &#8216;word_length&#8217; contains
the number of data bits per word (character). This must be one of
the values:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
> CYGNUM_SERIAL_WORD_LENGTH_5
 CYGNUM_SERIAL_WORD_LENGTH_6
 CYGNUM_SERIAL_WORD_LENGTH_7
 CYGNUM_SERIAL_WORD_LENGTH_8
	</PRE
></TD
></TR
></TABLE
><P
>The field &#8216;baud&#8217; contains
a baud rate selection. This must be one of the values:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
> CYGNUM_SERIAL_BAUD_50
 CYGNUM_SERIAL_BAUD_75
 CYGNUM_SERIAL_BAUD_110
 CYGNUM_SERIAL_BAUD_134_5
 CYGNUM_SERIAL_BAUD_150
 CYGNUM_SERIAL_BAUD_200
 CYGNUM_SERIAL_BAUD_300
 CYGNUM_SERIAL_BAUD_600
 CYGNUM_SERIAL_BAUD_1200
 CYGNUM_SERIAL_BAUD_1800
 CYGNUM_SERIAL_BAUD_2400
 CYGNUM_SERIAL_BAUD_3600
 CYGNUM_SERIAL_BAUD_4800
 CYGNUM_SERIAL_BAUD_7200
 CYGNUM_SERIAL_BAUD_9600
 CYGNUM_SERIAL_BAUD_14400
 CYGNUM_SERIAL_BAUD_19200
 CYGNUM_SERIAL_BAUD_38400
 CYGNUM_SERIAL_BAUD_57600
 CYGNUM_SERIAL_BAUD_115200
 CYGNUM_SERIAL_BAUD_234000
	</PRE
></TD
></TR
></TABLE
><P
>The field &#8216;stop&#8217; contains
the number of stop bits. This must be one of the values:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
> CYGNUM_SERIAL_STOP_1
 CYGNUM_SERIAL_STOP_1_5
 CYGNUM_SERIAL_STOP_2
	</PRE
></TD
></TR
></TABLE
><DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
><B
>Note: </B
>On most hardware, a selection of 1.5 stop bits is only valid
if the word (character) length is 5.</P
></BLOCKQUOTE
></DIV
><P
>The field &#8216;parity&#8217; contains
the parity mode. This must be one of the values: </P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
> CYGNUM_SERIAL_PARITY_NONE
 CYGNUM_SERIAL_PARITY_EVEN
 CYGNUM_SERIAL_PARITY_ODD
 CYGNUM_SERIAL_PARITY_MARK
 CYGNUM_SERIAL_PARITY_SPACE
	</PRE
></TD
></TR
></TABLE
><P
>The field &#8216;flags&#8217; is
a bitmask which controls the behavior of the serial device driver.
It should be built from the values <TT
CLASS="FUNCTION"
><B
>CYG_SERIAL_FLAGS_xxx</B
></TT
> defined
below: </P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>#define CYG_SERIAL_FLAGS_RTSCTS 0x0001
	</PRE
></TD
></TR
></TABLE
><P
>If this bit is set then the port is placed in &#8220;hardware
handshake&#8221; mode. In this mode, the CTS and RTS pins control
when data is allowed to be sent/received at the port. This
bit is ignored if the hardware does not support this level of handshake. </P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN4597"
>API details</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
> <TT
CLASS="FUNCTION"
><B
>cyg_io_write</B
></TT
>(handle, buf, len)
	</PRE
></TD
></TR
></TABLE
><P
>Send the data from &#8216;buf&#8217; to the device.
The driver maintains a buffer to hold the data and will return as
soon as there is space in the buffer and the entire contents of &#8216;buf&#8217; have
been consumed. The data is not modified at all while it is being
buffered. The size of the intermediate buffer is configurable within
the interface module. </P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
> <TT
CLASS="FUNCTION"
><B
>cyg_io_read</B
></TT
>(handle, buf, len)
	</PRE
></TD
></TR
></TABLE
><P
>Receive data into the specified buffer from the device. The
total &#8216;len&#8217; number of characters will be received
before this call completes. No manipulation of the data is performed
before being transferred. An interrupt driven interface module will
support data arriving when no read is pending by buffering the data
in the serial channel. Again, this buffering is completely configurable. </P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
> <TT
CLASS="FUNCTION"
><B
>cyg_io_get_config</B
></TT
>(handle, key, buf, len)
	</PRE
></TD
></TR
></TABLE
><P
>This function returns current [runtime] information
about the device and/or driver. </P
><P
></P
><DL
><DT
>Key:</DT
><DD
><P
>CYG_IO_GET_CONFIG_SERIAL_INFO</P
></DD
><DT
>Buf type:</DT
><DD
><P
>cyg_serial_info_t</P
></DD
><DT
>Function:</DT
><DD
><P
>This function retrieves the current state of the
driver and hardware. This information contains fields for hardware
baud rate, number of stop bits, and parity mode. It also includes
a set of flags that control the port, such as hardware flow control.</P
></DD
></DL
><P
></P
><DL
><DT
>Key:</DT
><DD
><P
>CYG_IO_GET_CONFIG_SERIAL_OUTPUT_DRAIN</P
></DD
><DT
>Buf type:</DT
><DD
><P
>void *</P
></DD
><DT
>Function:</DT
><DD
><P
>This function waits for any buffered output to complete.
This function only completes when there is no more data remaining
to be sent to the device.</P
></DD
></DL
><P
></P
><DL
><DT
>Key:</DT
><DD
><P
>CYG_IO_GET_CONFIG_SERIAL_OUTPUT_FLUSH</P
></DD
><DT
>Buf type:</DT
><DD
><P
>void *</P
></DD
><DT
>Function:</DT
><DD
><P
>This function discards any buffered output for the
device.</P
></DD
></DL
><P
></P
><DL
><DT
>Key:</DT
><DD
><P
>CYG_IO_GET_CONFIG_SERIAL_INPUT_DRAIN</P
></DD
><DT
>Buf type:</DT
><DD
><P
>void *</P
></DD
><DT
>Function:</DT
><DD
><P
>This function discards any buffered input for the
device.</P
></DD
></DL
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
> <TT
CLASS="FUNCTION"
><B
>cyg_io_set_config</B
></TT
>(handle, key, buf, len)
	</PRE
></TD
></TR
></TABLE
><P
>This function is used to update or change runtime configuration
of a port.</P
><P
>The only key currently defined is CYG_IO_SET_CONFIG_SERIAL_INFO
which is used to access the hardware configuration. The buffer must
be of type <TT
CLASS="FILENAME"
>cyg_serial_info_t</TT
> and
all fields must contain valid information. </P
></DIV
></DIV
></DIV
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="io-package-user-api.html"
>Prev</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="ecos-ref.html"
>Home</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="tty-driver.html"
>Next</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>User
API</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="ecos-device-drivers.html"
>Up</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>&#8220;tty&#8221; driver</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>