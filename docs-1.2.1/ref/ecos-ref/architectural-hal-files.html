<HTML
><HEAD
><TITLE
>Architectural HAL files</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.33"><LINK
REL="HOME"
TITLE="eCos Reference
Manual"
HREF="ecos-ref.html"><LINK
REL="UP"
TITLE="The
eCos Hardware Abstraction Layer (HAL)"
HREF="the-ecos-hardware-abstraction-layer-hal.html"><LINK
REL="PREVIOUS"
TITLE="General principles"
HREF="general-principles.html"><LINK
REL="NEXT"
TITLE="Future developments"
HREF="future-developments.html"></HEAD
><BODY
><DIV
CLASS="NAVHEADER"
><TABLE
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="3"
ALIGN="center"
><SPAN
CLASS="TRADEMARK"
>eCos</SPAN
><SUP
><FONT
SIZE="-4"
>TM</FONT
></SUP
> Reference
Manual</TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="bottom"
><A
HREF="general-principles.html"
>Prev</A
></TD
><TD
WIDTH="80%"
ALIGN="center"
VALIGN="bottom"
>Chapter 7. The
eCos Hardware Abstraction Layer (HAL)</TD
><TD
WIDTH="10%"
ALIGN="right"
VALIGN="bottom"
><A
HREF="future-developments.html"
>Next</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><DIV
CLASS="SECT1"
><H1
CLASS="SECT1"
><A
NAME="ARCHITECTURAL-HAL-FILES"
>Architectural HAL files</A
></H1
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN3407"
><TT
CLASS="FILENAME"
>hal/ARCH/arch/v1_2_1/include/basetype.h</TT
></A
></H2
><P
>This file defines the properties of the base architecture
that are used to compile the portable parts of the kernel. It is
included automatically by <TT
CLASS="FILENAME"
>cyg/infra/cyg_type.h</TT
>. The
following definitions may be included. </P
><DIV
CLASS="SECT3"
><H3
CLASS="SECT3"
><A
NAME="AEN3412"
>Byte order</A
></H3
><P
></P
><DL
><DT
><TT
CLASS="LITERAL"
>CYG_BYTEORDER</TT
></DT
><DD
><P
>This defines the byte order of the target and must
be set to either <TT
CLASS="LITERAL"
>CYG_LSBFIRST</TT
> or <TT
CLASS="LITERAL"
>CYG_MSBFIRST</TT
>.</P
></DD
></DL
></DIV
><DIV
CLASS="SECT3"
><H3
CLASS="SECT3"
><A
NAME="AEN3422"
>Label translation</A
></H3
><P
></P
><DL
><DT
><TT
CLASS="FUNCTION"
><B
>CYG_LABEL_NAME(name)</B
></TT
></DT
><DD
><P
>This is a wrapper used in some C and C++ files
which specify labels defined in assembly code or the linker script.
It need only be defined if the default implementation in <TT
CLASS="FILENAME"
>cyg/kernel/ktypes.h</TT
>,
which passes the name argument unaltered, is inadequate. The most
usual alternative definition of this macro prepends an underscore
to the label name. This depends on the labeling convention of the
tool set.</P
></DD
></DL
></DIV
><DIV
CLASS="SECT3"
><H3
CLASS="SECT3"
><A
NAME="AEN3431"
>Base types</A
></H3
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>&#13;	cyg_halint8
	cyg_halint16
	cyg_halint32
	cyg_halint64
	cyg_halcount8
	cyg_halcount16
	cyg_halcount32
	cyg_halcount64
	cyg_halbool	</PRE
></TD
></TR
></TABLE
><P
>These macros define the C base types that should be used to
define variables of the given size. They only need to be defined
if the default types specified in <TT
CLASS="FILENAME"
>cyg/infra/cyg_type.h</TT
> cannot
be used. Note that these are only the base types, they will be composed
with <TT
CLASS="LITERAL"
>signed</TT
> and <TT
CLASS="LITERAL"
>unsigned</TT
> to
form full type specifications.</P
><DIV
CLASS="SECT4"
><H4
CLASS="SECT4"
><A
NAME="AEN3438"
>Atomic types</A
></H4
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>&#13;	cyg_halatomic
	CYG_ATOMIC</PRE
></TD
></TR
></TABLE
><P
>These types are guaranteed to be read or written in a single
uninterruptible operation. It is architecture defined what size
this type is, but it will be at least a byte. </P
></DIV
></DIV
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN3442"
><TT
CLASS="FILENAME"
>hal/ARCH/arch/v1_2_1/include/hal_arch.h</TT
></A
></H2
><P
>This file contains definitions that are related to the basic
architecture of the CPU.</P
><DIV
CLASS="SECT3"
><H3
CLASS="SECT3"
><A
NAME="AEN3446"
>Register save format</A
></H3
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>&#13;typedef struct HAL_SavedRegisters
{
/* architecture-dependent list of registers to be saved */ 
} HAL_SavedRegisters;</PRE
></TD
></TR
></TABLE
><P
>This structure describes the layout of a saved machine state
on the stack. Such states are saved during thread context switches,
interrupts and exceptions. Different quantities of state may be
saved during each of these, but usually a thread context state is
a subset of the interrupt state which is itself a subset of an exception
state. Where these states are significantly different, this structure
should contain a union of the three states.</P
></DIV
><DIV
CLASS="SECT3"
><H3
CLASS="SECT3"
><A
NAME="AEN3450"
>Thread context initialization</A
></H3
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>&#13;	HAL_THREAD_INIT_CONTEXT( sp, arg, entry, id )</PRE
></TD
></TR
></TABLE
><P
>This macro initializes a thread"s context so that
it may be switched to by <TT
CLASS="FUNCTION"
><B
>HAL_THREAD_SWITCH_CONTEXT()</B
></TT
>.
The arguments are:</P
><P
></P
><DL
><DT
>sp</DT
><DD
><P
>A location containing the current value of the thread"s
stack pointer. This should be a variable or a structure field. The
SP value will be read out of here and an adjusted value written
back.</P
></DD
><DT
>arg</DT
><DD
><P
>A value that is passed as the first argument to
the entry point function.</P
></DD
><DT
>entry</DT
><DD
><P
>The address of an entry point function. This will
be called according the C calling conventions, and the value of <TT
CLASS="PARAMETER"
><I
>arg</I
></TT
> will
be passed as the first argument.</P
></DD
><DT
>id</DT
><DD
><P
>A thread id value. This is only used for debugging
purposes, it is ORed into the initialization pattern for unused
registers and may be used to help identify the thread from its register
dump. The least significant 16 bits of this value should be zero
to allow space for a register identifier.</P
></DD
></DL
></DIV
><DIV
CLASS="SECT3"
><H3
CLASS="SECT3"
><A
NAME="AEN3473"
>Thread context switching</A
></H3
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>&#13;HAL_THREAD_SWITCH_CONTEXT( from, to )</PRE
></TD
></TR
></TABLE
><P
>This macro implements the thread switch code. The arguments
are:</P
><P
></P
><DL
><DT
>from</DT
><DD
><P
>A pointer to a location where the stack pointer
of the current thread will be stored.</P
></DD
><DT
>to</DT
><DD
><P
>A pointer to a location from where the stack pointer
of the next thread will be read.</P
></DD
></DL
><P
>The state of the current thread is saved onto its stack, using
the current value of the stack pointer, and the address of the saved
state placed in <TT
CLASS="PARAMETER"
><I
>*from</I
></TT
>. The value in <TT
CLASS="PARAMETER"
><I
>*to</I
></TT
> is then
read and the state of the new thread is loaded from it.</P
><P
>Note that interrupts are not disabled during this process,
any interrupts that occur will be delivered onto the stack to which
the current value of the CPU stack pointer points. Hence the stack
pointer should never be invalid, or loaded with a value that might cause
the saved state to become corrupted by an interrupt.</P
></DIV
><DIV
CLASS="SECT3"
><H3
CLASS="SECT3"
><A
NAME="AEN3490"
>Bit indexing</A
></H3
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>&#13;HAL_LSBIT_INDEX( mask, index )
HAL_MSBIT_INDEX( mask, index )</PRE
></TD
></TR
></TABLE
><P
>These macros place in <TT
CLASS="PARAMETER"
><I
>index</I
></TT
> the bit
index of the least(most) significant bit in mask. Some architectures
have instruction level support for one or other of these operations. If
no architectural support is available, then these macros may call
C functions to do the job.</P
></DIV
><DIV
CLASS="SECT3"
><H3
CLASS="SECT3"
><A
NAME="AEN3495"
>Idle thread activity</A
></H3
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>&#13;HAL_IDLE_THREAD_ACTION( count )</PRE
></TD
></TR
></TABLE
><P
>It may be necessary under some circumstances for the HAL to
execute code in the kernel idle thread"s loop. An example
might be to execute a processor halt instruction. This macro provides
a portable way of doing this. The argument is a copy of the idle thread"s
loop counter, and may be used to trigger actions at longer intervals
than every loop.</P
></DIV
><DIV
CLASS="SECT3"
><H3
CLASS="SECT3"
><A
NAME="AEN3499"
>Reorder barrier</A
></H3
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>&#13;HAL_REORDER_BARRIER()</PRE
></TD
></TR
></TABLE
><P
>When optimizing the compiler can reorder code. In some parts
of multi-threaded systems, where the order of actions is vital,
this can sometimes cause problems. This macro may be inserted into
places where reordering should not happen and prevents code being
migrated across it by the compiler optimizer. It should be placed
between statements that must be executed in the order written in
the code. </P
></DIV
><DIV
CLASS="SECT3"
><H3
CLASS="SECT3"
><A
NAME="AEN3503"
>Breakpoint support</A
></H3
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>&#13;HAL_BREAKPOINT( label )
HAL_BREAKINST
HAL_BREAKINST_SIZE</PRE
></TD
></TR
></TABLE
><P
>These macros provide support for breakpoints. </P
><P
><TT
CLASS="FUNCTION"
><B
>HAL_BREAKPOINT()</B
></TT
> executes a breakpoint
instruction. The label is defined at the breakpoint instruction
so that exception code can detect which breakpoint was executed. </P
><P
><TT
CLASS="PARAMETER"
><I
>HAL_BREAKINST</I
></TT
> contains the breakpoint
instruction code as an integer value. <TT
CLASS="PARAMETER"
><I
>HAL_BREAKINST_SIZE</I
></TT
> is
the size of that breakpoint instruction in bytes. Together these
may be used to place a breakpoint in any code. </P
></DIV
><DIV
CLASS="SECT3"
><H3
CLASS="SECT3"
><A
NAME="AEN3512"
>GDB support</A
></H3
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>&#13;HAL_THREAD_GET_SAVED_REGISTERS( sp, regs )
HAL_GET_GDB_REGISTERS( regval, regs )
HAL_SET_GDB_REGISTERS( regs, regval ) </PRE
></TD
></TR
></TABLE
><P
>These macros provide support for interfacing GDB to the HAL.</P
><P
><TT
CLASS="FUNCTION"
><B
>HAL_THREAD_GET_SAVED_REGISTERS()</B
></TT
> extracts
a pointer to a <SPAN
CLASS="STRUCTNAME"
>HAL_SavedRegisters</SPAN
> structure
from a stack pointer value. The stack pointer passed in should be
the value saved by the thread context macros. The macro will assign
a pointer to the <SPAN
CLASS="STRUCTNAME"
>HAL_SavedRegisters</SPAN
> structure
to the variable passed as the second argument. </P
><P
><TT
CLASS="FUNCTION"
><B
>HAL_GET_GDB_REGISTERS()</B
></TT
> translates a
register state as saved by the HAL and into a register dump in the
format expected by GDB. It takes a pointer to a <SPAN
CLASS="STRUCTNAME"
>HAL_SavedRegisters</SPAN
> structure
in the <TT
CLASS="PARAMETER"
><I
>regs</I
></TT
> argument and a pointer to the memory
to contain the GDB register dump in the <TT
CLASS="PARAMETER"
><I
>regval</I
></TT
> argument. </P
><P
><TT
CLASS="FUNCTION"
><B
>HAL_SET_GDB_REGISTERS()</B
></TT
> translates a
GDB format register dump into a the format expected by the HAL.
It takes a pointer to the memory containing the GDB register dump
in the <TT
CLASS="PARAMETER"
><I
>regval</I
></TT
> argument and a pointer to a <SPAN
CLASS="STRUCTNAME"
>HAL_SavedRegisters</SPAN
> structure
in the <TT
CLASS="PARAMETER"
><I
>regs</I
></TT
> argument. </P
></DIV
><DIV
CLASS="SECT3"
><H3
CLASS="SECT3"
><A
NAME="AEN3530"
>Setjmp and longjmp support</A
></H3
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>&#13;CYGARC_JMP_BUF_SIZE
hal_jmp_buf[CYGARC_JMP_BUF_SIZE]
hal_setjmp( hal_jmp_buf env )
hal_longjmp( hal_jmp_buf env, int val )</PRE
></TD
></TR
></TABLE
><P
>These functions provide support for the C <TT
CLASS="FUNCTION"
><B
>setjmp()</B
></TT
> and <TT
CLASS="FUNCTION"
><B
>longjmp()</B
></TT
> functions. Refer
to the C library for further information.</P
></DIV
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN3536"
><TT
CLASS="FILENAME"
>hal/ARCH/arch/v1_2_1/include/hal_intr.h</TT
></A
></H2
><P
>This file contains definitions related to interrupt handling.</P
><DIV
CLASS="SECT3"
><H3
CLASS="SECT3"
><A
NAME="AEN3540"
>Vector numbers</A
></H3
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>&#13;CYGNUM_HAL_VECTOR_XXX
CYGNUM_HAL_VSR_MIN
CYGNUM_HAL_VSR_MAX
CYGNUM_HAL_ISR_MIN
CYGNUM_HAL_ISR_MAX
CYGNUM_HAL_EXCEPTION_MIN
CYGNUM_HAL_EXCEPTION_MAX
CYGNUM_HAL_ISR_COUNT
CYGNUM_HAL_VSR_COUNT
CYGNUM_HAL_EXCEPTION_COUNT </PRE
></TD
></TR
></TABLE
><P
>All possible interrupt and exception vectors should be specified
here, together with maximum and minimum values for range checking.</P
><P
>There are two ranges of numbers, those for the vector service
routines and those for the interrupt service routines. The relationship
between these two ranges is undefined, and no equivalence should
be assumed if vectors from the two ranges coincide.</P
><P
>The VSR vectors correspond to the set of exception vectors
that can be delivered by the CPU architecture, many of these will
be internal exception traps. The ISR vectors correspond to the set
of external interrupts that can be delivered and are usually determined
by extra decoding of an interrupt controller by the interrupt VSR.</P
><P
>Where a CPU supports synchronous exceptions, the range of
such exceptions allowed are defined by <TT
CLASS="PARAMETER"
><I
>CYGNUM_HAL_EXCEPTION_MIN</I
></TT
> and <TT
CLASS="PARAMETER"
><I
>CYGNUM_HAL_EXCEPTION_MAX</I
></TT
>.
The actual exception numbers will normally correspond to the VSR
exception range. In future other exceptions generated by the system
software (such as stack overflow) may be added.</P
><P
><TT
CLASS="PARAMETER"
><I
>CYGNUM_HAL_ISR_COUNT</I
></TT
>, <TT
CLASS="PARAMETER"
><I
>CYGNUM_HAL_VSR_COUNT</I
></TT
> and <TT
CLASS="PARAMETER"
><I
>CYGNUM_HAL_EXCEPTION_COUNT</I
></TT
> define
the number of ISRs, VSRs and EXCEPTIONs respectively for the purposes
of defining arrays etc. There might be a translation from the supplied
vector numbers into array offsets. Hence <TT
CLASS="PARAMETER"
><I
>CYGNUM_HAL_XXX_COUNT</I
></TT
> may
not simply be <TT
CLASS="PARAMETER"
><I
>CYGNUM_HAL_XXX_MAX</I
></TT
> - <TT
CLASS="PARAMETER"
><I
>CYGNUM_HAL_XXX_MIN</I
></TT
> or <TT
CLASS="PARAMETER"
><I
>CYGNUM_HAL_XXX_MAX</I
></TT
>+1.</P
></DIV
><DIV
CLASS="SECT3"
><H3
CLASS="SECT3"
><A
NAME="AEN3557"
>Interrupt state control</A
></H3
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>&#13;HAL_DISABLE_INTERRUPTS( old )
HAL_RESTORE_INTERRUPTS( old )
HAL_ENABLE_INTERRUPTS()
HAL_QUERY_INTERRUPTS( state ) </PRE
></TD
></TR
></TABLE
><P
>These macros provide control over the state of the CPUs interrupt
mask mechanism. They should normally manipulate a CPU status register
to enable and disable interrupt delivery. They should not access
an interrupt controller.</P
><P
><TT
CLASS="FUNCTION"
><B
>HAL_DISABLE_INTERRUPTS()</B
></TT
> disables the
delivery of interrupts and stores the original state of the interrupt
mask in the variable passed in the <TT
CLASS="PARAMETER"
><I
>old</I
></TT
> argument.</P
><P
><TT
CLASS="FUNCTION"
><B
>HAL_RESTORE_INTERRUPTS()</B
></TT
> restores the
state of the interrupt mask to that recorded in <TT
CLASS="PARAMETER"
><I
>old</I
></TT
>.</P
><P
><TT
CLASS="FUNCTION"
><B
>HAL_ENABLE_INTERRUPTS()</B
></TT
> simply enables
interrupts regardless of the current state of the mask.</P
><P
><TT
CLASS="FUNCTION"
><B
>HAL_QUERY_INTERRUPTS()</B
></TT
> stores the state
of the interrupt mask in the variable passed in the <TT
CLASS="PARAMETER"
><I
>state</I
></TT
> argument.</P
><P
>It is at the HAL implementer&#8217;s discretion exactly
which interrupts are masked by this mechanism. Where a CPU has more
than one interrupt type that may be masked separately (e.g. the
ARM"s IRQ and FIQ) only those that can raise DSRs need
to be masked here. A separate architecture specific mechanism may
then be used to control the other interrupt types.</P
></DIV
><DIV
CLASS="SECT3"
><H3
CLASS="SECT3"
><A
NAME="AEN3573"
>ISR and VSR management</A
></H3
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>&#13;HAL_INTERRUPT_ATTACH( vector, isr, data, object )
HAL_INTERRUPT_DETACH( vector, isr )
HAL_VSR_SET( vector, vsr, poldvsr )
HAL_VSR_GET( vector, pvsr )</PRE
></TD
></TR
></TABLE
><P
>These macros manage the attachment of interrupt and vector
service routines to interrupt and exception vectors respectively.</P
><P
><TT
CLASS="FUNCTION"
><B
>HAL_INTERRUPT_ATTACH()</B
></TT
> attaches the ISR,
data pointer and object pointer to the given vector. When an interrupt
occurs on this vector the ISR is called using the C calling convention
and the vector number and data pointer are passed to it as the first and
second arguments respectively.</P
><P
><TT
CLASS="FUNCTION"
><B
>HAL_INTERRUPT_DETACH()</B
></TT
> detaches the ISR
from the vector.</P
><P
><TT
CLASS="FUNCTION"
><B
>HAL_VSR_SET()</B
></TT
> replaces the VSR attached
to the <TT
CLASS="PARAMETER"
><I
>vector</I
></TT
> with the replacement supplied
in <TT
CLASS="PARAMETER"
><I
>vsr</I
></TT
>. The old VSR is returned in the location
pointed to by <TT
CLASS="PARAMETER"
><I
>pvsr</I
></TT
>.</P
><P
><TT
CLASS="FUNCTION"
><B
>HAL_VSR_GET()</B
></TT
> assigns a copy of the VSR
to the location pointed to by <TT
CLASS="PARAMETER"
><I
>pvsr</I
></TT
>.</P
></DIV
><DIV
CLASS="SECT3"
><H3
CLASS="SECT3"
><A
NAME="AEN3589"
>Interrupt controller management</A
></H3
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>&#13;HAL_INTERRUPT_MASK( vector )
HAL_INTERRUPT_UNMASK( vector )
HAL_INTERRUPT_ACKNOWLEDGE( vector )
HAL_INTERRUPT_CONFIGURE( vector, level, up )
HAL_INTERRUPT_SET_LEVEL( vector, level )</PRE
></TD
></TR
></TABLE
><P
>These macros exert control over any prioritized interrupt
controller that is present. If no priority controller exists, then
these macros should be empty.</P
><P
><TT
CLASS="FUNCTION"
><B
>HAL_INTERRUPT_MASK()</B
></TT
> causes the interrupt
associated with the given vector to be blocked.</P
><P
><TT
CLASS="FUNCTION"
><B
>HAL_INTERRUPT_UNMASK()</B
></TT
> causes the interrupt
associated with the given vector to be unblocked.</P
><P
><TT
CLASS="FUNCTION"
><B
>HAL_INTERRUPT_ACKNOWLEDGE()</B
></TT
> acknowledges
the current interrupt from the given vector. This is usually executed
from the ISR for this vector when it is prepared to allow further
interrupts. Most interrupt controllers need some form of acknowledge action
before the next interrupt is allowed through. Executing this macro
may cause another interrupt to be delivered. Whether this interrupts
the current code depends on the state of the CPU interrupt mask.</P
><P
><TT
CLASS="FUNCTION"
><B
>HAL_INTERRUPT_CONFIGURE()</B
></TT
> provides control
over how an interrupt signal is detected. The arguments are:</P
><P
></P
><DL
><DT
>vector</DT
><DD
><P
>The interrupt to be configured.</P
></DD
><DT
>level</DT
><DD
><P
>Set to <TT
CLASS="LITERAL"
>true</TT
> if the interrupt
is detected by level, and <TT
CLASS="LITERAL"
>false</TT
> if it is edge
triggered.</P
></DD
><DT
>up</DT
><DD
><P
>If the interrupt is set to level detect, then if
this is <TT
CLASS="LITERAL"
>true</TT
> it is detected by a high signal
level, and if <TT
CLASS="LITERAL"
>false</TT
> by a low signal level. If
the interrupt is set to edge triggered, then if this is <TT
CLASS="LITERAL"
>true</TT
> it
is triggered by a rising edge and if <TT
CLASS="LITERAL"
>false</TT
> by
a falling edge.</P
></DD
></DL
><P
><TT
CLASS="FUNCTION"
><B
>HAL_INTERRUPT_SET_LEVEL()</B
></TT
> provides control
over the hardware priority of the interrupt. The arguments are:</P
><P
></P
><DL
><DT
>vector</DT
><DD
><P
>The interrupt whose level is to be set.</P
></DD
><DT
>level</DT
><DD
><P
>The priority level to which the interrupt is to
set. In some architectures the set interrupt level is also used
as an interrupt enable/disable. Hence this function and <TT
CLASS="FUNCTION"
><B
>HAL_INTERRUPT_MASK()</B
></TT
> and <TT
CLASS="FUNCTION"
><B
>HAL_INTERRUPT_UNMASK()</B
></TT
> may
interfere with each other.</P
></DD
></DL
></DIV
><DIV
CLASS="SECT3"
><H3
CLASS="SECT3"
><A
NAME="AEN3633"
>Clock control</A
></H3
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>&#13;HAL_CLOCK_INITIALIZE( period )
HAL_CLOCK_RESET( vector, period )
HAL_CLOCK_READ( pvalue )</PRE
></TD
></TR
></TABLE
><P
>These macros provide control over a clock or timer device
that may be used by the kernel to provide time-out, delay and scheduling
services. The clock is assumed to be implemented by some form of
counter that is incremented or decremented by some external source
and which raises an interrupt when it reaches zero.</P
><P
><TT
CLASS="FUNCTION"
><B
>HAL_CLOCK_INITIALIZE()</B
></TT
> initializes the
clock device to interrupt at the given period. The period is essentially
the value used to initialize the clock counter and must be calculated
from the clock frequency and the desired interrupt rate.</P
><P
><TT
CLASS="FUNCTION"
><B
>HAL_CLOCK_RESET()</B
></TT
> re-initializes the
clock to provoke the next interrupt. This macro is only really necessary
when the clock device needs to be reset in some way after each interrupt.</P
><P
><TT
CLASS="FUNCTION"
><B
>HAL_CLOCK_READ()</B
></TT
> reads the current value
of the clock counter and puts the value in the location pointed
to by <TT
CLASS="PARAMETER"
><I
>pvalue</I
></TT
>. The value stored will always
be the number of clock ``ticks"" since
the last interrupt, and hence ranges between zero and the initial period
value.</P
></DIV
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN3644"
><TT
CLASS="FILENAME"
>hal/ARCH/arch/v1_2_1/include/hal_io.h</TT
></A
></H2
><P
>This file contains definitions for supporting access to device
control registers in an architecture neutral fashion.</P
><DIV
CLASS="SECT3"
><H3
CLASS="SECT3"
><A
NAME="AEN3648"
>Register address</A
></H3
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>&#13;HAL_IO_REGISTER</PRE
></TD
></TR
></TABLE
><P
>This type is used to store the address of an I/O
register. It will normally be a memory address, an integer port
address or an offset into an I/O space. More complex architectures
may need to code an address space plus offset pair into a single
word, or may represent it as a structure.</P
><P
>Values of variables and constants of this type will usually
be supplied by configuration mechanisms.</P
></DIV
><DIV
CLASS="SECT3"
><H3
CLASS="SECT3"
><A
NAME="AEN3653"
>Register read</A
></H3
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>&#13;HAL_READ_XXX( register, value )
HAL_READ_XXX_VECTOR( register, buffer, count, stride )</PRE
></TD
></TR
></TABLE
><P
>These macros support the reading of I/O registers
in various sizes. The <SPAN
CLASS="TYPE"
>XXX</SPAN
> component of the name may
be <SPAN
CLASS="TYPE"
>UINT8</SPAN
>, <SPAN
CLASS="TYPE"
>UINT16</SPAN
>, <SPAN
CLASS="TYPE"
>UINT32</SPAN
>.</P
><P
><TT
CLASS="FUNCTION"
><B
>HAL_READ_XXX()</B
></TT
> reads the appropriately
sized value from the register and stores it in the variable passed
as the second argument.</P
><P
><TT
CLASS="FUNCTION"
><B
>HAL_READ_XXX_VECTOR()</B
></TT
> reads <TT
CLASS="PARAMETER"
><I
>count</I
></TT
> values
of the appropriate size into <TT
CLASS="PARAMETER"
><I
>buffer</I
></TT
>. The <TT
CLASS="PARAMETER"
><I
>stride</I
></TT
> controls
how the pointer advances through the register space. A stride of
zero will read the same register repeatedly, and a stride of one
will read adjacent registers of the given size. Greater strides
will step by larger amounts, to allow for sparsely mapped registers
for example.</P
></DIV
><DIV
CLASS="SECT3"
><H3
CLASS="SECT3"
><A
NAME="AEN3668"
>Register write</A
></H3
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>&#13;HAL_WRITE_XXX( register, value )
HAL_WRITE_XXX_VECTOR( register, buffer, count, stride )</PRE
></TD
></TR
></TABLE
><P
>These macros support the writing of I/O registers
in various sizes. The <TT
CLASS="LITERAL"
>XXX</TT
> component of the name
may be <TT
CLASS="LITERAL"
>UINT8</TT
>, <TT
CLASS="LITERAL"
>UINT16</TT
>, <TT
CLASS="LITERAL"
>UINT32</TT
>.</P
><P
><TT
CLASS="FUNCTION"
><B
>HAL_WRITE_XXX()</B
></TT
> writes the appropriately
sized value from the variable passed as the second argument stored
it in the register.</P
><P
><TT
CLASS="FUNCTION"
><B
>HAL_WRITE_XXX_VECTOR()</B
></TT
> writes <TT
CLASS="PARAMETER"
><I
>count</I
></TT
> values
of the appropriate size from <TT
CLASS="PARAMETER"
><I
>buffer</I
></TT
>. The <TT
CLASS="PARAMETER"
><I
>stride</I
></TT
> controls
how the pointer advances through the register space. A stride of
zero will write the same register repeatedly, and a stride of one
will write adjacent registers of the given size. Greater strides
will step by larger amounts, to allow for sparsely mapped registers
for example.</P
></DIV
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN3683"
><TT
CLASS="FILENAME"
>hal/ARCH/arch/v1_2_1/include/hal_cache.h</TT
></A
></H2
><P
>This file contains definitions for supporting control of the
caches on the CPU. </P
><P
>There are versions of the macros defined here for both the
Data and Instruction caches. these are distinguished by the use
of either DCACHE or ICACHE in the macro names. In the following
descriptions, XCACHE is also used to stand for either of these.
Where there are issues specific to a particular cache, this will
be explained in the text. </P
><P
>There might be restrictions on the use of some of the macros
which it is the user"s responsibility to comply with. Such
restrictions are documented in the <TT
CLASS="FILENAME"
>hal_cache.h</TT
> file. </P
><P
>Note that destructive cache macros should be used with caution.
Preceding a cache invalidation with a cache synchronization is not
safe in itself since an interrupt may happen after the synchronization
but before the invalidation. This might cause the state of dirty
data lines created during the interrupt to be lost. </P
><P
>Depending on the architecture"s capabilities, it
may be possible to temporarily disable the cache while doing the
synchronization and invalidation which solves the problem (no new
data would be cached during an interrupt). Otherwise it is necessary
to disable interrupts while manipulating the cache which may take
a long time. </P
><DIV
CLASS="SECT3"
><H3
CLASS="SECT3"
><A
NAME="AEN3692"
>Cache dimensions</A
></H3
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>&#13;HAL_XCACHE_SIZE
HAL_XCACHE_LINE_SIZE
HAL_XCACHE_WAYS
HAL_XCACHE_SETS</PRE
></TD
></TR
></TABLE
><P
>These macros define the size and dimensions of the Instruction
and Data caches.</P
><P
></P
><DL
><DT
>HAL_XCACHE_SIZE</DT
><DD
><P
>gives the total size of the cache in bytes.</P
></DD
><DT
>HAL_XCACHE_LINE_SIZE</DT
><DD
><P
>gives the cache line size in bytes.</P
></DD
><DT
>HAL_XCACHE_WAYS</DT
><DD
><P
>gives the number of ways in each set and defines
its level of associativity. This would be 1 for a direct mapped
cache.</P
></DD
><DT
>HAL_XCACHE_SETS</DT
><DD
><P
>gives the number of sets in the cache, and is derived
from the previous values.</P
></DD
></DL
></DIV
><DIV
CLASS="SECT3"
><H3
CLASS="SECT3"
><A
NAME="AEN3713"
>Global cache control</A
></H3
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>&#13;HAL_XCACHE_ENABLE()
HAL_XCACHE_DISABLE()
HAL_XCACHE_INVALIDATE_ALL()
HAL_XCACHE_SYNC()
HAL_XCACHE_BURST_SIZE( size )
HAL_DCACHE_WRITE_MODE( mode )
HAL_XCACHE_LOCK( base, size )
HAL_XCACHE_UNLOCK( base, size )
HAL_XCACHE_UNLOCK_ALL()</PRE
></TD
></TR
></TABLE
><P
>These macros affect the state of the entire cache, or a large
part of it. </P
><P
></P
><DL
><DT
>HAL_XCACHE_ENABLE()
and HAL_XCACHE_DISABLE()</DT
><DD
><P
>enable and disable the cache.</P
></DD
><DT
>HAL_XCACHE_INVALIDATE_ALL()</DT
><DD
><P
>causes the entire contents of the cache to be invalidated.</P
></DD
><DT
>HAL_XCACHE_SYNC()</DT
><DD
><P
>causes the contents of the cache to be brought into
synchronization with the contents of memory. In some implementations
this may be equivalent to HAL_XCACHE_INVALIDATE_ALL().</P
></DD
><DT
>HAL_XCACHE_BURST_SIZE()</DT
><DD
><P
>allows the size of cache to/from memory
bursts to be controlled. This macro will only be defined if this
functionality is available.</P
></DD
><DT
>HAL_DCACHE_WRITE_MODE()</DT
><DD
><P
>controls the way in which data cache lines are written
back to memory. There will be definitions for the possible modes.
Typical definitions are HAL_DCACHE_WRITEBACK_MODE
and HAL_DCACHE_WRITETHRU_MODE. This macro
will only be defined if this functionality is available.</P
></DD
><DT
>HAL_XCACHE_LOCK()</DT
><DD
><P
>causes data to be locked into the cache. The base
and size arguments define the memory region that will be locked
into the cache. It is architecture dependent whether more than one
locked region is allowed at any one time, and whether this operation
causes the cache to cease acting as a cache for addresses outside
the region during the duration of the lock. This macro will only
be defined if this functionality is available.</P
></DD
><DT
>HAL_XCACHE_UNLOCK()</DT
><DD
><P
>cancels the locking of the memory region given.
This should normally correspond to a region supplied in a matching
lock call. This macro will only be defined if this functionality
is available.</P
></DD
><DT
>HAL_XCACHE_UNLOCK_ALL()</DT
><DD
><P
>cancels all existing locked memory regions. This
may be required as part of the cache initialization on some architectures.
This macro will only be defined if this functionality is available.</P
></DD
></DL
></DIV
><DIV
CLASS="SECT3"
><H3
CLASS="SECT3"
><A
NAME="AEN3750"
>Cache line control</A
></H3
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>&#13;HAL_DCACHE_ALLOCATE( base , size )
HAL_DCACHE_FLUSH( base , size )
HAL_XCACHE_INVALIDATE( base , size )
HAL_DCACHE_STORE( base , size )
HAL_DCACHE_READ_HINT( base , size )
HAL_DCACHE_WRITE_HINT( base , size )
HAL_DCACHE_ZERO( base , size )</PRE
></TD
></TR
></TABLE
><P
>All of these macros apply a cache operation to all cache lines
that match the memory address region defined by the base and size
arguments. These macros will only be defined if the described functionality
is available. Also, it is not guaranteed that the cache function
will only be applied to just the described regions, in some architectures it
may be applied to the whole cache.</P
><P
></P
><DL
><DT
>HAL_DCACHE_ALLOCATE()</DT
><DD
><P
>allocates lines in the cache for the given region
without reading their contents from memory, hence the contents of
the lines is undefined. This is useful for preallocating lines which
are to be completely overwritten, for example in a block copy operation.</P
></DD
><DT
>HAL_DCACHE_FLUSH()</DT
><DD
><P
>invalidates all cache lines in the region after
writing any dirty lines to memory.</P
></DD
><DT
>HAL_XCACHE_INVALIDATE()</DT
><DD
><P
>invalidates all cache lines in the region. Any dirty
lines are invalidated without being written to memory.</P
></DD
><DT
>HAL_DCACHE_STORE()</DT
><DD
><P
>writes all dirty lines in the region to memory,
but does not invalidate any lines.</P
></DD
><DT
>HAL_DCACHE_READ_HINT()</DT
><DD
><P
>hints to the cache that the region is going to be
read from in the near future. This may cause the region to be speculatively
read into the cache.</P
></DD
><DT
>HAL_DCACHE_WRITE_HINT()</DT
><DD
><P
>hints to the cache that the region is going to be
written to in the near future. This may have the identical behavior
to HAL_DCACHE_READ_HINT().</P
></DD
><DT
>HAL_DCACHE_ZERO()</DT
><DD
><P
>allocates and zeroes lines in the cache for the
given region without reading memory. This is useful if a large area
of memory is to be cleared.</P
></DD
></DL
></DIV
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="PLATFORM-LD"
><TT
CLASS="FILENAME"
>hal/ARCH/arch/v1_2_1/src/ARCH.ld</TT
></A
></H2
><P
>This is the architecture specific linker script file. It defines
the section types required for the architecture. During preprocessing,
the memory layout specified for the chosen platform and startup
type is included, defining region, alignment and location parameters
for the sections.</P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN3787"
><TT
CLASS="FILENAME"
>hal/ARCH/arch/v1_2_1/src/vectors.S</TT
></A
></H2
><P
>This file contains code to deal with exception and interrupt
vectors. Since the reset entry point is usually implemented as one
of these it also deals with system startup.</P
><P
>The exact implementation of this code is under the control
of the HAL implementer. So long as it interacts correctly with the
macros defined in <TT
CLASS="FILENAME"
>hal_intr.h</TT
> it may
take any form. However, all current implementation follow the same
pattern, and there should be a very good reason to break with this.
The rest of this section describes how the standard HAL implementation
operates.</P
><P
>This file usually contains the following sections of code:</P
><P
></P
><UL
><LI
><P
>Startup and initialization code.</P
></LI
><LI
><P
>Exception delivery.</P
></LI
><LI
><P
>Default handling of synchronous exception.</P
></LI
><LI
><P
>Default handling of interrupts.</P
></LI
></UL
><DIV
CLASS="SECT3"
><H3
CLASS="SECT3"
><A
NAME="HAL-APPENDIX-STARTUP"
>HAL startup</A
></H3
><P
>Execution normally begins at the reset vector with the machine
in a minimal startup state.</P
><P
>The following is a list of the jobs that need to be done in
approximately the order in which they should be accomplished. Many
of these will not be needed in some configurations.</P
><P
></P
><UL
><LI
><P
>Initialize various CPU status registers.
Most importantly, the CPU interrupt mask should be set to disable
interrupts. </P
></LI
><LI
><P
>Set up any CPU memory controller to access RAM,
ROM and I/O devices correctly. Until this is done it may
not be possible to access RAM. </P
></LI
><LI
><P
>Enable the cache, if it is to be used. This may
require enabling the CPU"s memory management system since
that is often the only way of controlling the cacheability of memory.
If this is necessary, a direct one-to-one mapping between physical
and virtual memory is most desirable. </P
></LI
><LI
><P
>Set up the stack pointer, this allows subsequent
initialization code to make procedure calls. </P
></LI
><LI
><P
>Initialize any global pointer register needed for
access to globally defined variables. This allows subsequent initialization
code to access global variables. </P
></LI
><LI
><P
>Perform any platform specific initialization. This
is best accomplished by calling an initialization routine in <TT
CLASS="FILENAME"
>PLATFORM.S</TT
> (see <A
HREF="architectural-hal-files.html#PLATFORM-S"
>the section called <I
><TT
CLASS="FILENAME"
>hal/ARCH/PLATFORM/v1_2_1/src/PLATFORM.S</TT
></I
></A
>).</P
></LI
><LI
><P
>If the system is starting from ROM, copy the ROM
template of the <TT
CLASS="LITERAL"
>.data</TT
> section out to its correct
position in RAM. (See <A
HREF="architectural-hal-files.html#PLATFORM-LD"
>the section called <I
><TT
CLASS="FILENAME"
>hal/ARCH/arch/v1_2_1/src/ARCH.ld</TT
></I
></A
>). </P
></LI
><LI
><P
>Zero the <TT
CLASS="LITERAL"
>BSS</TT
> section. </P
></LI
><LI
><P
>Create a suitable C call stack frame. </P
></LI
><LI
><P
>Call <TT
CLASS="FUNCTION"
><B
>cyg_hal_invoke_constructors()</B
></TT
> to
run any static constructors.</P
></LI
><LI
><P
>Call <TT
CLASS="FUNCTION"
><B
>cyg_start()</B
></TT
>. If <TT
CLASS="FUNCTION"
><B
>cyg_start()</B
></TT
> returns,
drop into an infinite loop.</P
></LI
></UL
></DIV
><DIV
CLASS="SECT3"
><H3
CLASS="SECT3"
><A
NAME="AEN3841"
>Vectors
and VSRs</A
></H3
><P
>The CPU delivers all exceptions
whether synchronous or interrupts to a set of vectors. Depending
on the architecture, these may be implemented in a number of different ways.
Examples of existing mechanisms are:</P
><P
></P
><DL
><DT
>PowerPC</DT
><DD
><P
>Exceptions are vectored to locations 256 bytes apart
starting at either zero or <TT
CLASS="LITERAL"
>0xFFF00000</TT
>. There
are 16 such vectors defined by the architecture and extra vectors
may be defined by specific implementations.</P
></DD
><DT
>MIPS</DT
><DD
><P
>All exceptions are vectored to a single address
and software is responsible for reading the exception code from
a CPU register to discover its true source.</P
></DD
><DT
>MN10300</DT
><DD
><P
>External interrupts are vectored to an address stored
in one of seven interrupt vector registers. These only supply the
lower 16 bits of the address, the upper 16 bits are fixed to <TT
CLASS="LITERAL"
>0x4000XXXX</TT
>.
Hence the service routine is constrained to the 64k range starting
at <TT
CLASS="LITERAL"
>0x40000000</TT
>.</P
></DD
><DT
>Pentium</DT
><DD
><P
>Exceptions are delivered via an Interrupt Descriptor
Table (IDT) which is essentially an indirection table indexed by
exception type. The IDT may be placed anywhere in memory. In PC
hardware the interrupt controller can be programmed to deliver the
external interrupts to a block of 16 vectors at any offset in the
IDT.</P
></DD
><DT
>680X0</DT
><DD
><P
>Exceptions are delivered via an indirection table
described by a CPU base register (for X &#62; 0). External
interrupts are either delivered via a set of level-specific vectors
defined by the architecture, or a vector number may be supplied
by the device in which case another entry in the table may be used.</P
></DD
></DL
><P
>The model adopted by the HAL is that VSRs should be easily
replaceable with a pointer to an alternative routine. Of the above
architectures, only the <SPAN
CLASS="HARDWARE"
>Pentium</SPAN
> and <SPAN
CLASS="HARDWARE"
>680X0</SPAN
> allow
this directly in the hardware. In the other three, extra software
is required. The code attached directly to the vector is a short
trampoline that indirects by way of a HAL supplied VSR table to
the true VSR. In the <SPAN
CLASS="HARDWARE"
>PowerPC</SPAN
> and <SPAN
CLASS="HARDWARE"
>MN10300</SPAN
> the
table offset is implicit in the vector routine called, for the MIPS
the code reads the <TT
CLASS="PARAMETER"
><I
>cause</I
></TT
> register and indirects
through the appropriate table entry.</P
></DIV
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN3878"
>Default
exception handling</A
></H2
><P
>Most synchronous exception vectors will point to a default
exception VSR which is responsible for handling all exceptions in
a generic manner.</P
><P
>Since most exceptions handled by this VSR are errors (or breakpoints
when a program is being debugged), its default behavior should be
to save the entire machine state, disable interrupts, and invoke
the debugger"s entry point, passing it a pointer to the saved
state.</P
><P
>If the debugger returns then the saved state is restored and
the interrupted code resumed. Since the debugger may adjust the
saved state while it runs a little care must be taken to restore
the state correctly.</P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN3886"
>Default
interrupt handling</A
></H2
><P
>Most external interrupt vectors will point to a default interrupt
VSR which decode the actual interrupt being delivered and invokes
the appropriate ISR.</P
><P
>The default interrupt VSR has a number of responsibilities
if it is going to interact with the Kernel cleanly and allow interrupts
to cause thread preemption.</P
><P
>To support this VSR an ISR vector table is needed. For each
valid vector three pointers need to be stored: the ISR, its data
pointer and an interrupt object pointer needed by the kernel. It
is implementation defined whether these are stored in a single table
of triples, or in three separate tables.</P
><P
>The VSR should follow the following approximate plan:</P
><P
></P
><UL
><LI
><P
>Save the CPU state. In non-debug configurations,
it may be possible to get away with saving less than the entire
machine state.</P
></LI
><LI
><P
>Increment the kernel scheduler lock. This is a static
member of the Cyg_Scheduler class. It may be necessary
to look at a objdump or assembler listing of <TT
CLASS="FILENAME"
>sched.cxx</TT
> to
discover its mangled label.</P
></LI
><LI
><P
>(Optional) Switch to an interrupt stack if not already
running on it. This allows nested interrupts to be delivered without
needing every thread to have a stack large enough to take the maximum
possible nesting. It is implementation defined how to detect whether
this is a nested interrupt.</P
></LI
><LI
><P
>(Optional) Re-enable interrupts to permit nesting.</P
></LI
><LI
><P
>Decode the actual external interrupt being delivered
from the interrupt controller. This will yield the ISR vector number.</P
></LI
><LI
><P
>Using the ISR vector number as an index, retrieve
the ISR pointer and its data pointer from the ISR vector table.</P
></LI
><LI
><P
>Construct a C call stack frame.</P
></LI
><LI
><P
>Call the ISR, passing the vector number and data
pointer. The vector number and a pointer to the saved state should
be preserved across this call, preferably by storing them in registers
that are defined to be callee-saved by the calling conventions.</P
></LI
><LI
><P
>If this is an un-nested interrupt and a separate
interrupt stack is being used, switch back to the interrupted thread"s
own stack.</P
></LI
><LI
><P
>(Optional) If interrupts were not enabled above,
enable them here since the <TT
CLASS="FUNCTION"
><B
>interrupt_end()</B
></TT
> function
must be called with interrupts enabled.</P
></LI
><LI
><P
>Use the saved ISR vector number to get the interrupt
object pointer from the ISR vector table.</P
></LI
><LI
><P
>Call <TT
CLASS="FUNCTION"
><B
>interrupt_end()</B
></TT
> passing
it the return value from the ISR, the interrupt object pointer and
a pointer to the saved CPU state. This function is implemented by
the Kernel and is responsible for finishing off the interrupt handling. Specifically,
it may post a DSR depending on the ISR return value, and will decrement
the scheduler lock. If the lock is zeroed by this then it may result
in a thread context switch. </P
></LI
><LI
><P
>When <TT
CLASS="FUNCTION"
><B
>interrupt_end()</B
></TT
> returns,
restore the machine state and resume execution of the interrupted
thread. Depending on the architecture, it may be necessary to disable
interrupts again for part of this.</P
></LI
></UL
><P
>The detailed order of these steps may vary slightly depending
on the architecture, in particular where interrupts are enabled
and disabled.</P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN3927"
><TT
CLASS="FILENAME"
>hal/ARCH/arch/v1_2_1/src/hal_misc.c</TT
></A
></H2
><P
>This file contains any miscellaneous functions that are reference
by the HAL. Typical functions that might go here are C implementations
of the least- and most- significant bit index routines, constructor
calling functions such as <TT
CLASS="FUNCTION"
><B
>cyg_hal_invoke_constructors()</B
></TT
> and
support routines for the exception and interrupt vector handling.</P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN3932"
><TT
CLASS="FILENAME"
>hal/ARCH/PLATFORM/v1_2_1/include/pkgconf/STARTUP.mlt </TT
></A
></H2
><P
>For each startup type (STARTUP) the memory layout of the sections
is defined. This information may be edited using the <SPAN
CLASS="APPLICATION"
>Configuration
Tool</SPAN
> only. </P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN3937"
><TT
CLASS="FILENAME"
>hal/ARCH/PLATFORM/v1_2_1/include/pkgconf/STARTUP.ldi </TT
></A
></H2
><P
>For each startup type (STARTUP) the memory layout of the sections
is exported by the <SPAN
CLASS="APPLICATION"
>Configuration Tool</SPAN
> as
a linker script fragment suitable for inclusion within the architecture-specific
linker script file during preprocessing. The linker script fragment to
be included is specified by the CYGHWR_MEMORY_LAYOUT_LDI
macro in the <TT
CLASS="FILENAME"
>system.h</TT
> header file. The linker
script fragments will be overwritten by the <SPAN
CLASS="APPLICATION"
>Configuration
Tool</SPAN
> and should only edited manually where the <SPAN
CLASS="APPLICATION"
>Configuration
Tool</SPAN
> is not in use. </P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN3945"
><TT
CLASS="FILENAME"
>hal/ARCH/PLATFORM/v1_2_1/include/hal_diag.h </TT
></A
></H2
><P
>During early development it is useful to have the ability
to output messages to some default destination. This may be a memory
buffer, a simulator supported output channel, a ROM emulator virtual
UART or a serial line. This file defines set of macros that provide
simple, polled output for this purpose.</P
><P
><TT
CLASS="FUNCTION"
><B
>HAL_DIAG_INIT()</B
></TT
> performs any initialization
required on the device being used to generate diagnostic output.
This may include setting baud rate, and stop, parity and character
bits.</P
><P
><TT
CLASS="FUNCTION"
><B
>HAL_DIAG_WRITE_CHAR(c)</B
></TT
> writes the character
supplied to the diagnostic output device.</P
><P
>These macros may either implement the required functionality
directly, or may call functions elsewhere in the HAL to do it. In
the latter case these should be in the file <TT
CLASS="FILENAME"
>hal/ARCH/PLATFORM/v1_2_1/src/hal_diag.c</TT
>. </P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="PLATFORM-S"
><TT
CLASS="FILENAME"
>hal/ARCH/PLATFORM/v1_2_1/src/PLATFORM.S</TT
></A
></H2
><P
>This is a platform specific assembly code file. Its main purpose
is to contain any platform specific startup code called from <TT
CLASS="FILENAME"
>vectors.S</TT
>.</P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="CONTEXT-S"
><TT
CLASS="FILENAME"
>hal/ARCH/PLATFORM/v1_2_1/src/context.S</TT
></A
></H2
><P
>If present, this is an assembly code file that contains the
code to support thread contexts. The routines to switch between
various contexts, as well as initialize a thread context may be
present in this file. </P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN3964"
><TT
CLASS="FILENAME"
>hal/ARCH/PLATFORM/v1_2_1/src/hal_diag.c</TT
></A
></H2
><P
>If present, this file contains the implementation of the HAL
diagnostic support routines.</P
></DIV
></DIV
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="general-principles.html"
>Prev</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="ecos-ref.html"
>Home</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="future-developments.html"
>Next</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>General principles</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="the-ecos-hardware-abstraction-layer-hal.html"
>Up</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>Future developments</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>