<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML EXPERIMENTAL 970324//EN">
<HTML>
<HEAD>
<META NAME="GENERATOR" CONTENT="Adobe FrameMaker 5.5/HTML Export Filter">
<LINK REL="STYLESHEET" HREF="cygnus.css">
<TITLE> A tour of the kernel sources</TITLE></HEAD>
<BODY BGCOLOR="#ffffff">
<DIV>
<TABLE STYLE="ECOS" WIDTH="98%" BORDER="0" ALIGN="LEFT" CELLPADDING="1"><TR><TH COLSPAN="3" ALIGN="center"><P CLASS="Gotos">A tour of the kernel sources</P></TH></TR><TR><TD  ALIGN="center"><P CLASS="Gotos"><A HREF="ecos-ref.2.html">To Contents</A></P></TD><TD  ALIGN="center"><P CLASS="Gotos"><A HREF="ecos-ref.4.html">To&nbsp;previous&nbsp;page</A></P></TD><TD ALIGN="center"><P CLASS="Gotos"><A HREF="ecos-ref.6.html">To&nbsp;next&nbsp;page</A></P></TD></TR></TABLE><P ALIGN="LEFT">&nbsp;</P><BR><BR><HR ALIGN="center"></DIV>
<H2 CLASS="ChapterTitle">
<A NAME="pgfId=1076148">
 </A>
A tour of the kernel sources<DIV>
<IMG SRC="botclear.gif">
</DIV>
</H2>
<P CLASS="Body">
<A NAME="pgfId=1015445">
 </A>
This description takes the form of a tour around the sources explaining their structure and describing the functionality of each component. </P>
<P CLASS="Body">
<A NAME="pgfId=1015512">
 </A>
The kernel is divided into two basic parts, the largely machine independent parts in <CODE CLASS="Code">
Cygnus/eCos/packages/kernel/</CODE>
<EM CLASS="Filename">
v1_3_x,</EM>
 and the architecture- and platform-specific parts that comprise the Hardware Abstraction Layer (<EM CLASS="Acronym">
HAL</EM>
) in <CODE CLASS="Code">
Cygnus/eCos/packages/hal</CODE>
. These will be described separately. Also note that the HAL is described in great detail in its own chapter (see <A HREF="ecos-ref.b.html#11148" CLASS="XRef">
 The eCos Hardware Abstraction Layer (HAL)</A>
). </P>
<DIV>
<H3 CLASS="Heading1">
<A NAME="pgfId=1015521">
 </A>
<A NAME="marker=1084393">
 </A>
Kernel headers</H3>
<P CLASS="Body">
<A NAME="pgfId=1015566">
 </A>
Kernel header files (in <CODE CLASS="Code">
Cygnus/eCos/packages/kernel/</CODE>
<EM CLASS="Filename">
v1_3_x</EM>
<CODE CLASS="Code">
/include</CODE>
) provide external interfaces and configuration control for the various kernel objects. In general there is an include file for each major kernel class. Those header files having to do with configuration live in the <CODE CLASS="Code">
pkgconf</CODE>
 subdirectory. </P>
<P CLASS="Body">
<A NAME="pgfId=1015616">
 </A>
The base name of a header file and the source file that implements it are usually the same. So, for example, the member functions defined in <CODE CLASS="Code">
sched.hxx</CODE>
 are implemented in <CODE CLASS="Code">
sched.cxx</CODE>
. For a number of classes there are also header files that define inline functions, for example <CODE CLASS="Code">
sched.inl</CODE>
. </P>
<P CLASS="Body">
<A NAME="pgfId=1015626">
 </A>
There are some kernel objects that are implemented using C++ templates to allow code re-use in future; it is not intended that these template classes be used generally by applications. The appropriate concrete kernel classes should be used instead. </P>
<P CLASS="Body">
<A NAME="pgfId=1015644">
 </A>
Now we examine the files one by one for reference: </P>
<P CLASS="BodyHang1">
<A NAME="pgfId=1015651">
 </A>
<CODE CLASS="Code">
include/bitmap.hxx</CODE>
 	</P>
<P CLASS="BodyListFollow">
<A NAME="pgfId=1015673">
 </A>
Bitmap scheduler definition. See source file <CODE CLASS="Code">
sched/bitmap.cxx</CODE>
</P>
<P CLASS="BodyHang1">
<A NAME="pgfId=1015692">
 </A>
<CODE CLASS="Code">
include/clock.hxx</CODE>
, </P>
<P CLASS="BodyHang1">
<A NAME="pgfId=1015706">
 </A>
<CODE CLASS="Code">
include/clock.inl</CODE>
 	</P>
<P CLASS="BodyListFollow">
<A NAME="pgfId=1015716">
 </A>
Counter, clock and alarm functions. See source file <CODE CLASS="Code">
common/clock.cxx</CODE>
</P>
<P CLASS="BodyHang1">
<A NAME="pgfId=1015735">
 </A>
<CODE CLASS="Code">
include/diag.h</CODE>
 	</P>
<P CLASS="BodyListFollow">
<A NAME="pgfId=1015749">
 </A>
Diagnostic routines. See source file <CODE CLASS="Code">
trace/diag.c</CODE>
</P>
<P CLASS="BodyHang1">
<A NAME="pgfId=1015768">
 </A>
<CODE CLASS="Code">
include/errors.h</CODE>
 	</P>
<P CLASS="BodyListFollow">
<A NAME="pgfId=1015782">
 </A>
Kernel error codes. See source file <CODE CLASS="Code">
common/except.cxx</CODE>
</P>
<P CLASS="BodyHang1">
<A NAME="pgfId=1015801">
 </A>
<CODE CLASS="Code">
include/except.hxx</CODE>
 	</P>
<P CLASS="BodyListFollow">
<A NAME="pgfId=1015815">
 </A>
Exception handling.</P>
<P CLASS="BodyHang1">
<A NAME="pgfId=1015825">
 </A>
<CODE CLASS="Code">
include/flag.hxx</CODE>
 	</P>
<P CLASS="BodyListFollow">
<A NAME="pgfId=1015839">
 </A>
Flag synchronization objects. See source file <CODE CLASS="Code">
sync/flag.cxx</CODE>
</P>
<P CLASS="BodyHang1">
<A NAME="pgfId=1015858">
 </A>
<CODE CLASS="Code">
include/instrmnt.h</CODE>
 	</P>
<P CLASS="BodyListFollow">
<A NAME="pgfId=1015872">
 </A>
Instrumentation. See source file <CODE CLASS="Code">
instrmnt/meminst.cxx</CODE>
</P>
<P CLASS="BodyHang1">
<A NAME="pgfId=1015891">
 </A>
<CODE CLASS="Code">
include/intr.hxx</CODE>
 	</P>
<P CLASS="BodyListFollow">
<A NAME="pgfId=1015905">
 </A>
Interrupts. See source file <CODE CLASS="Code">
intr/intr.cxx</CODE>
</P>
<P CLASS="BodyHang1">
<A NAME="pgfId=1015924">
 </A>
<CODE CLASS="Code">
include/kapi.h</CODE>
, </P>
<P CLASS="BodyHang1">
<A NAME="pgfId=1015938">
 </A>
<CODE CLASS="Code">
include/kapidata.h</CODE>
 	</P>
<P CLASS="BodyListFollow">
<A NAME="pgfId=1015948">
 </A>
Native 'C' API to the kernel. See source file <CODE CLASS="Code">
common/kapi.cxx</CODE>
</P>
<P CLASS="BodyHang1">
<A NAME="pgfId=1015967">
 </A>
<CODE CLASS="Code">
include/ktypes.h</CODE>
 	</P>
<P CLASS="BodyListFollow">
<A NAME="pgfId=1015981">
 </A>
Kernel types.</P>
<P CLASS="BodyHang1">
<A NAME="pgfId=1015991">
 </A>
<CODE CLASS="Code">
include/llistt.hxx</CODE>
 	</P>
<P CLASS="BodyListFollow">
<A NAME="pgfId=1016005">
 </A>
A simple doubly linked-list template class used elsewhere in the kernel.</P>
<P CLASS="BodyHang1">
<A NAME="pgfId=1016018">
 </A>
<CODE CLASS="Code">
include/lottery.hxx</CODE>
 	</P>
<P CLASS="BodyListFollow">
<A NAME="pgfId=1016032">
 </A>
Lottery scheduler implementation. See source file <CODE CLASS="Code">
sched/lottery.cxx</CODE>
</P>
<P CLASS="BodyHang1">
<A NAME="pgfId=1016051">
 </A>
<CODE CLASS="Code">
include/mbox.hxx</CODE>
, </P>
<P CLASS="BodyHang1">
<A NAME="pgfId=1016065">
 </A>
<CODE CLASS="Code">
include/mboxt.hxx</CODE>
, </P>
<P CLASS="BodyHang1">
<A NAME="pgfId=1016075">
 </A>
<CODE CLASS="Code">
include/mboxt2.hxx</CODE>
, </P>
<P CLASS="BodyHang1">
<A NAME="pgfId=1016085">
 </A>
<CODE CLASS="Code">
include/mboxt.inl</CODE>
, </P>
<P CLASS="BodyHang1">
<A NAME="pgfId=1016095">
 </A>
<CODE CLASS="Code">
include/mboxt2.inl</CODE>
 	</P>
<P CLASS="BodyListFollow">
<A NAME="pgfId=1016162">
 </A>
Message boxes. See source file <CODE CLASS="Code">
sync/mbox.cxx</CODE>
; <CODE CLASS="Code">
mboxt.hxx</CODE>
 and <CODE CLASS="Code">
mboxt2.hxx</CODE>
 and <CODE CLASS="Code">
mboxt.inl</CODE>
 and <CODE CLASS="Code">
mboxt2.inl</CODE>
 implement the underlying template function.</P>
<H3 CLASS="Label">
<A NAME="pgfId=1016173">
 </A>
NOTE</H3>
<P CLASS="Note">
<A NAME="pgfId=1076149">
 </A>
The files with a 2 suffix are used by default and provide precise <EM CLASS="FmSymbol">
&#181</EM>
ITRON semantics.</P>
<P CLASS="BodyHang1">
<A NAME="pgfId=1016188">
 </A>
<CODE CLASS="Code">
include/memfixed.hxx</CODE>
, </P>
<P CLASS="BodyHang1">
<A NAME="pgfId=1016202">
 </A>
<CODE CLASS="Code">
include/mempoolt.hxx</CODE>
, </P>
<P CLASS="BodyHang1">
<A NAME="pgfId=1016212">
 </A>
<CODE CLASS="Code">
include/mempolt2.hxx</CODE>
, </P>
<P CLASS="BodyHang1">
<A NAME="pgfId=1016222">
 </A>
<CODE CLASS="Code">
include/mempoolt.inl</CODE>
, </P>
<P CLASS="BodyHang1">
<A NAME="pgfId=1016232">
 </A>
<CODE CLASS="Code">
include/mempolt2.inl</CODE>
, </P>
<P CLASS="BodyHang1">
<A NAME="pgfId=1016242">
 </A>
<CODE CLASS="Code">
include/mfiximpl.hxx</CODE>
, </P>
<P CLASS="BodyHang1">
<A NAME="pgfId=1016252">
 </A>
<CODE CLASS="Code">
include/mfiximpl.inl</CODE>
 	</P>
<P CLASS="BodyListFollow">
<A NAME="pgfId=1016262">
 </A>
Fixed-block allocation memory pools. See source file <CODE CLASS="Code">
mem/memfixed.cxx</CODE>
; mempoolt[2] and mfiximpl are a thread-safety template function and underlying memory manager respectively.</P>
<H3 CLASS="Label">
<A NAME="pgfId=1016292">
 </A>
NOTE</H3>
<P CLASS="Note">
<A NAME="pgfId=1076150">
 </A>
The files with a 2 suffix are used by default and provide precise <EM CLASS="FmSymbol">
&#181</EM>
ITRON semantics.</P>
<P CLASS="BodyHang1">
<A NAME="pgfId=1016307">
 </A>
<CODE CLASS="Code">
include/memvar.hxx</CODE>
, </P>
<P CLASS="BodyHang1">
<A NAME="pgfId=1016321">
 </A>
<CODE CLASS="Code">
include/mempoolt.hxx</CODE>
, </P>
<P CLASS="BodyHang1">
<A NAME="pgfId=1016331">
 </A>
<CODE CLASS="Code">
include/mempolt2.hxx</CODE>
, </P>
<P CLASS="BodyHang1">
<A NAME="pgfId=1016341">
 </A>
<CODE CLASS="Code">
include/mempoolt.inl</CODE>
, </P>
<P CLASS="BodyHang1">
<A NAME="pgfId=1016351">
 </A>
<CODE CLASS="Code">
include/mempolt2.inl</CODE>
, </P>
<P CLASS="BodyHang1">
<A NAME="pgfId=1016361">
 </A>
<CODE CLASS="Code">
include/mvarimpl.hxx</CODE>
, </P>
<P CLASS="BodyHang1">
<A NAME="pgfId=1016371">
 </A>
<CODE CLASS="Code">
include/mvarimpl.inl</CODE>
 	</P>
<P CLASS="BodyListFollow">
<A NAME="pgfId=1016381">
 </A>
Variable-block allocation memory pools. See source file <CODE CLASS="Code">
mem/memvar.cxx</CODE>
; mempoolt[2] and mvar are a thread-safety template function and underlying memory manager respectively.</P>
<H3 CLASS="Label">
<A NAME="pgfId=1126518">
 </A>
NOTE</H3>
<P CLASS="Note">
<A NAME="pgfId=1126522">
 </A>
The files with a 2 suffix are used by default and provide precise <EM CLASS="FmSymbol">
&#181</EM>
ITRON semantics.</P>
<P CLASS="BodyHang1">
<A NAME="pgfId=1126491">
 </A>
<CODE CLASS="Code">
include/mlqueue.hxx</CODE>
 	</P>
<P CLASS="BodyListFollow">
<A NAME="pgfId=1016440">
 </A>
Multi-level queue scheduler. See source file <CODE CLASS="Code">
sched/mlqueue.cxx</CODE>
</P>
<P CLASS="BodyHang1">
<A NAME="pgfId=1016460">
 </A>
<CODE CLASS="Code">
include/mutex.hxx</CODE>
 	</P>
<P CLASS="BodyListFollow">
<A NAME="pgfId=1016474">
 </A>
Mutexes. See source file <CODE CLASS="Code">
sync/mutex.cxx</CODE>
</P>
<P CLASS="BodyHang1">
<A NAME="pgfId=1016493">
 </A>
<CODE CLASS="Code">
include/sched.hxx</CODE>
, </P>
<P CLASS="BodyHang1">
<A NAME="pgfId=1016507">
 </A>
<CODE CLASS="Code">
include/sched.inl</CODE>
 	</P>
<P CLASS="BodyListFollow">
<A NAME="pgfId=1016517">
 </A>
General scheduler functions. See source file <CODE CLASS="Code">
sched/sched.cxx</CODE>
</P>
<P CLASS="BodyHang1">
<A NAME="pgfId=1016536">
 </A>
<CODE CLASS="Code">
include/sema.hxx</CODE>
, </P>
<P CLASS="BodyHang1">
<A NAME="pgfId=1016550">
 </A>
<CODE CLASS="Code">
include/sema2.hxx</CODE>
 	</P>
<P CLASS="BodyListFollow">
<A NAME="pgfId=1016584">
 </A>
Semaphores. See source files <CODE CLASS="Code">
sync/cnt_sem.cxx</CODE>
 and <CODE CLASS="Code">
sync/bin_sem.cxx</CODE>
 for counting or binary semaphores respectively.</P>
<H3 CLASS="Label">
<A NAME="pgfId=1016595">
 </A>
NOTE</H3>
<P CLASS="Note">
<A NAME="pgfId=1076152">
 </A>
The file with a 2 suffix is used by default and provides precise <EM CLASS="FmSymbol">
&#181</EM>
ITRON semantics.</P>
<P CLASS="BodyHang1">
<A NAME="pgfId=1016610">
 </A>
<CODE CLASS="Code">
include/thread.hxx</CODE>
, </P>
<P CLASS="BodyHang1">
<A NAME="pgfId=1016624">
 </A>
<CODE CLASS="Code">
include/thread.inl</CODE>
 	</P>
<P CLASS="BodyListFollow">
<A NAME="pgfId=1016634">
 </A>
Threads, regardless of scheduler. See <CODE CLASS="Code">
common/thread.cxx</CODE>
</P>
</DIV>
<DIV>
<H3 CLASS="Heading1">
<A NAME="pgfId=1016653">
 </A>
<A NAME="marker=1084443">
 </A>
Kernel source files</H3>
<P CLASS="Body">
<A NAME="pgfId=1016663">
 </A>
The kernel source directory (<CODE CLASS="Code">
Cygnus/eCos/packages/kernel/</CODE>
<EM CLASS="Filename">
v1_3_x</EM>
<CODE CLASS="Code">
/src</CODE>
) is divided into a number of sub-directories each containing the source files for a particular kernel subsystem. These sources divide into two classes: those that are generic to all configurations, and those that are specific to a particular configuration. </P>
<H3 CLASS="Heading2">
<A NAME="pgfId=1016699">
 </A>
<A NAME="marker=1084446">
 </A>
<A NAME="11786">
 </A>
Sched subdirectory</H3>
<P CLASS="BodyHang1">
<A NAME="pgfId=1016709">
 </A>
<CODE CLASS="Code">
sched/sched.cxx</CODE>
 	</P>
<P CLASS="BodyListFollow">
<A NAME="pgfId=1016727">
 </A>
This contains the implementation of the base scheduler classes. The most important function here is <CODE CLASS="CodeOutput">
Cyg_Scheduler::unlock_inner()</CODE>
 which runs DSRs and performs any rescheduling and thread switching.</P>
<P CLASS="BodyHang1">
<A NAME="pgfId=1016754">
 </A>
<CODE CLASS="Code">
sched/bitmap.cxx</CODE>
 	</P>
<P CLASS="BodyListFollow">
<A NAME="pgfId=1016768">
 </A>
This contains the bitmap scheduler implementation. It represents each runnable thread with a bit in a bitmap. Each thread must have a unique priority and there is a strict upper limit on the number of threads allowed.</P>
<P CLASS="BodyHang1">
<A NAME="pgfId=1016786">
 </A>
<CODE CLASS="Code">
sched/mlqueue.cxx</CODE>
 	</P>
<P CLASS="BodyListFollow">
<A NAME="pgfId=1016800">
 </A>
This contains the multi-level queue scheduler implementation. It implements a number of thread priorities and is capable of timeslicing between threads at the same priority. This scheduler can also support priority inheritance.</P>
<P CLASS="BodyHang1">
<A NAME="pgfId=1016821">
 </A>
<CODE CLASS="Code">
sched/lottery.cxx</CODE>
 	</P>
<P CLASS="BodyListFollow">
<A NAME="pgfId=1084510">
 </A>
This contains the lottery scheduler implementation. This implements a CPU share scheduler based on threads holding a number of lottery tickets. At the start of each time quantum, a random number is generated and the thread holding the matching ticket is scheduled. Compensation tickets and ticket donation allow fair sharing for I/O bound threads and an equivalent mechanism to priority inheritance.</P>
<H3 CLASS="Label">
<A NAME="pgfId=1084526">
 </A>
NOTE</H3>
<P CLASS="Note">
<A NAME="pgfId=1084535">
 </A>
This scheduler is experimental, and is meant to test the behavior of other parts of the kernel with a non-orthodox scheduler. It is not meant to be used for real applications. It is currently under development and is incomplete.</P>
<H3 CLASS="Heading2">
<A NAME="pgfId=1084547">
 </A>
<A NAME="marker=1084568">
 </A>
Common subdirectory</H3>
<P CLASS="BodyHang1">
<A NAME="pgfId=1016898">
 </A>
<CODE CLASS="Code">
common/thread.cxx</CODE>
 	</P>
<P CLASS="BodyListFollow">
<A NAME="pgfId=1016916">
 </A>
This implements the basic thread classes. The functions in this file implement the basic thread controls to sleep and wake threads, change priorities and delay and time-out. Also defined here is the idle thread that runs when there is nothing else to do.</P>
<P CLASS="BodyHang1">
<A NAME="pgfId=1016938">
 </A>
<CODE CLASS="Code">
common/clock.cxx</CODE>
 	</P>
<P CLASS="BodyListFollow">
<A NAME="pgfId=1016952">
 </A>
This implements the counter, clock and alarm functions. Also defined here is the system real-time clock that is used to drive timeslicing, delays and time-outs.</P>
<P CLASS="BodyHang1">
<A NAME="pgfId=1016969">
 </A>
<CODE CLASS="Code">
common/kapi.cxx</CODE>
 	</P>
<P CLASS="BodyListFollow">
<A NAME="pgfId=1016983">
 </A>
This implements a C API to the basic kernel functions.</P>
<P CLASS="BodyHang1">
<A NAME="pgfId=1016995">
 </A>
<CODE CLASS="Code">
common/memcpy.c</CODE>
, </P>
<P CLASS="BodyHang1">
<A NAME="pgfId=1017009">
 </A>
<CODE CLASS="Code">
common/memset.c</CODE>
 	</P>
<P CLASS="BodyListFollow">
<A NAME="pgfId=1017019">
 </A>
Standard ANSI memcpy and memset operations; these are here because the compiler may invoke them for structure operations regardless of the presence of a C library.</P>
<H3 CLASS="Heading2">
<A NAME="pgfId=1017035">
 </A>
<A NAME="marker=1084571">
 </A>
Interrupt subdirectory</H3>
<P CLASS="BodyHang1">
<A NAME="pgfId=1017045">
 </A>
<CODE CLASS="Code">
intr/intr.cxx</CODE>
 	</P>
<P CLASS="BodyListFollow">
<A NAME="pgfId=1017063">
 </A>
This implements the Interrupt class. Most of this code is concerned with posting and calling DSRs. The remainder of the interrupt handling code is machine specific and is in <CODE CLASS="Code">
hal_intr.cxx</CODE>
 in the HAL directory.</P>
<H3 CLASS="Heading2">
<A NAME="pgfId=1017093">
 </A>
<A NAME="marker=1084574">
 </A>
Synchronization subdirectory</H3>
<P CLASS="BodyHang1">
<A NAME="pgfId=1017103">
 </A>
<CODE CLASS="Code">
sync/mutex.cxx</CODE>
 	</P>
<P CLASS="BodyListFollow">
<A NAME="pgfId=1017121">
 </A>
This contains the implementation of mutexes and condition variables. Mutexes can optionally be configured to use a priority inheritance mechanism supplied by the scheduler.</P>
<P CLASS="BodyHang1">
<A NAME="pgfId=1017137">
 </A>
<CODE CLASS="Code">
sync/cnt_sem.cxx</CODE>
 	</P>
<P CLASS="BodyListFollow">
<A NAME="pgfId=1017151">
 </A>
This contains the implementation of counting semaphores.</P>
<P CLASS="BodyHang1">
<A NAME="pgfId=1017163">
 </A>
<CODE CLASS="Code">
sync/cnt_sem2.cxx</CODE>
 	</P>
<P CLASS="BodyListFollow">
<A NAME="pgfId=1017177">
 </A>
This contains the alternate implementation of counting semaphores which implements precise <EM CLASS="FmSymbol">
&#181</EM>
ITRON semantics.</P>
<P CLASS="BodyHang1">
<A NAME="pgfId=1017193">
 </A>
<CODE CLASS="Code">
sync/bin_sem.cxx</CODE>
 	</P>
<P CLASS="BodyListFollow">
<A NAME="pgfId=1017207">
 </A>
This contains the implementation of binary semaphores.</P>
<P CLASS="BodyHang1">
<A NAME="pgfId=1017219">
 </A>
<CODE CLASS="Code">
sync/mbox.cxx</CODE>
 	</P>
<P CLASS="BodyListFollow">
<A NAME="pgfId=1017271">
 </A>
This contains wrapper functions for a message box of (void *) values. The implementation is the template defined in <CODE CLASS="Code">
include/mboxt.hxx</CODE>
 which <CODE CLASS="Code">
include/mboxt.inl</CODE>
 implements in turn. Message boxes exist in the kernel specifically to support <EM CLASS="FmSymbol">
&#181</EM>
ITRON compatibility.</P>
<P CLASS="BodyHang1">
<A NAME="pgfId=1017289">
 </A>
<CODE CLASS="Code">
sync/flag.cxx</CODE>
 	</P>
<P CLASS="BodyListFollow">
<A NAME="pgfId=1017303">
 </A>
This contains the implementation of flag objects. Flag objects exist in the kernel specifically to support <EM CLASS="FmSymbol">
&#181</EM>
ITRON compatibility.</P>
<H3 CLASS="Heading2">
<A NAME="pgfId=1017321">
 </A>
<A NAME="marker=1084577">
 </A>
Memory management subdirectory</H3>
<P CLASS="BodyHang1">
<A NAME="pgfId=1017331">
 </A>
<CODE CLASS="Code">
mem/memfixed.cxx</CODE>
 	</P>
<P CLASS="BodyListFollow">
<A NAME="pgfId=1017398">
 </A>
This contains the wrapper functions for a fixed-block allocation memory manager. The actual implementation is in two parts: <CODE CLASS="Code">
include/mfiximpl.hxx</CODE>
 implements the fixed-block memory management algorithms, and template <CODE CLASS="Code">
include/mempoolt.hxx</CODE>
 implements thread safety and waiting for memory management classes. These are combined in <CODE CLASS="Code">
memfixed.cxx</CODE>
. Memory pools exist in the kernel specifically to support <EM CLASS="FmSymbol">
&#181</EM>
ITRON compatibility.</P>
<P CLASS="BodyHang1">
<A NAME="pgfId=1017413">
 </A>
<CODE CLASS="Code">
mem/memvar.cxx</CODE>
 	</P>
<P CLASS="BodyListFollow">
<A NAME="pgfId=1017476">
 </A>
This contains the wrapper functions for a variable-block allocation memory manager. The actual implementation is in two parts: <CODE CLASS="Code">
include/mvarimpl.hxx</CODE>
 implements the variable-block memory management algorithms, and template <CODE CLASS="Code">
include/mempoolt.hxx</CODE>
 implements thread safety and waiting for memory management classes. These are combined in <CODE CLASS="Code">
memvar.cxx</CODE>
. Memory pools exist in the kernel specifically to support <EM CLASS="FmSymbol">
&#181</EM>
ITRON compatibility.</P>
<H3 CLASS="Heading2">
<A NAME="pgfId=1017491">
 </A>
<A NAME="marker=1084580">
 </A>
Instrumentation subdirectory</H3>
<P CLASS="BodyHang1">
<A NAME="pgfId=1017501">
 </A>
<CODE CLASS="Code">
instrmnt/meminst.cxx</CODE>
 	</P>
<P CLASS="BodyListFollow">
<A NAME="pgfId=1017519">
 </A>
This contains an implementation of the instrumentation mechanism that stores instrumentation records in a circular buffer in memory. The size of this buffer is configurable. The instrumentation flags mechanism allows the generation of instrumentation records to be controlled on a per-record basis. The header file <CODE CLASS="Code">
cyg/kernel/instrmnt.h</CODE>
 contains macros to generate instrumentation records in various places, and may be configured to only generate instrumentation records where required.</P>
<P CLASS="BodyHang1">
<A NAME="pgfId=1017566">
 </A>
<CODE CLASS="Code">
instrmnt/nullinst.cxx</CODE>
 	</P>
<P CLASS="BodyListFollow">
<A NAME="pgfId=1017608">
 </A>
This contains an implementation of the instrumentation mechanism that does nothing. By substituting its object file <CODE CLASS="Code">
nullinst.o</CODE>
 for <CODE CLASS="Code">
meminst.o</CODE>
 in a build, the instrumentation mechanism may be disabled without recompiling.</P>
<H3 CLASS="Heading2">
<A NAME="pgfId=1017621">
 </A>
<A NAME="marker=1084583">
 </A>
Trace subdirectory</H3>
<P CLASS="BodyHang1">
<A NAME="pgfId=1017631">
 </A>
<CODE CLASS="Code">
trace/simple.cxx</CODE>
 	</P>
<P CLASS="BodyListFollow">
<A NAME="pgfId=1017649">
 </A>
This contains an implementation of the trace and assert mechanisms that output textual messages via a set of externally defined functions. These are currently supplied by the code in <CODE CLASS="Code">
trace/diag.c</CODE>
 but may be supplied by a device driver in the future.</P>
<P CLASS="BodyHang1">
<A NAME="pgfId=1017679">
 </A>
<CODE CLASS="Code">
trace/fancy.cxx</CODE>
 	</P>
<P CLASS="BodyListFollow">
<A NAME="pgfId=1017693">
 </A>
This contains a (fancier) implementation of the trace and assert mechanisms that output textual messages via a set of externally defined functions. These are currently supplied by the code in <CODE CLASS="Code">
trace/diag.c</CODE>
 but may be supplied by a device driver in the future.</P>
<P CLASS="BodyListFollow">
<A NAME="pgfId=1017721">
 </A>
This more elaborate view was introduced mainly to validate the trace and assertion macros during development. </P>
<P CLASS="BodyHang1">
<A NAME="pgfId=1017732">
 </A>
<CODE CLASS="Code">
trace/null.cxx</CODE>
 	</P>
<P CLASS="BodyListFollow">
<A NAME="pgfId=1017773">
 </A>
This contains an implementation of the trace and assert mechanisms that do nothing. By substituting its object file <CODE CLASS="Code">
null.o</CODE>
 for <CODE CLASS="Code">
simple.o</CODE>
 in a build, the trace mechanisms may be disabled without recompiling.</P>
<P CLASS="BodyHang1">
<A NAME="pgfId=1017784">
 </A>
<CODE CLASS="Code">
trace/diag.c</CODE>
 	</P>
<P CLASS="BodyListFollow">
<A NAME="pgfId=1017798">
 </A>
This contains a number of diagnostic routines that use the HAL supplied diagnostic output mechanism to format and print strings and numbers. There is currently no formatted output.</P>
<P CLASS="BodyHang1">
<A NAME="pgfId=1017816">
 </A>
<CODE CLASS="Code">
trace/tcdiag.c</CODE>
 	</P>
<P CLASS="BodyListFollow">
<A NAME="pgfId=1017830">
 </A>
This contains an implementation of the testing internal API which uses the kernel's diagnostic routines to perform output.</P>
<H3 CLASS="Heading2">
<A NAME="pgfId=1017844">
 </A>
<A NAME="marker=1084586">
 </A>
Sload subdirectory</H3>
<P CLASS="Body">
<A NAME="pgfId=1017854">
 </A>
This contains the sources of a simple S-Record loader that may be used in a ROM for various microprocessor development boards to download code via a serial port.</P>
<H3 CLASS="Heading2">
<A NAME="pgfId=1017865">
 </A>
<A NAME="marker=1084589">
 </A>
HAL source files</H3>
<P CLASS="Body">
<A NAME="pgfId=1017901">
 </A>
The HAL is divided into architecture- and platform-specific files. For each architecture supported, there is an <CODE CLASS="Code">
arch</CODE>
 directory, containing files generic to that architecture, and a <CODE CLASS="Code">
platform</CODE>
 directory, containing files specific to each platform supported.</P>
<P CLASS="Body">
<A NAME="pgfId=1017912">
 </A>
Amongst the architectures supported are: the PowerPC, the Tx39 and the MN10300. To find the code corresponding to each architecture, substitute &quot;powerpc&quot;, &quot;mips&quot; and &quot;mn10300&quot;, respectively, for &quot;ARCH&quot; in the following file descriptions. Similarly substitute the appropriate platform name representing your development board for &quot;PLATFORM&quot;.</P>
<H3 CLASS="Heading2">
<A NAME="pgfId=1017940">
 </A>
<A NAME="marker=1084592">
 </A>
Architecture files</H3>
<P CLASS="BodyHang1">
<A NAME="pgfId=1017950">
 </A>
<CODE CLASS="Code">
ARCH/arch/</CODE>
<EM CLASS="Filename2">
v1_3_x</EM>
<CODE CLASS="Code">
/include/basetype.h</CODE>
 	</P>
<P CLASS="BodyListFollow">
<A NAME="pgfId=1017973">
 </A>
This file is used to define the base architecture configuration such as endianness and word size.</P>
<P CLASS="BodyHang1">
<A NAME="pgfId=1017985">
 </A>
<CODE CLASS="Code">
ARCH/arch/</CODE>
<EM CLASS="Filename2">
v1_3_x</EM>
<CODE CLASS="Code">
/include/hal_arch.h</CODE>
 	</P>
<P CLASS="BodyListFollow">
<A NAME="pgfId=1018004">
 </A>
This file contains macros that implement various architecture-specific functions. The most important macros here are the thread context initialization and switch macros that are used to implement multithreading.</P>
<P CLASS="BodyHang1">
<A NAME="pgfId=1018025">
 </A>
<CODE CLASS="Code">
ARCH/arch/</CODE>
<EM CLASS="Filename2">
v1_3_x</EM>
<CODE CLASS="Code">
/include/hal_intr.h</CODE>
 	</P>
<P CLASS="BodyListFollow">
<A NAME="pgfId=1018044">
 </A>
This file contains the HAL support for interrupt management and clock support.</P>
<P CLASS="BodyHang1">
<A NAME="pgfId=1018056">
 </A>
<CODE CLASS="Code">
ARCH/arch/</CODE>
<EM CLASS="Filename2">
v1_3_x</EM>
<CODE CLASS="Code">
/include/hal_io.h</CODE>
 	</P>
<P CLASS="BodyListFollow">
<A NAME="pgfId=1018075">
 </A>
This file contains the HAL support for accessing hardware registers. It provides a portable API that allows more generic device drivers to be written.</P>
<P CLASS="BodyHang1">
<A NAME="pgfId=1018091">
 </A>
<CODE CLASS="Code">
ARCH/arch/</CODE>
<EM CLASS="Filename2">
v1_3_x</EM>
<CODE CLASS="Code">
/include/hal_cache.h</CODE>
 	</P>
<P CLASS="BodyListFollow">
<A NAME="pgfId=1018110">
 </A>
This file contains macros to control any caches that may be present.</P>
<P CLASS="BodyHang1">
<A NAME="pgfId=1090865">
 </A>
<CODE CLASS="Code">
ARCH/arch/</CODE>
<EM CLASS="Filename2">
v1_3_x</EM>
<CODE CLASS="Code">
/include/ARCH_stub.h</CODE>
 	</P>
<P CLASS="BodyListFollow">
<A NAME="pgfId=1090875">
 </A>
This file contains architectural information for a GDB stub, such as the register layout in a GDB packet.</P>
<P CLASS="BodyHang1">
<A NAME="pgfId=1090878">
 </A>
<CODE CLASS="Code">
ARCH/arch/</CODE>
<EM CLASS="Filename2">
v1_3_x</EM>
<CODE CLASS="Code">
/src/vectors.S</CODE>
 	</P>
<P CLASS="BodyListFollow">
<A NAME="pgfId=1018141">
 </A>
This is an assembly code file that contains the code to handle interrupt and exception vectors. Since system reset can also be considered an exception, this is handled here also. Interrupts are currently handled by placing a stub routine in the hardware vector which calls a Vector Service Routine via an indirection table. There is a API to allow user-defined VSRs to be installed. The default VSR reads the interrupt controller registers and decodes the interrupt source into an offset into a further table of interrupt service routines. It also handles interrupt cleanup, which may result in the execution of deferred service routines (DSRs) and the preemption of the current thread.</P>
<P CLASS="BodyHang1">
<A NAME="pgfId=1018186">
 </A>
<CODE CLASS="Code">
ARCH/arch/</CODE>
<EM CLASS="Filename2">
v1_3_x</EM>
<CODE CLASS="Code">
/src/context.S</CODE>
 	</P>
<P CLASS="BodyListFollow">
<A NAME="pgfId=1018205">
 </A>
If present, this is an assembly code file that contains the code to support thread contexts. The routines to switch between various contexts, as well as initialize a thread context may be present in this file.</P>
<P CLASS="BodyHang1">
<A NAME="pgfId=1018227">
 </A>
<CODE CLASS="Code">
ARCH/arch/</CODE>
<EM CLASS="Filename2">
v1_3_x</EM>
<CODE CLASS="Code">
/src/hal_misc.c</CODE>
 	</P>
<P CLASS="BodyListFollow">
<A NAME="pgfId=1018246">
 </A>
This file contains the implementation of various miscellaneous HAL routines that are needed by the kernel or C++ runtime.</P>
<P CLASS="BodyHang1">
<A NAME="pgfId=1090910">
 </A>
<CODE CLASS="Code">
ARCH/arch/</CODE>
<EM CLASS="Filename2">
v1_3_x</EM>
<CODE CLASS="Code">
/src/ARCH_stub.c</CODE>
 	</P>
<P CLASS="BodyListFollow">
<A NAME="pgfId=1090920">
 </A>
This file contains the architectural part of a GDB stub. This deals with CPU-specific details of the stub, such as the setting of breakpoints and translating exception data into signals that GDB understands.</P>
<P CLASS="BodyHang1">
<A NAME="pgfId=1090944">
 </A>
<CODE CLASS="Code">
ARCH/arch/</CODE>
<EM CLASS="Filename2">
v1_3_x</EM>
<CODE CLASS="Code">
/src/ARCH.ld</CODE>
 	</P>
<P CLASS="BodyListFollow">
<A NAME="pgfId=1090951">
 </A>
This file is the linker script. During preprocessing it includes linker script fragments that define the memory layout.</P>
<H3 CLASS="Heading2">
<A NAME="pgfId=1018260">
 </A>
P<A NAME="marker=1084595">
 </A>
latform files</H3>
<P CLASS="BodyHang1">
<A NAME="pgfId=1018270">
 </A>
<CODE CLASS="Code">
ARCH/PLATFORM/</CODE>
<EM CLASS="Filename2">
v1_3_x</EM>
<CODE CLASS="Code">
/include/hal_diag.h</CODE>
 	</P>
<P CLASS="BodyListFollow">
<A NAME="pgfId=1018293">
 </A>
This file contains the definitions of macros that support the HAL diagnostic output mechanism.</P>
<P CLASS="BodyHang1">
<A NAME="pgfId=1091012">
 </A>
<CODE CLASS="Code">
ARCH/PLATFORM/</CODE>
<EM CLASS="Filename2">
v1_3_x</EM>
<CODE CLASS="Code">
/include/plf_stub.h</CODE>
 	</P>
<P CLASS="BodyListFollow">
<A NAME="pgfId=1091019">
 </A>
This file contains a set of macros that allow the common GDB stub code to access the platform-specific minimal serial driver functions.</P>
<P CLASS="BodyHang1">
<A NAME="pgfId=1091025">
 </A>
<CODE CLASS="Code">
ARCH/PLATFORM/</CODE>
<EM CLASS="Filename2">
v1_3_x</EM>
<CODE CLASS="Code">
/src/hal_diag.c</CODE>
 	</P>
<P CLASS="BodyListFollow">
<A NAME="pgfId=1018324">
 </A>
This file contain the implementation of the HAL diagnostic output mechanism.</P>
<P CLASS="BodyHang1">
<A NAME="pgfId=1091046">
 </A>
<CODE CLASS="Code">
ARCH/PLATFORM/</CODE>
<EM CLASS="Filename2">
v1_3_x</EM>
<CODE CLASS="Code">
/src/plf_stub.c</CODE>
 	</P>
<P CLASS="BodyListFollow">
<A NAME="pgfId=1091053">
 </A>
This file contains a minimal serial driver for the target platform that is used by the GDB stub.</P>
<P CLASS="BodyHang1">
<A NAME="pgfId=1091059">
 </A>
<CODE CLASS="Code">
ARCH/PLATFORM/</CODE>
<EM CLASS="Filename2">
v1_3_x</EM>
<CODE CLASS="Code">
/src/PLATFORM.S</CODE>
 	</P>
<P CLASS="BodyListFollow">
<A NAME="pgfId=1018355">
 </A>
This is an assembler file that contains any platform-specific code. It often contains platform initialization code called from vectors.S.</P>
</DIV>
<HR ALIGN="center"><TABLE STYLE="ECOS" WIDTH="98%" BORDER="0" ALIGN="LEFT" CELLPADDING="1"><TR><TH COLSPAN="3" ALIGN="center"><P CLASS="Gotos">A tour of the kernel sources</P></TH></TR><TR><TD  ALIGN="center"><P CLASS="Gotos"><A HREF="ecos-ref.2.html">To Contents</A></P></TD><TD  ALIGN="center"><P CLASS="Gotos"><A HREF="ecos-ref.4.html">To&nbsp;previous&nbsp;page</A></P></TD><TD  ALIGN="center"><P CLASS="Gotos"><A HREF="ecos-ref.6.html">To&nbsp;next&nbsp;page</A></P></TD></TR></TABLE></BODY>
</HTML>
