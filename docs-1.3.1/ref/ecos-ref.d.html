<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML EXPERIMENTAL 970324//EN">
<HTML>
<HEAD>
<META NAME="GENERATOR" CONTENT="Adobe FrameMaker 5.5/HTML Export Filter">
<LINK REL="STYLESHEET" HREF="cygnus.css">
<TITLE> The eCos PCI Library</TITLE></HEAD>
<BODY BGCOLOR="#ffffff">
<DIV>
<TABLE STYLE="ECOS" WIDTH="98%" BORDER="0" ALIGN="LEFT" CELLPADDING="1"><TR><TH COLSPAN="3" ALIGN="center"><P CLASS="Gotos">The eCos PCI Library</P></TH></TR><TR><TD  ALIGN="center"><P CLASS="Gotos"><A HREF="ecos-ref.2.html">To Contents</A></P></TD><TD  ALIGN="center"><P CLASS="Gotos"><A HREF="ecos-ref.c2.html">To&nbsp;previous&nbsp;page</A></P></TD><TD ALIGN="center"><P CLASS="Gotos"><A HREF="ecos-ref.e.html">To&nbsp;next&nbsp;page</A></P></TD></TR></TABLE><P ALIGN="LEFT">&nbsp;</P><BR><BR><HR ALIGN="center"></DIV>
<H2 CLASS="ChapterTitle">
<A NAME="pgfId=1157964">
 </A>
The eCos PCI Library<DIV>
<IMG SRC="botclear.gif">
</DIV>
</H2>
<P CLASS="Body">
<A NAME="pgfId=1158795">
 </A>
The PCI library is an optional part of eCos, and is only applicable to some packages.</P>
<DIV>
<H3 CLASS="Heading1">
<A NAME="pgfId=1157972">
 </A>
PCI Library</H3>
<P CLASS="Body">
<A NAME="pgfId=1157977">
 </A>
The eCos PCI library provides the following functionality:</P>
<P CLASS="Body">
<A NAME="pgfId=1157981">
 </A>
1) Scan the PCI bus for specific devices or devices of a certain class.<BR>
2) Read and change generic PCI information.<BR>
3) Read and change device-specific PCI information.<BR>
4) Allocate PCI memory and IO space to devices.<BR>
5) Translate a device's PCI interrupts to equivalent HAL vectors.</P>
<P CLASS="Body">
<A NAME="pgfId=1157986">
 </A>
Example code fragments are from the pci1 test (see</P>
<P CLASS="Body">
<A NAME="pgfId=1157988">
 </A>
io/pci/&lt;release&gt;/tests/pci1.c).</P>
<P CLASS="Body">
<A NAME="pgfId=1157992">
 </A>
All of the functions described below are declared in the header file &lt;cyg/io/pci.h&gt; which all clients of the PCI library should include.</P>
<H3 CLASS="Heading2">
<A NAME="pgfId=1158001">
 </A>
Initialising the bus</H3>
<P CLASS="Body">
<A NAME="pgfId=1158005">
 </A>
The PCI bus needs to be initialized before it can be used. This only needs to be done once - some HALs may do it as part of the platform initialization procedure, other HALs may leave it to the application to do it. The following function will do the initialization only once, so it's safe to call from multiple drivers:</P>
<PRE CLASS="CodeExample"><A NAME="pgfId=1158012"> </A>
void cyg_pci_init( void );</PRE>
<H3 CLASS="Heading2">
<A NAME="pgfId=1158020">
 </A>
Scanning for devices</H3>
<P CLASS="Body">
<A NAME="pgfId=1158024">
 </A>
After the bus has been initialized, it is possible to scan it for devices. This is done using the function:</P>
<PRE CLASS="CodeExample"><A NAME="pgfId=1158029"> </A>
cyg_bool cyg_pci_find_next( cyg_pci_device_id cur_devid, 
	                     cyg_pci_device_id *next_devid );</PRE>
<P CLASS="Body">
<A NAME="pgfId=1158034">
 </A>
It will scan the bus for devices starting at cur_devid. If a device is found, its devid is stored in next_devid and the function returns true.</P>
<P CLASS="Body">
<A NAME="pgfId=1158040">
 </A>
The pci1 test's outer loop looks like:</P>
<PRE CLASS="CodeExample"><A NAME="pgfId=1158044"> </A>
cyg_pci_init();
    if (cyg_pci_find_next(CYG_PCI_NULL_DEVID, &amp;devid)) {
        do {
             &lt;use devid&gt;
        } while (cyg_pci_find_next(devid, &amp;devid));
    }</PRE>
<P CLASS="Body">
<A NAME="pgfId=1158049">
 </A>
What happens is that the bus gets initialized and a scan is started. CYG_PCI_NULL_DEVID causes cyg_pci_find_next() to restart its scan. If the bus does not contain any devices, the first call to cyg_pci_find_next() will return false.</P>
<P CLASS="Body">
<A NAME="pgfId=1158054">
 </A>
If the call returns true, a loop is entered where the found devid is used. After devid processing has completed, the next device on the bus is searched for; cyg_pci_find_next() continues its scan from the current devid. The loop terminates when no more devices are found on the bus.</P>
<P CLASS="Body">
<A NAME="pgfId=1158059">
 </A>
This is the generic way of scanning the bus, enumerating all the devices on the bus. But if the application is looking for a device of a given device class (e.g., a SCSI controller), or a specific vendor device, these functions simplify the task a bit:</P>
<PRE CLASS="CodeExample"><A NAME="pgfId=1158064"> </A>
cyg_bool cyg_pci_find_class( cyg_uint32 dev_class,
                              cyg_pci_device_id *devid );
cyg_bool cyg_pci_find_device( cyg_uint16 vendor, cyg_uint16 device,
                               cyg_pci_device_id *devid );</PRE>
<P CLASS="Body">
<A NAME="pgfId=1158069">
 </A>
They work just like cyg_pci_find_next(), but only return true when the, dev_class or vendor/device qualifiers match those of a device on the bus. The devid serves as both an input and an output operand: the scan starts at the given device, and if a device is found devid is updated with the value for the found device.</P>
<P CLASS="Body">
<A NAME="pgfId=1158074">
 </A>
The &lt;cyg/io/pci_cfg.h&gt; header file (included by pci.h) contains definitions for PCI class, vendor and device codes which can be used as arguments to the find functions. The list of vendor and device codes is not complete: add new codes as necessary. If possible also register the codes at the PCI Code List (http://www.yourvote.com/pci) which is where the eCos definitions are generated from.</P>
<H3 CLASS="Heading2">
<A NAME="pgfId=1158084">
 </A>
Generic config information</H3>
<P CLASS="Body">
<A NAME="pgfId=1158088">
 </A>
When a valid device ID (devid) is found using one of the above functions, the associated device can be queried and controlled using the functions:</P>
<PRE CLASS="CodeExample"><A NAME="pgfId=1158093"> </A>
void cyg_pci_get_device_info ( cyg_pci_device_id devid, 
                                cyg_pci_device *dev_info );
void cyg_pci_set_device_info ( cyg_pci_device_id devid, 
                                cyg_pci_device *dev_info );</PRE>
<P CLASS="Body">
<A NAME="pgfId=1158098">
 </A>
The cyg_pci_device structure (defined in pci.h) primarily holds information as described by the PCI specification [1]. The pci1 test prints out some of this information:</P>
<PRE CLASS="CodeExample"><A NAME="pgfId=1158103"> </A>
           // Get device info
            cyg_pci_get_device_info(devid, &amp;dev_info);
            diag_printf(&quot;\n Command   0x%04x, Status 0x%04x\n&quot;,
                        dev_info.command, dev_info.status);</PRE>
<P CLASS="Body">
<A NAME="pgfId=1158108">
 </A>
The command register can also be written to, controlling (among other things) whether the device responds to IO and memory access from the bus. </P>
<H3 CLASS="Heading2">
<A NAME="pgfId=1158118">
 </A>
Specific config information</H3>
<P CLASS="Body">
<A NAME="pgfId=1158122">
 </A>
The above functions only allow access to generic PCI config registers. A device can have extra config registers not specified by the PCI specification. These can be accessed with these functions:</P>
<PRE CLASS="CodeExample"><A NAME="pgfId=1158127"> </A>
void cyg_pci_read_config_uint8( cyg_pci_device_id devid,
                                 cyg_uint8 offset, cyg_uint8 *val);
void cyg_pci_read_config_uint16( cyg_pci_device_id devid,
                                  cyg_uint8 offset, cyg_uint16 *val);
void cyg_pci_read_config_uint32( cyg_pci_device_id devid,
                                  cyg_uint8 offset, cyg_uint32 *val);
void cyg_pci_write_config_uint8( cyg_pci_device_id devid,
                                  cyg_uint8 offset, cyg_uint8 val);
void cyg_pci_write_config_uint16( cyg_pci_device_id devid,
                                   cyg_uint8 offset, cyg_uint16 val);
void cyg_pci_write_config_uint32( cyg_pci_device_id devid,
                                   cyg_uint8 offset, cyg_uint32 val);</PRE>
<P CLASS="Body">
<A NAME="pgfId=1158132">
 </A>
The write functions should only be used for device-specific config registers since using them on generic registers may invalidate the contents of a previously fetched cyg_pci_device structure.</P>
<H3 CLASS="Heading2">
<A NAME="pgfId=1158142">
 </A>
Allocating memory</H3>
<P CLASS="Body">
<A NAME="pgfId=1158146">
 </A>
A PCI device ignores all IO and memory access from the PCI bus until it has been activated. Activation cannot happen until after device configuration. Configuration means telling the device where it should map its IO and memory resources. This is done with this function:</P>
<PRE CLASS="CodeExample"><A NAME="pgfId=1158152"> </A>
cyg_bool cyg_pci_configure_device( cyg_pci_device *dev_info );</PRE>
<P CLASS="Body">
<A NAME="pgfId=1158156">
 </A>
This function handles all IO and memory regions that need configuration on the device. Each region is represented in the PCI device's config space by one of six BARs (Base Address Registers) and is handled individually according to type using these functions:</P>
<PRE CLASS="CodeExample"><A NAME="pgfId=1158161"> </A>
cyg_bool cyg_pci_allocate_memory( cyg_pci_device *dev_info,
                                   cyg_uint32 bar, 
                                   CYG_PCI_ADDRESS64 *base );
 cyg_bool cyg_pci_allocate_io( cyg_pci_device *dev_info,
                               cyg_uint32 bar, 
                               CYG_PCI_ADDRESS32 *base );</PRE>
<P CLASS="Body">
<A NAME="pgfId=1158166">
 </A>
The memory bases (in two distinct address spaces) are increased as memory regions are allocated to devices. Allocation will fail (the function returns false) if the base exceeds the limits of the address space (IO is 1MB, memory is 2^32 or 2^64 bytes).</P>
<P CLASS="Body">
<A NAME="pgfId=1158171">
 </A>
These functions can also be called directly be the application/driver if necessary, but this should not be necessary.</P>
<P CLASS="Body">
<A NAME="pgfId=1158176">
 </A>
The bases are initialized with default values provided by the HAL. It is possible for an application to override these using the following functions: </P>
<PRE CLASS="CodeExample"><A NAME="pgfId=1158181"> </A>
void cyg_pci_set_memory_base( CYG_PCI_ADDRESS64 base );
void cyg_pci_set_io_base( CYG_PCI_ADDRESS32 base );</PRE>
<P CLASS="Body">
<A NAME="pgfId=1158186">
 </A>
When a device has been configured, the cyg_pci_device structure will contain the physical address in the CPU's address space where the device's memory regions can be accessed. </P>
<P CLASS="Body">
<A NAME="pgfId=1158191">
 </A>
This information is provided in base_map[] - there is a 32 bit word for each of the device's BARs. For 32 bit PCI memory regions, each 32 bit word will be an actual pointer that can be used immediately by the driver: the memory space will normally be linearly addressable by the CPU.</P>
<P CLASS="Body">
<A NAME="pgfId=1158196">
 </A>
However, for 64 bit PCI memory regions, some (or all) of the region may be outside of the CPUs address space. In this case the driver will need to know how to access the region in segments. This functionality may be adopted by the eCos HAL if deemed useful in the future. The 2GB available on many systems should suffice though.</P>
<H3 CLASS="Heading2">
<A NAME="pgfId=1158206">
 </A>
Interrupts</H3>
<P CLASS="Body">
<A NAME="pgfId=1158210">
 </A>
A device may generate interrupts. The HAL vector associated with a given device on the bus is platform specific. This function allows a driver to find the actual interrupt vector for a given device:</P>
<PRE CLASS="CodeExample"><A NAME="pgfId=1158215"> </A>
cyg_bool cyg_pci_translate_interrupt( cyg_pci_device *dev_info,
                                       CYG_ADDRWORD *vec );</PRE>
<P CLASS="Body">
<A NAME="pgfId=1158220">
 </A>
If the function returns false, no interrupts will be generated by the device. If it returns true, the CYG_ADDRWORD pointed to by vec is updated with the HAL interrupt vector the device will be using. This is how the function is used in the pci1 test:</P>
<PRE CLASS="CodeExample"><A NAME="pgfId=1158225"> </A>
            if (cyg_pci_translate_interrupt(&amp;dev_info, &amp;irq))
                diag_printf(&quot; Wired to HAL vector %d\n&quot;, irq);
            else</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1158227"> </A>
                diag_printf(&quot; Does not generate interrupts.\n&quot;);</PRE>
<P CLASS="Body">
<A NAME="pgfId=1158231">
 </A>
The application/drive should attach an interrupt handler to a device's interrupt before activating the device.</P>
<H3 CLASS="Heading2">
<A NAME="pgfId=1158241">
 </A>
Activating a device</H3>
<P CLASS="Body">
<A NAME="pgfId=1158245">
 </A>
When the device has been allocated memory space it can be activated. This is not done by the library since a driver may have to initialize more state on the device before it can be safely activated.</P>
<P CLASS="Body">
<A NAME="pgfId=1158250">
 </A>
Activating the device is done by enabling flags in its command word. As an example, see the pci1 test which can be configured to enable the devices it finds. This allows these to be accessed from GDB (if a breakpoint is set on cyg_test_exit):</P>
<PRE CLASS="CodeExample"><A NAME="pgfId=1158255"> </A>
#ifdef ENABLE_PCI_DEVICES
                {
                    cyg_uint16 cmd;
</PRE>
<PRE CLASS="CodeExample"><A NAME="pgfId=1158256"> </A>
                    // Don't use cyg_pci_set_device_info since it clears
                    // some of the fields we want to print out below.
                    cyg_pci_read_config_uint16(dev_info.devid,
                                               CYG_PCI_CFG_COMMAND, &amp;cmd);
                    cmd |=
CYG_PCI_CFG_COMMAND_IO|CYG_PCI_CFG_COMMAND_MEMORY;
                    cyg_pci_write_config_uint16(dev_info.devid,
                                                CYG_PCI_CFG_COMMAND, cmd);
                }
                diag_printf(&quot; **** Device IO and MEM access enabled\n&quot;);
#endif</PRE>
<P CLASS="Body">
<A NAME="pgfId=1158261">
 </A>
 Note: that the best way to activate a device is actually through cyg_pci_set_device_info(), but in this particular case the cyg_pci_device structure contents from before the activation is required for printout further down in the code.</P>
<H3 CLASS="Heading2">
<A NAME="pgfId=1158271">
 </A>
Links</H3>
<P CLASS="Body">
<A NAME="pgfId=1158276">
 </A>
See these links for more information about PCI.</P>
<P CLASS="Body">
<A NAME="pgfId=1158280">
 </A>
1) See http://www.pcisig.com  (information on the PCI specifications)<BR>
2) See http://www.yourvote.com/pci  (list of vendor and device IDs)<BR>
3) See http://www.picmg.org  (PCI Industrial Computer Manufacturers Group)</P>
</DIV>
<DIV>
<H3 CLASS="Heading1">
<A NAME="pgfId=1158291">
 </A>
PCI Library reference</H3>
<P CLASS="Body">
<A NAME="pgfId=1158296">
 </A>
This document defines the PCI Support Library for eCos.</P>
<P CLASS="Body">
<A NAME="pgfId=1158300">
 </A>
The PCI support library provides a set of routines for accessing the PCI bus configuration space in a portable manner. This is provided by two APIs. The high level API is used by device drivers, or other code, to access the PCI configuration space portably. The low level API is used by the PCI library itself to access the hardware in a platform-specific manner, and may also be used by device drivers to access the PCI configuration space directly.</P>
<P CLASS="Body">
<A NAME="pgfId=1158305">
 </A>
Underlying the low-level API is HAL support for the basic Configuration space operations. These should not generally be used by any code other than the PCI library, and are present in the HAL to allow low level initialization of the PCI bus and devices to take place if necessary.</P>
<H3 CLASS="Heading2">
<A NAME="pgfId=1158314">
 </A>
PCI Library API</H3>
<P CLASS="Body">
<A NAME="pgfId=1158318">
 </A>
The PCI library provides the following routines and types for accessing the PCI configuration space.</P>
<P CLASS="Body">
<A NAME="pgfId=1158325">
 </A>
The API for the PCI library is found in the header file &lt;cyg/io/pci.h&gt;.</P>
<H3 CLASS="Heading2">
<A NAME="pgfId=1158333">
 </A>
Definitions</H3>
<P CLASS="Body">
<A NAME="pgfId=1158337">
 </A>
The header file contains definitions for the common configuration structure offsets and specimin values for device, vendor and class code.</P>
<H3 CLASS="Heading2">
<A NAME="pgfId=1158347">
 </A>
Types and data structures</H3>
<P CLASS="Body">
<A NAME="pgfId=1158352">
 </A>
The following types are defined:</P>
<PRE CLASS="CodeExample"><A NAME="pgfId=1158357"> </A>
typedef CYG_WORD32 cyg_pci_device_id;</PRE>
<P CLASS="Body">
<A NAME="pgfId=1158361">
 </A>
This is comprised of the bus number, device number and functional unit number packed into a single word. The macro CYG_PCI_DEV_MAKE_ID() may be used to construct a device id from the bus, device and functional unit numbers of a device. Similarly the macros CYG_PCI_DEV_GET_BUS() and CYG_PCI_DEV_GET_DEVFN() may be used to extract them. It should not be necessary to use these macros under normal circumstances.</P>
<PRE CLASS="CodeExample"><A NAME="pgfId=1158367"> </A>
typedef struct cyg_pci_device;</PRE>
<P CLASS="Body">
<A NAME="pgfId=1158371">
 </A>
This structure is used to contain data read from a PCI device's configuration header by cyg_pci_get_device_info(). It is also used to record the resource allocations made to the device.</P>
<PRE CLASS="CodeExample"><A NAME="pgfId=1158376"> </A>
typedef CYG_WORD64 CYG_PCI_ADDRESS64;
typedef CYG_WORD32 CYG_PCI_ADDRESS32;</PRE>
<P CLASS="Body">
<A NAME="pgfId=1158381">
 </A>
Pointers in the PCI address space are 32 bit (IO space) or 32/64 bit (memory space). In most platform and device configurations all of PCI memory will be linearly addressable using only 32 bit pointers as read from base_map[].</P>
<P CLASS="Body">
<A NAME="pgfId=1158386">
 </A>
The 64 bit type is used to allow handling 64 bit devices in the future, should it be necessary, without changing the library's API.</P>
<H3 CLASS="Heading2">
<A NAME="pgfId=1158396">
 </A>
Functions</H3>
<PRE CLASS="CodeExampleWide"><A NAME="pgfId=1158401"> </A>
void cyg_pci_init(void);</PRE>
<P CLASS="Body">
<A NAME="pgfId=1158405">
 </A>
Initialize the PCI library and establish contact with the hardware. This function is idempotent and can be called either by all drivers in the system, or just from an application initialization function.</P>
<PRE CLASS="CodeExampleWide"><A NAME="pgfId=1158410"> </A>
cyg_bool cyg_pci_find_device( cyg_uint16 vendor,
			      cyg_uint16 device,
			      cyg_pci_device_id *devid );</PRE>
<P CLASS="Body">
<A NAME="pgfId=1158415">
 </A>
Searches the PCI bus configuration space for a device with the given vendor and device ids. The search starts at the device pointed to by devid, or at the first slot if it contains CYG_PCI_NULL_DEVID. *devid will be updated with the ID of the next device found. Returns true if one is found and false if not.</P>
<PRE CLASS="CodeExampleWide"><A NAME="pgfId=1452843"> </A>
cyg_bool cyg_pci_find_class( cyg_uint32 dev_class,
			     cyg_pci_device_id *devid );</PRE>
<P CLASS="Body">
<A NAME="pgfId=1452844">
 </A>
Searches the PCI bus configuration space for a device with the given class code.  The search starts at the device pointed to by devid, or at the first slot if it contains CYG_PCI_NULL_DEVID.</P>
<P CLASS="Body">
<A NAME="pgfId=1158426">
 </A>
*devid will be updated with the ID of the next device found. Returns true if one is found and false if not.</P>
<PRE CLASS="CodeExampleWide"><A NAME="pgfId=1158431"> </A>
cyg_bool cyg_pci_find_next( cyg_pci_device_id cur_devid,
			    cyg_pci_device_id *next_devid );</PRE>
<P CLASS="Body">
<A NAME="pgfId=1158436">
 </A>
Searches the PCI configuration space for the next valid device after cur_devid. If cur_devid is given the value CYG_PCI_NULL_DEVID, then the search starts at the first slot. It is permitted for next_devid to point to cur_devid.  Returns true if another device is found and false if not.</P>
<PRE CLASS="CodeExampleWide"><A NAME="pgfId=1158441"> </A>
void cyg_pci_get_device_info ( cyg_pci_device_id devid,
			       cyg_pci_device *dev_info );</PRE>
<P CLASS="Body">
<A NAME="pgfId=1158446">
 </A>
This function gets the PCI configuration information for the device indicated in devid. The common fields of the cyg_pci_device structure, and the appropriate fields of the relevant header union member are filled in from the device's configuration space. If the device has not been enabled, then this function will also fetch the size and type information from the base address registers and place it in the base_size[] array.</P>
<PRE CLASS="CodeExampleWide"><A NAME="pgfId=1158451"> </A>
void cyg_pci_set_device_info ( cyg_pci_device_id devid,
			       cyg_pci_device *dev_info );</PRE>
<P CLASS="Body">
<A NAME="pgfId=1158456">
 </A>
This function sets the PCI configuration information for the device indicated in devid. Only the configuration space registers that are writable are actually written. Once all the fields have been written, the device info will be read back into *dev_info, so that it reflects the true state of the hardware.</P>
<PRE CLASS="CodeExampleWide"><A NAME="pgfId=1158461"> </A>
void cyg_pci_read_config_uint8( cyg_pci_device_id devid, cyg_uint8 offset, cyg_uint8 *val );
void cyg_pci_read_config_uint16( cyg_pci_device_id devid, cyg_uint8 offset, cyg_uint16 *val );
void cyg_pci_read_config_uint32( cyg_pci_device_id devid, cyg_uint8 offset, cyg_uint32 *val );</PRE>
<P CLASS="Body">
<A NAME="pgfId=1158466">
 </A>
These functions read registers of the appropriate size from the configuration space of the given device. They should mainly be used to access registers that are device specific. General PCI registers are best accessed through cyg_pci_get_device_info().</P>
<PRE CLASS="CodeExampleWide"><A NAME="pgfId=1158471"> </A>
void cyg_pci_write_config_uint8( cyg_pci_device_id devid, cyg_uint8 offset, cyg_uint8 val );
void cyg_pci_write_config_uint16( cyg_pci_device_id devid, cyg_uint8 offset, cyg_uint16 val );
void cyg_pci_write_config_uint32( cyg_pci_device_id devid, cyg_uint8 offset, cyg_uint32 val );</PRE>
<P CLASS="Body">
<A NAME="pgfId=1158476">
 </A>
These functions write registers of the appropriate size to the configuration space of the given device. They should mainly be used to access registers that are device specific. General PCI registers are best accessed through cyg_pci_get_device_info(). Writing the general registers this way may render the contents of a cyg_pci_device structure invalid.</P>
<H3 CLASS="Heading2">
<A NAME="pgfId=1158486">
 </A>
Resource allocation</H3>
<P CLASS="Body">
<A NAME="pgfId=1158491">
 </A>
These routines allocate memory and IO space to PCI devices.</P>
<PRE CLASS="CodeExampleWide"><A NAME="pgfId=1158496"> </A>
cyg_bool cyg_pci_configure_device( cyg_pci_device *dev_info )</PRE>
<P CLASS="Body">
<A NAME="pgfId=1158500">
 </A>
Allocate memory and IO space to all base address registers using the current memory and IO base addresses in the library. The allocated base addresses, translated into directly usable values, will be put into the matching base_map[] entries in *dev_info. If *dev_info does not contain valid base_size[] entries, then the result is false. This function will also call cyg_pci_translate_interrupt() to put the interrupt vector into the hal_vector entry.</P>
<PRE CLASS="CodeExampleWide"><A NAME="pgfId=1158505"> </A>
cyg_bool cyg_pci_translate_interrupt( cyg_pci_device *dev_info, CYG_ADDRWORD *vec );</PRE>
<P CLASS="Body">
<A NAME="pgfId=1158510">
 </A>
Translate the device's PCI interrupt (INTA#-INTD#) to the associated HAL vector. This may also depend on which slot the device occupies. If the device may generate interrupts, the translated vector number will be stored in vec and the result is true. Otherwise the result is false.</P>
<PRE CLASS="CodeExampleWide"><A NAME="pgfId=1158515"> </A>
cyg_bool cyg_pci_allocate_memory( cyg_pci_device *dev_info,
                                          cyg_uint32 bar, 
                                          CYG_PCI_ADDRESS64 *base );
cyg_bool cyg_pci_allocate_io( cyg_pci_device *dev_info,
                                          cyg_uint32 bar, 
                                      CYG_PCI_ADDRESS32 *base );</PRE>
<P CLASS="Body">
<A NAME="pgfId=1158520">
 </A>
These routines allocate memory or IO space to the base address register indicated by bar. The base address in *base will be correctly aligned and the address of the next free location will be written back into it if the allocation succeeds. If the base address register is of the wrong type for this allocation, or dev_info does not contain valid base_size[] entries, the result is false. These functions allow a device driver to set up its own mappings if it wants. Most devices should probably use cyg_pci_configure_device().</P>
<PRE CLASS="CodeExampleWide"><A NAME="pgfId=1158525"> </A>
void cyg_pci_set_memory_base( CYG_PCI_ADDRESS64 base );
void cyg_pci_set_io_base( CYG_PCI_ADDRESS32 base );</PRE>
<P CLASS="Body">
<A NAME="pgfId=1158530">
 </A>
These routines set the base addresses for memory and IO mappings to be used by the memory allocation routines. Normally these base addresses will be set to default values based on the platform. These routines allow these to be changed by application code if necessary.</P>
<H3 CLASS="Heading2">
<A NAME="pgfId=1158540">
 </A>
PCI Library Hardware API</H3>
<P CLASS="Body">
<A NAME="pgfId=1158544">
 </A>
This API is used by the PCI library to access the PCI bus configuration space. Although it should not normally be necessary, this API may also be used by device driver or application code to perform PCI bus operations not supported by the PCI library.</P>
<PRE CLASS="CodeExampleWide"><A NAME="pgfId=1158550"> </A>
void cyg_pcihw_init(void);</PRE>
<P CLASS="Body">
<A NAME="pgfId=1158555">
 </A>
Initialize the PCI hardware so that the configuration space may be accessed.</P>
<PRE CLASS="CodeExampleWide"><A NAME="pgfId=1158559"> </A>
void cyg_pcihw_read_config_uint8( cyg_uint8 bus, cyg_uint8 devfn, cyg_uint8 offset, cyg_uint8 *val);
void cyg_pcihw_read_config_uint16( cyg_uint8 bus, cyg_uint8 devfn, cyg_uint8 offset, cyg_uint16 *val);
void cyg_pcihw_read_config_uint32( cyg_uint8 bus, cyg_uint8 devfn, cyg_uint8 offset, cyg_uint32 *val);</PRE>
<P CLASS="Body">
<A NAME="pgfId=1158564">
 </A>
These functions read a register of the appropriate size from the PCI configuration space at an address composed from the bus, devfn and offset arguments.</P>
<PRE CLASS="CodeExampleWide"><A NAME="pgfId=1158569"> </A>
void cyg_pcihw_write_config_uint8( cyg_uint8 bus, cyg_uint8 devfn, cyg_uint8 offset, cyg_uint8 val);
void cyg_pcihw_write_config_uint16( cyg_uint8 bus, cyg_uint8 devfn, cyg_uint8 offset, cyg_uint16 val);
void cyg_pcihw_write_config_uint32( cyg_uint8 bus, cyg_uint8 devfn, cyg_uint8 offset, cyg_uint32 val);</PRE>
<P CLASS="Body">
<A NAME="pgfId=1158574">
 </A>
These functions write a register of the appropriate size to the PCI configuration space at an address composed from the bus, devfn and offset arguments.</P>
<PRE CLASS="CodeExampleWide"><A NAME="pgfId=1158579"> </A>
cyg_bool cyg_pcihw_translate_interrupt( cyg_uint8 bus, cyg_uint8 devfn, CYG_ADDRWORD *vec);</PRE>
<P CLASS="Body">
<A NAME="pgfId=1158584">
 </A>
This function interrogates the device and determines which HAL interrupt vector it is connected to.</P>
<H3 CLASS="Heading2">
<A NAME="pgfId=1158594">
 </A>
HAL PCI support</H3>
<P CLASS="Body">
<A NAME="pgfId=1158598">
 </A>
HAL support consists of a set of C macros that provide the implementation of the low level PCI API.</P>
<PRE CLASS="CodeExampleWide"><A NAME="pgfId=1158604"> </A>
HAL_PCI_INIT()</PRE>
<P CLASS="Body">
<A NAME="pgfId=1158609">
 </A>
Initialize the PCI bus.</P>
<PRE CLASS="CodeExampleWide"><A NAME="pgfId=1158613"> </A>
HAL_PCI_READ_UINT8( bus, devfn, offset, val )
HAL_PCI_READ_UINT16( bus, devfn, offset, val )
HAL_PCI_READ_UINT32( bus, devfn, offset, val )</PRE>
<P CLASS="Body">
<A NAME="pgfId=1158618">
 </A>
Read a value from the PCI configuration space of the appropriate size at an address composed from the bus, devfn and offset.</P>
<PRE CLASS="CodeExampleWide"><A NAME="pgfId=1158623"> </A>
HAL_PCI_WRITE_UINT8( bus, devfn, offset, val )
HAL_PCI_WRITE_UINT16( bus, devfn, offset, val )
HAL_PCI_WRITE_UINT32( bus, devfn, offset, val )</PRE>
<P CLASS="Body">
<A NAME="pgfId=1158628">
 </A>
Write a value to the PCI configuration space of the appropriate size at an address composed from the bus, devfn and offset.</P>
<PRE CLASS="CodeExampleWide"><A NAME="pgfId=1158634"> </A>
HAL_PCI_TRANSLATE_INTERRUPT( bus, devfn, *vec, valid )</PRE>
<P CLASS="Body">
<A NAME="pgfId=1158639">
 </A>
Translate the device's interrupt line into a HAL interrupt vector.</P>
<PRE CLASS="CodeExampleWide"><A NAME="pgfId=1158643"> </A>
HAL_PCI_ALLOC_BASE_MEMORY
HAL_PCI_ALLOC_BASE_IO</PRE>
<P CLASS="Body">
<A NAME="pgfId=1158648">
 </A>
These macros define the default base addresses used to initialize the memory and IO allocation pointers.</P>
<PRE CLASS="CodeExampleWide"><A NAME="pgfId=1158653"> </A>
HAL_PCI_PHYSICAL_MEMORY_BASE
HAL_PCI_PHYSICAL_IO_BASE</PRE>
<P CLASS="Body">
<A NAME="pgfId=1158658">
 </A>
PCI memory and IO range do not always correspond directly to physical memory or IO addresses. Frequently the PCI address spaces are windowed into the processor's address range at some offset. These macros define offsets to be added to the PCI base addresses to translate PCI bus addresses into physical memory addresses that can be used to access the allocated memory or IO space.</P>
<H3 CLASS="Label">
<A NAME="pgfId=1158666">
 </A>
NOTE</H3>
<P CLASS="Note">
<A NAME="pgfId=1158670">
 </A>
The chunk of PCI memory space directly addressable though the window by the CPU may be smaller than the amount of PCI memory actually provided. In that case drivers will have to access PCI memory space in segments. Doing this will be platform specific and is currently beyond the scope of the HAL.</P>
</DIV>
<HR ALIGN="center"><TABLE STYLE="ECOS" WIDTH="98%" BORDER="0" ALIGN="LEFT" CELLPADDING="1"><TR><TH COLSPAN="3" ALIGN="center"><P CLASS="Gotos">The eCos PCI Library</P></TH></TR><TR><TD  ALIGN="center"><P CLASS="Gotos"><A HREF="ecos-ref.2.html">To Contents</A></P></TD><TD  ALIGN="center"><P CLASS="Gotos"><A HREF="ecos-ref.c2.html">To&nbsp;previous&nbsp;page</A></P></TD><TD  ALIGN="center"><P CLASS="Gotos"><A HREF="ecos-ref.e.html">To&nbsp;next&nbsp;page</A></P></TD></TR></TABLE></BODY>
</HTML>
