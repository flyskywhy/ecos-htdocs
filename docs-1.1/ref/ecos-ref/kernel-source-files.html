<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML
><HEAD
><TITLE
>Kernel source files</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet version 1.19"><LINK
REL="HOME"
TITLE="eCosTM Reference Manual"
HREF="ecos-ref.html"><LINK
REL="UP"
TITLE="A tour of the kernel sources"
HREF="a-tour-of-the-kernel-sources.html"><LINK
REL="PREVIOUS"
TITLE="A tour of the kernel sources"
HREF="a-tour-of-the-kernel-sources.html"><LINK
REL="NEXT"
TITLE="Kernel APIs"
HREF="kernel-apis.html"></HEAD
><BODY
><DIV
CLASS="NAVHEADER"
><TABLE
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="3"
ALIGN="center"
><SPAN
CLASS="PRODUCTNAME"
>eCos</SPAN
><SUP
><FONT
SIZE="-1"
>TM</FONT
></SUP
> Reference Manual</TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="bottom"
><A
HREF="a-tour-of-the-kernel-sources.html"
>Prev</A
></TD
><TD
WIDTH="80%"
ALIGN="center"
VALIGN="bottom"
>Chapter 2. A tour of the kernel sources</TD
><TD
WIDTH="10%"
ALIGN="right"
VALIGN="bottom"
><A
HREF="kernel-apis.html"
>Next</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><H1
CLASS="SECT1"
><A
NAME="KERNEL-SOURCE-FILES"
>Kernel source files</A
></H1
><P
>	  The kernel source directory
	  (<TT
CLASS="FILENAME"
>Cygnus/eCos/packages/kernel/v1_1/src</TT
>)
	  is divided into a number of sub-directories each containing
	  the source files for a particular kernel subsystem.  These
	  sources divide into two classes: those that are generic to
	  all configurations, and those that are specific to a
	  particular configuration.
    </P
><H2
CLASS="SECT2"
><A
NAME="SCHED-SUBDIRECTORY"
>Sched subdirectory</A
></H2
><P
></P
><DL
><DT
><TT
CLASS="FILENAME"
>sched/sched.cxx</TT
></DT
><DD
><P
>		This contains the implementation of the base scheduler
		classes.  The most important function here is
		<TT
CLASS="FUNCTION"
><B
>Cyg_Scheduler::unlock_inner()</B
></TT
>
		which runs DSRs and performs any rescheduling and
		thread switching.</P
></DD
><DT
><TT
CLASS="FILENAME"
>sched/bitmap.cxx</TT
></DT
><DD
><P
>		  This contains the bitmap scheduler implementation.
		  It represents each runnable thread with a bit in a
		  bitmap. Each thread must have a unique priority and
		  there is a strict upper limit on the number of
		  threads allowed.</P
></DD
><DT
><TT
CLASS="FILENAME"
>sched/mlqueue.cxx</TT
></DT
><DD
><P
>		  This contains the multi-level queue scheduler
		  implementation. It implements a number of thread
		  priorities and is capable of timeslicing between
		  threads at the same priority.  This scheduler can
		  also support priority inheritance.</P
></DD
><DT
><TT
CLASS="FILENAME"
>sched/lottery.cxx</TT
></DT
><DD
><P
>		  This contains the lottery scheduler implementation.
		  This implements a CPU share scheduler based on
		  threads holding a number of lottery tickets.  At the
		  start of each time quantum, a random number is
		  generated and the thread holding the matching ticket
		  is scheduled. Compensation tickets and ticket
		  donation allow fair sharing for I/O bound threads
		  and an equivalent mechanism to priority
		  inheritance.</P
><BLOCKQUOTE
CLASS="NOTE"
><P
><B
>Note: </B
>This scheduler is experimental, and is
		    meant to test the behavior of other parts of the
		    kernel with a non-orthodox scheduler.  It is not
		    meant to be used for real applications.  It is
		    currently under development and is
		    incomplete.</P
></BLOCKQUOTE
></DD
></DL
><H2
CLASS="SECT2"
><A
NAME="AEN322"
>Common subdirectory</A
></H2
><P
></P
><DL
><DT
><TT
CLASS="FILENAME"
>common/thread.cxx</TT
></DT
><DD
><P
>		  This implements the basic thread classes.  The
		  functions in this file implement the basic thread
		  controls to sleep and wake threads, change
		  priorities and delay and timeout. Also defined here
		  is the idle thread that runs when there is nothing
		  else to do.</P
></DD
><DT
><TT
CLASS="FILENAME"
>common/clock.cxx</TT
></DT
><DD
><P
>		  This implements the counter, clock and alarm
		  functions. Also defined here is the system real-time
		  clock that is used to drive timeslicing, delays and
		  timeouts.</P
></DD
><DT
><TT
CLASS="FILENAME"
>common/kapi.cxx</TT
></DT
><DD
><P
>		  This implements a C API to the basic kernel
		  functions.</P
></DD
><DT
><TT
CLASS="FILENAME"
>common/memcpy.c</TT
>, <TT
CLASS="FILENAME"
>common/memset.c</TT
></DT
><DD
><P
>		  Standard ANSI memcpy and memset operations; these
		  are here because the compiler may invoke them for
		  structure operations regardless of the presence of a
		  C library.</P
></DD
></DL
><H2
CLASS="SECT2"
><A
NAME="AEN347"
>Interrupt subdirectory</A
></H2
><P
></P
><DL
><DT
><TT
CLASS="FILENAME"
>intr/intr.cxx</TT
></DT
><DD
><P
>		  This implements the Interrupt class.  Most of this code
		  is concerned with posting and calling DSRs.  The
		  remainder of the interrupt handling code is machine
		  specific and is in <TT
CLASS="FILENAME"
>hal_intr.cxx</TT
>
		  in the HAL directory.</P
></DD
></DL
><H2
CLASS="SECT2"
><A
NAME="AEN356"
>Synchronization subdirectory</A
></H2
><P
></P
><DL
><DT
><TT
CLASS="FILENAME"
>sync/mutex.cxx</TT
></DT
><DD
><P
>	      This contains the implementation of mutexes and
	      condition variables. Mutexes can optionally be
	      configured to use a priority inheritance mechanism
	      supplied by the scheduler.</P
></DD
><DT
><TT
CLASS="FILENAME"
>sync/cnt_sem.cxx</TT
></DT
><DD
><P
>	      This contains the implementation of counting
	      semaphores.</P
></DD
><DT
><TT
CLASS="FILENAME"
>sync/cnt_sem2.cxx</TT
></DT
><DD
><P
>	      This contains the alternate implementation of counting
		  semaphores which implements precise µITRON
		  semantics.</P
></DD
><DT
><TT
CLASS="FILENAME"
>sync/bin_sem.cxx</TT
></DT
><DD
><P
>	      This contains the implementation of binary
	      semaphores.</P
></DD
><DT
><TT
CLASS="FILENAME"
>sync/mbox.cxx</TT
></DT
><DD
><P
>		  This contains wrapper functions for a message box of
		  (<SPAN
CLASS="TYPE"
>void *</SPAN
>) values.  The implementation is
		  the template defined in
		  <TT
CLASS="FILENAME"
>include/mboxt.hxx</TT
> which
		  <TT
CLASS="FILENAME"
>include/mboxt.inl</TT
> implements in
		  turn.  Message boxes exist in the kernel
		  specifically to support µITRON compatibility.</P
></DD
><DT
><TT
CLASS="FILENAME"
>sync/flag.cxx</TT
></DT
><DD
><P
>	      This contains the implementation of flag objects.  Flag
	      objects exist in the kernel specifically to support
		  µITRON compatibility.</P
></DD
></DL
><H2
CLASS="SECT2"
><A
NAME="AEN392"
>Memory management subdirectory</A
></H2
><P
></P
><DL
><DT
><TT
CLASS="FILENAME"
>mem/memfixed.cxx</TT
></DT
><DD
><P
>	      This contains the wrapper functions for a fixed-block
		  allocation memory manager.  The actual
		  implementation is in two parts:
		  <TT
CLASS="FILENAME"
>include/mfiximpl.hxx</TT
> implements
		  the fixed-block memory management algorithms, and
		  template <TT
CLASS="FILENAME"
>include/mempoolt.hxx</TT
>
		  implements thread safety and waiting for memory
		  management classes.  These are combined in
		  <TT
CLASS="FILENAME"
>memfixed.cxx</TT
>. Memory pools
		  exist in the kernel specifically to support µITRON
		  compatibility.</P
></DD
><DT
><TT
CLASS="FILENAME"
>mem/memvar.cxx</TT
></DT
><DD
><P
>		  This contains the wrapper functions for a
		  variable-block allocation memory manager.  The
		  actual implementation is in two parts:
		  <TT
CLASS="FILENAME"
>include/mvarimpl.hxx</TT
> implements
		  the variable-block memory management algorithms, and
		  template <TT
CLASS="FILENAME"
>include/mempoolt.hxx</TT
>
		  implements thread safety and waiting for memory
		  management classes.  These are combined in
		  <TT
CLASS="FILENAME"
>memvar.cxx</TT
>. Memory pools exist
		  in the kernel specifically to support µITRON
		  compatibility.</P
></DD
></DL
><H2
CLASS="SECT2"
><A
NAME="AEN411"
>Instrumentation subdirectory</A
></H2
><P
></P
><DL
><DT
><TT
CLASS="FILENAME"
>instrmnt/meminst.cxx</TT
></DT
><DD
><P
>		  This contains an implementation of the
		  instrumentation mechanism that stores
		  instrumentation records in a circular buffer in
		  memory.  The size of this buffer is
		  configurable.  The instrumentation flags mechanism
		  allows the generation of instrumentation records to
		  be controlled on a per-record basis.  The header
		  file <TT
CLASS="FILENAME"
>cyg/kernel/instrmnt.h</TT
>
		  contains macros to generate instrumentation records
		  in various places, and may be configured to only
		  generate instrumentation records where
		  required.</P
></DD
><DT
><TT
CLASS="FILENAME"
>instrmnt/nullinst.cxx</TT
></DT
><DD
><P
>		  This contains an implementation of the
		  instrumentation mechanism that does nothing.  By
		  substituting its object file
		  <TT
CLASS="FILENAME"
>nullinst.o</TT
> for
		  <TT
CLASS="FILENAME"
>meminst.o</TT
> in a build, the
		  instrumentation mechanism may be disabled without
		  recompiling.</P
></DD
></DL
><H2
CLASS="SECT2"
><A
NAME="AEN427"
>Trace subdirectory</A
></H2
><P
></P
><DL
><DT
><TT
CLASS="FILENAME"
>trace/simple.cxx</TT
></DT
><DD
><P
>		  This contains an implementation of the trace and
		  assert mechanisms that output textual messages via a
		  set of externally defined functions.  These are
		  currently supplied by the code in
		  <TT
CLASS="FILENAME"
>trace/diag.c</TT
> but may be
		  supplied by a device driver in the future.</P
></DD
><DT
><TT
CLASS="FILENAME"
>trace/fancy.cxx</TT
></DT
><DD
><P
>		  This contains a (fancier) implementation of the
		  trace and assert mechanisms that output textual
		  messages via a set of externally defined functions.
		  These are currently supplied by the code in
		  <TT
CLASS="FILENAME"
>trace/diag.c</TT
> but may be
		  supplied by a device driver in the future.</P
><P
>		  This more elaborate view was introduced mainly to
		  validate the trace and assertion macros during
		  development.
		</P
></DD
><DT
><TT
CLASS="FILENAME"
>trace/null.cxx</TT
></DT
><DD
><P
>		  This contains an implementation of the trace and
		  assert mechanisms that do nothing.  By substituting
		  its object file <TT
CLASS="FILENAME"
>null.o</TT
> for
		  <TT
CLASS="FILENAME"
>simple.o</TT
> in a build, the trace
		  mechanisms may be disabled without recompiling.</P
></DD
><DT
><TT
CLASS="FILENAME"
>trace/diag.c</TT
></DT
><DD
><P
>	      This contains a number of diagnostic routines that use
	      the HAL supplied diagnostic output mechanism to format
	      and print strings and numbers.  There is currently no
	      formatted output.</P
></DD
><DT
><TT
CLASS="FILENAME"
>trace/tcdiag.c</TT
></DT
><DD
><P
>	      This contains an implementation of the testing internal
	      API which uses the kernel's diagnostic routines to
	      perform output.</P
></DD
></DL
><H2
CLASS="SECT2"
><A
NAME="AEN460"
>Sload subdirectory</A
></H2
><P
>	This contains the sources of a simple S-Record loader that may
	be used in a ROM for various microprocessor development boards
	to download code via a serial port.</P
><H2
CLASS="SECT2"
><A
NAME="AEN463"
>HAL source files</A
></H2
><P
>	The HAL is divided into architecture- and platform-specific
	    files.  For each architecture supported, there is an
	    <TT
CLASS="FILENAME"
>arch</TT
> directory, containing files
	    generic to that architecture, and a
	    <TT
CLASS="FILENAME"
>platform</TT
> directory, containing files
	    specific to each platform supported.</P
><P
>	Amongst the architectures supported are: the PowerPC, the Tx39
	and the MN10300.  To find the code corresponding to each
	architecture, substitute "powerpc", "mips" and "mn10300",
	respectively, for "ARCH" in the following file descriptions.
	Similarly substitute the appropriate platform name
	representing your development board for "PLATFORM".</P
><H2
CLASS="SECT2"
><A
NAME="AEN469"
>Architecture files</A
></H2
><P
></P
><DL
><DT
><TT
CLASS="FILENAME"
>ARCH/arch/v1_1/include/basetype.h</TT
></DT
><DD
><P
>	      This file is used to define the base architecture
	      configuration such as endianness and word size.</P
></DD
><DT
><TT
CLASS="FILENAME"
>ARCH/arch/v1_1/include/hal_arch.h</TT
></DT
><DD
><P
>	      This file contains macros that implement various
	      architecture-specific functions.  The most important
	      macros here are the thread context initialization and
	      switch macros that are used to implement
	      multithreading.</P
></DD
><DT
><TT
CLASS="FILENAME"
>ARCH/arch/v1_1/include/hal_intr.h</TT
></DT
><DD
><P
>	      This file contains the HAL support for interrupt
	      management and clock support.</P
></DD
><DT
><TT
CLASS="FILENAME"
>ARCH/arch/v1_1/include/hal_io.h</TT
></DT
><DD
><P
>	      This file contains the HAL support for accessing
	      hardware registers.  It provides a portable API that
	      allows more generic device drivers to be written.</P
></DD
><DT
><TT
CLASS="FILENAME"
>ARCH/arch/v1_1/include/hal_cache.h</TT
></DT
><DD
><P
>		  This file contains macros to control any caches that
		  may be present.</P
></DD
><DT
><TT
CLASS="FILENAME"
>ARCH/arch/v1_1/src/vectors.S</TT
></DT
><DD
><P
>		  This is an assembly code file that contains the code
		  to handle interrupt and exception vectors.  Since
		  system reset can also be considered an exception,
		  this is handled here also.  Interrupts are currently
		  handled by placing a stub routine in the hardware
		  vector which calls a Vector Service Routine via an
		  indirection table. There is a API to allow
		  user-defined VSRs to be installed.  The default VSR
		  reads the interrupt controller registers and decodes
		  the interrupt source into an offset into a further
		  table of interrupt service routines.  It also
		  handles interrupt cleanup, which may result in the
		  execution of deferred service routines (DSRs) and
		  the preemption of the current thread.</P
></DD
><DT
><TT
CLASS="FILENAME"
>ARCH/arch/v1_1/src/context.S</TT
></DT
><DD
><P
>If present, this is an assembly code
		  file that contains the code to support thread
		  contexts.  The routines to switch between various
		  contexts, as well as initialize a  thread context
		  may be present in this file.</P
></DD
><DT
><TT
CLASS="FILENAME"
>ARCH/arch/v1_1/src/hal_misc.c</TT
></DT
><DD
><P
>		  This file contains the implementation of various
		  miscellaneous HAL routines that are needed by the
		  kernel or C++ runtime.</P
></DD
></DL
><H2
CLASS="SECT2"
><A
NAME="AEN512"
>Platform files</A
></H2
><P
></P
><DL
><DT
><TT
CLASS="FILENAME"
>ARCH/PLATFORM/v1_1/include/hal_diag.h</TT
></DT
><DD
><P
>	      This file contains the definitions of macros that
	      support the HAL diagnostic output mechanism.</P
></DD
><DT
><TT
CLASS="FILENAME"
>ARCH/PLATFORM/v1_1/src/hal_diag.c</TT
></DT
><DD
><P
>	      This file contain the implementation of the HAL
	      diagnostic output mechanism.</P
></DD
><DT
><TT
CLASS="FILENAME"
>ARCH/PLATFORM/v1_1/src/PLATFORM.S</TT
></DT
><DD
><P
>		  This is an assembler file that contains any
		  platform-specific code.  It often contains platform
		  initialization code called from vectors.S.</P
></DD
><DT
><TT
CLASS="FILENAME"
>ARCH/PLATFORM/v1_1/src/PLATFORM.ld</TT
></DT
><DD
><P
>	      This is a linker script that is used to create an
	      executable that will execute on the platform.  It
	      correctly places code and data in ROM or RAM depending
	      on the configuration.</P
></DD
></DL
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="a-tour-of-the-kernel-sources.html"
>Prev</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="ecos-ref.html"
>Home</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="kernel-apis.html"
>Next</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>A tour of the kernel sources</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="a-tour-of-the-kernel-sources.html"
>Up</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>Kernel APIs</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>